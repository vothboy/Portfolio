{"ast":null,"code":"/*\r\n * @copyright\r\n * Copyright Â© Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\n'use strict';\n\nvar _ = require('underscore');\n/**\r\n * Constructs a new in memory token cache.\r\n * @constructor\r\n */\n\n\nfunction MemoryCache() {\n  this._entries = [];\n}\n/**\r\n * Removes a collection of entries from the cache in a single batch operation.\r\n * @param  {Array}   entries  An array of cache entries to remove.\r\n * @param  {Function} callback This function is called when the operation is complete.  Any error is provided as the\r\n *                             first parameter.\r\n */\n\n\nMemoryCache.prototype.remove = function (entries, callback) {\n  var updatedEntries = _.filter(this._entries, function (element) {\n    if (_.findWhere(entries, element)) {\n      return false;\n    }\n\n    return true;\n  });\n\n  this._entries = updatedEntries;\n  callback();\n};\n/**\r\n * Adds a collection of entries to the cache in a single batch operation.\r\n * @param {Array}   entries  An array of entries to add to the cache.\r\n * @param  {Function} callback This function is called when the operation is complete.  Any error is provided as the\r\n *                             first parameter.\r\n */\n\n\nMemoryCache.prototype.add = function (entries, callback) {\n  // Remove any entries that are duplicates of the existing\n  // cache elements.\n  _.each(this._entries, function (element) {\n    _.each(entries, function (addElement, index) {\n      if (_.isEqual(element, addElement)) {\n        entries[index] = null;\n      }\n    });\n  }); // Add the new entries to the end of the cache.\n\n\n  entries = _.compact(entries);\n\n  for (var i = 0; i < entries.length; i++) {\n    this._entries.push(entries[i]);\n  }\n\n  callback(null, true);\n};\n/**\r\n * Finds all entries in the cache that match all of the passed in values.\r\n * @param  {object}   query    This object will be compared to each entry in the cache.  Any entries that\r\n *                             match all of the values in this object will be returned.  All the values\r\n *                             in the passed in object must match values in a potentialy returned object\r\n *                             exactly.  The returned object may have more values than the passed in query\r\n *                             object.\r\n * @param  {TokenCacheFindCallback} callback\r\n */\n\n\nMemoryCache.prototype.find = function (query, callback) {\n  var results = _.where(this._entries, query);\n\n  callback(null, results);\n};\n\nmodule.exports = MemoryCache;","map":null,"metadata":{},"sourceType":"script"}