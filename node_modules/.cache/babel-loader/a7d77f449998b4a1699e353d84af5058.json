{"ast":null,"code":"/*\r\n * @copyright\r\n * Copyright Â© Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\n'use strict';\n\nvar request = require('request');\n\nvar url = require('url');\n\nvar DOMParser = require('xmldom').DOMParser;\n\nvar _ = require('underscore');\n\nvar Logger = require('./log').Logger;\n\nvar util = require('./util');\n\nvar xmlutil = require('./xmlutil');\n\nvar select = xmlutil.xpathSelect;\n\nvar Namespaces = require('./constants').XmlNamespaces;\n\nvar WSTrustVersion = require('./constants').WSTrustVersion;\n/**\r\n * Create a new Mex object.\r\n * @private\r\n * @constructor\r\n * @param {object} callContext Contains any context information that applies to the request.\r\n * @param {string} url  The url of the mex endpoint.\r\n */\n\n\nfunction Mex(callContext, url) {\n  this._log = new Logger('MEX', callContext._logContext);\n  this._callContext = callContext;\n  this._url = url;\n  this._dom = null;\n  this._mexDoc = null;\n  this._usernamePasswordPolicy = {};\n\n  this._log.verbose('Mex created');\n\n  this._log.verbose('Mex created with url: ' + url, true);\n}\n/**\r\n* Returns the policy containing IDP url and wstrust version from which a username passwowrd can be exchanged for a token.\r\n* @instance\r\n* @memberOf Mex\r\n* @name usernamePasswordPolicy\r\n*/\n\n\nObject.defineProperty(Mex.prototype, 'usernamePasswordPolicy', {\n  get: function get() {\n    return this._usernamePasswordPolicy;\n  }\n});\n/**\r\n* @callback DiscoverCallback\r\n* @memberOf Mex\r\n* @param {object} error\r\n*/\n\n/**\r\n* Performs Mex discovery.  This method will retrieve the mex document, parse it, and extract\r\n* the username password ws-trust endpoint.\r\n* @private\r\n* @param {Mex.DiscoverCallback}  callback  Called when discover is complete.\r\n*/\n\nMex.prototype.discover = function (callback) {\n  this._log.verbose('Retrieving mex');\n\n  this._log.verbose('Retrieving mex at: ' + this._url);\n\n  var self = this;\n  var options = util.createRequestOptions(self, {\n    headers: {\n      'Content-Type': 'application/soap+xml'\n    }\n  });\n  request.get(this._url, options, util.createRequestHandler('Mex Get', this._log, callback, function (response, body) {\n    try {\n      self._mexDoc = body;\n      var options = {\n        errorHandler: self._log.error\n      };\n      self._dom = new DOMParser(options).parseFromString(self._mexDoc);\n\n      self._parse(callback);\n\n      return;\n    } catch (err) {\n      self._log.error('Failed to parse mex response in to DOM', err, true);\n\n      callback(err);\n    }\n  }));\n};\n\nvar TRANSPORT_BINDING_XPATH = 'wsp:ExactlyOne/wsp:All/sp:TransportBinding';\nvar TRANSPORT_BINDING_2005_XPATH = 'wsp:ExactlyOne/wsp:All/sp2005:TransportBinding';\n/**\r\n* Checks a DOM policy node that is a potentialy appplicable username password policy\r\n* to ensure that it has the correct transport.\r\n* @private\r\n* @param {object} policyNode  The policy node to check.\r\n* @returns {string} If the policy matches the desired transport then the id of the policy is returned.\r\n*                   If not then null is returned.\r\n*/\n\nMex.prototype._checkPolicy = function (policyNode) {\n  var policyId = null;\n  var id = policyNode.getAttributeNS(Namespaces.wsu, 'Id');\n  var transportBindingNodes = select(policyNode, TRANSPORT_BINDING_XPATH);\n\n  if (0 === transportBindingNodes.length) {\n    transportBindingNodes = select(policyNode, TRANSPORT_BINDING_2005_XPATH);\n  }\n\n  if (0 !== transportBindingNodes.length) {\n    if (id) {\n      policyId = id;\n    }\n  }\n\n  if (policyId) {\n    this._log.verbose('found matching policy id');\n\n    this._log.verbose('found matching policy id: ' + policyId, true);\n  } else {\n    if (!id) {\n      id = '<no id>';\n    }\n\n    this._log.verbose('potential policy did not match required transport binding');\n\n    this._log.verbose('potential policy did not match required transport binding: ' + id, true);\n  }\n\n  return policyId;\n};\n/**\r\n* Finds all username password policies within the mex document.\r\n* @private\r\n* @param xpath The xpath expression for selecting username token nodes. \r\n* @returns {object} A map object that contains objects containing the id of username password polices.\r\n*/\n\n\nMex.prototype._selectUsernamePasswordPolicies = function (xpath) {\n  var policies = {};\n  var usernameTokenNodes = select(this._dom, xpath);\n\n  if (!usernameTokenNodes.length) {\n    this._log.warn('no username token policy nodes found');\n\n    return;\n  }\n\n  for (var i = 0; i < usernameTokenNodes.length; i++) {\n    var policyNode = usernameTokenNodes[i].parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode;\n\n    var id = this._checkPolicy(policyNode);\n\n    if (id) {\n      var idRef = '#' + id;\n      policies[idRef] = {\n        id: idRef\n      };\n    }\n  }\n\n  return _.isEmpty(policies) ? null : policies;\n};\n\nvar SOAP_ACTION_XPATH = 'wsdl:operation/soap12:operation/@soapAction';\nvar RST_SOAP_ACTION_13 = 'http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue';\nvar RST_SOAP_ACTION_2005 = 'http://schemas.xmlsoap.org/ws/2005/02/trust/RST/Issue';\nvar SOAP_TRANSPORT_XPATH = 'soap12:binding/@transport';\nvar SOAP_HTTP_TRANSPORT_VALUE = 'http://schemas.xmlsoap.org/soap/http';\n/**\r\n* Given a DOM binding node determines whether it matches the correct soap action and transport.\r\n* @private\r\n* @param {object} bindingNode   The DOM node to check.\r\n* @returns {bool}\r\n*/\n\nMex.prototype._checkSoapActionAndTransport = function (bindingNode) {\n  var soapTransportAttributes;\n  var soapAction;\n  var soapTransport;\n  var bindingName = bindingNode.getAttribute('name');\n  var soapActionAttributes = select(bindingNode, SOAP_ACTION_XPATH);\n\n  if (soapActionAttributes.length) {\n    soapAction = soapActionAttributes[0].value;\n    soapTransportAttributes = select(bindingNode, SOAP_TRANSPORT_XPATH);\n  }\n\n  if (soapTransportAttributes.length) {\n    soapTransport = soapTransportAttributes[0].value;\n  }\n\n  if (soapTransport === SOAP_HTTP_TRANSPORT_VALUE) {\n    if (soapAction === RST_SOAP_ACTION_13) {\n      this._log.verbose('foud binding matching Action and Transport: ' + bindingName);\n\n      return WSTrustVersion.WSTRUST13;\n    } else if (soapAction === RST_SOAP_ACTION_2005) {\n      this._log.verbose('found binding matching Action and Transport: ' + bindingName);\n\n      return WSTrustVersion.WSTRUST2005;\n    }\n  }\n\n  this._log.verbose('binding node did not match soap Action or Transport: ' + bindingName);\n\n  return WSTrustVersion.UNDEFINED;\n};\n/**\r\n* Given a map with policy id keys, finds the bindings in the mex document that are linked to thos policies.\r\n* @private\r\n* @param {object}   policies  A map with policy id keys.\r\n* @returns {object} a map of bindings id's to policy id's.\r\n*/\n\n\nMex.prototype._getMatchingBindings = function (policies) {\n  var bindings = {};\n  var bindingPolicyRefNodes = select(this._dom, '//wsdl:definitions/wsdl:binding/wsp:PolicyReference');\n\n  for (var i = 0; i < bindingPolicyRefNodes.length; i++) {\n    var node = bindingPolicyRefNodes[i];\n    var uri = node.getAttribute('URI');\n    var policy = policies[uri];\n\n    if (policy) {\n      var bindingNode = node.parentNode;\n      var bindingName = bindingNode.getAttribute('name');\n\n      var version = this._checkSoapActionAndTransport(bindingNode);\n\n      if (version !== WSTrustVersion.UNDEFINED) {\n        var bindingPolicy = {};\n        bindingPolicy.url = uri;\n        bindingPolicy.version = version;\n        bindings[bindingName] = bindingPolicy;\n      }\n    }\n  }\n\n  return _.isEmpty(bindings) ? null : bindings;\n};\n/**\r\n* Ensures that a url points to an SSL endpoint.\r\n* @private\r\n* @param {string} endpointUrl   The url to check.\r\n* @returns {bool}\r\n*/\n\n\nMex.prototype._urlIsSecure = function (endpointUrl) {\n  var parsedUrl = url.parse(endpointUrl);\n  return parsedUrl.protocol === 'https:';\n};\n\nvar PORT_XPATH = '//wsdl:definitions/wsdl:service/wsdl:port';\nvar ADDRESS_XPATH = 'wsa10:EndpointReference/wsa10:Address';\n/**\r\n* Finds all of the wsdl ports in the mex document that are associated with username password policies.  Augments\r\n* the passed in bindings with the endpoint url of the correct port.\r\n* @private\r\n* @param {object} bindings  A map of binding id's to policy id's.\r\n*/\n\nMex.prototype._getPortsForPolicyBindings = function (bindings, policies) {\n  var portNodes = select(this._dom, PORT_XPATH);\n\n  if (0 === portNodes.length) {\n    this._log.warning('no ports found');\n  }\n\n  for (var i = 0; i < portNodes.length; i++) {\n    var portNode = portNodes[i];\n    var bindingId = portNode.getAttribute('binding'); // Clear any prefix\n\n    var bindingIdParts = bindingId.split(':');\n    bindingId = bindingIdParts[bindingIdParts.length - 1];\n    var trustPolicy = bindings[bindingId];\n\n    if (trustPolicy) {\n      var bindingPolicy = policies[trustPolicy.url];\n\n      if (bindingPolicy && !bindingPolicy.url) {\n        bindingPolicy.version = trustPolicy.version;\n        var addressNode = select(portNode, ADDRESS_XPATH);\n\n        if (0 === addressNode) {\n          throw this._log.createError('no address nodes on port.');\n        }\n\n        var address = xmlutil.findElementText(addressNode[0]);\n\n        if (this._urlIsSecure(address)) {\n          bindingPolicy.url = address;\n        } else {\n          this._log.warn('skipping insecure endpoint: ' + address);\n        }\n      }\n    }\n  }\n};\n/**\r\n* Given a list of username password policies chooses one of them at random as the policy chosen by this Mex instance.\r\n* @private\r\n* @param {object} policies  A map of policy id's to an object containing username password ws-trust endpoint addresses.\r\n*/\n\n\nMex.prototype._selectSingleMatchingPolicy = function (policies) {\n  // if both wstrust13 and wstrust2005 policy exists, then choose wstrust13, otherwise choose whatever exists.\n  var matchingPolicies = _.filter(policies, function (policy) {\n    return policy.url ? true : false;\n  });\n\n  if (!matchingPolicies) {\n    this._log.warn('no policies found with an url');\n\n    return;\n  }\n\n  var wstrust13Policy = null,\n      wstrust2005Policy = null;\n\n  for (var i = 0; i < matchingPolicies.length; ++i) {\n    var matchingPolicy = matchingPolicies[i];\n\n    if (WSTrustVersion.WSTRUST13 === matchingPolicy.version) {\n      wstrust13Policy = matchingPolicy;\n    } else if (WSTrustVersion.WSTRUST2005 === matchingPolicy.version) {\n      wstrust2005Policy = matchingPolicy;\n    }\n  }\n\n  if (!wstrust13Policy && !wstrust2005Policy) {\n    this._log.warn('no policies found with an url');\n\n    this._usernamePasswordPolicy = null;\n    return;\n  }\n\n  this._usernamePasswordPolicy = wstrust13Policy ? wstrust13Policy : wstrust2005Policy;\n};\n/**\r\n* Parses the mex document previously retrieved.\r\n* @private\r\n* @param {Mex.DiscoverCallback} callback\r\n*/\n\n\nMex.prototype._parse = function (callback) {\n  var self = this;\n  var xpathExpression = '//wsdl:definitions/wsp:Policy/wsp:ExactlyOne/wsp:All/sp:SignedEncryptedSupportingTokens/wsp:Policy/sp:UsernameToken/wsp:Policy/sp:WssUsernameToken10';\n\n  var policies = self._selectUsernamePasswordPolicies(xpathExpression);\n\n  xpathExpression = '//wsdl:definitions/wsp:Policy/wsp:ExactlyOne/wsp:All/sp2005:SignedSupportingTokens/wsp:Policy/sp2005:UsernameToken/wsp:Policy/sp2005:WssUsernameToken10';\n\n  if (policies) {\n    _.extend(policies, self._selectUsernamePasswordPolicies(xpathExpression));\n  } else {\n    policies = self._selectUsernamePasswordPolicies(xpathExpression);\n  }\n\n  if (!policies) {\n    callback(self._log.createError('No matching policies'));\n    return;\n  }\n\n  var bindings = self._getMatchingBindings(policies);\n\n  if (!bindings) {\n    callback(self._log.createError('No matching bindings'));\n    return;\n  }\n\n  self._getPortsForPolicyBindings(bindings, policies);\n\n  self._selectSingleMatchingPolicy(policies);\n\n  var err = this._url ? undefined : this._log.createError('No ws-trust endpoints match requirements.');\n  callback(err);\n};\n\nmodule.exports = Mex;","map":null,"metadata":{},"sourceType":"script"}