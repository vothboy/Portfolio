{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nvar _os = _interopRequireDefault(require(\"os\"));\n\nvar _constants = _interopRequireDefault(require(\"constants\"));\n\nvar _tls = require(\"tls\");\n\nvar _msRestNodeauth = require(\"@azure/ms-rest-nodeauth\");\n\nvar _bulkLoad = _interopRequireDefault(require(\"./bulk-load\"));\n\nvar _debug = _interopRequireDefault(require(\"./debug\"));\n\nvar _events = require(\"events\");\n\nvar _instanceLookup = require(\"./instance-lookup\");\n\nvar _transientErrorLookup = require(\"./transient-error-lookup\");\n\nvar _packet = require(\"./packet\");\n\nvar _preloginPayload = _interopRequireDefault(require(\"./prelogin-payload\"));\n\nvar _login7Payload = _interopRequireDefault(require(\"./login7-payload\"));\n\nvar _ntlmPayload = _interopRequireDefault(require(\"./ntlm-payload\"));\n\nvar _request = _interopRequireDefault(require(\"./request\"));\n\nvar _rpcrequestPayload = _interopRequireDefault(require(\"./rpcrequest-payload\"));\n\nvar _sqlbatchPayload = _interopRequireDefault(require(\"./sqlbatch-payload\"));\n\nvar _messageIo = _interopRequireDefault(require(\"./message-io\"));\n\nvar _tokenStreamParser = require(\"./token/token-stream-parser\");\n\nvar _transaction = require(\"./transaction\");\n\nvar _errors = require(\"./errors\");\n\nvar _connector = require(\"./connector\");\n\nvar _library = require(\"./library\");\n\nvar _tdsVersions = require(\"./tds-versions\");\n\nvar _ntlm = require(\"./ntlm\");\n\nvar _depd = _interopRequireDefault(require(\"depd\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar deprecate = (0, _depd.default)('tedious'); // A rather basic state machine for managing a connection.\n// Implements something approximating s3.2.1.\n\nvar KEEP_ALIVE_INITIAL_DELAY = 30 * 1000;\nvar DEFAULT_CONNECT_TIMEOUT = 15 * 1000;\nvar DEFAULT_CLIENT_REQUEST_TIMEOUT = 15 * 1000;\nvar DEFAULT_CANCEL_TIMEOUT = 5 * 1000;\nvar DEFAULT_CONNECT_RETRY_INTERVAL = 500;\nvar DEFAULT_PACKET_SIZE = 4 * 1024;\nvar DEFAULT_TEXTSIZE = '2147483647';\nvar DEFAULT_DATEFIRST = 7;\nvar DEFAULT_PORT = 1433;\nvar DEFAULT_TDS_VERSION = '7_4';\nvar DEFAULT_LANGUAGE = 'us_english';\nvar DEFAULT_DATEFORMAT = 'mdy';\nvar CLEANUP_TYPE = {\n  NORMAL: 0,\n  REDIRECT: 1,\n  RETRY: 2\n};\n\nvar Connection = /*#__PURE__*/function (_events$EventEmitter) {\n  _inherits(Connection, _events$EventEmitter);\n\n  function Connection(config) {\n    var _this;\n\n    _classCallCheck(this, Connection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Connection).call(this));\n    _this.fedAuthRequired = void 0;\n    _this.fedAuthInfoToken = void 0;\n    _this.config = void 0;\n    _this.secureContext = void 0;\n    _this.inTransaction = void 0;\n    _this.transactionDescriptors = void 0;\n    _this.transactionDepth = void 0;\n    _this.isSqlBatch = void 0;\n    _this.curTransientRetryCount = void 0;\n    _this.transientErrorLookup = void 0;\n    _this.closed = void 0;\n    _this.loggedIn = void 0;\n    _this.loginError = void 0;\n    _this.debug = void 0;\n    _this.tokenStreamParser = void 0;\n    _this.ntlmpacket = void 0;\n    _this.ntlmpacketBuffer = void 0;\n    _this.routingData = void 0;\n    _this.state = void 0;\n    _this.resetConnectionOnNextRequest = void 0;\n    _this.attentionReceived = void 0;\n    _this.request = void 0;\n    _this.procReturnStatusValue = void 0;\n    _this.socket = void 0;\n    _this.messageBuffer = void 0;\n    _this.connectTimer = void 0;\n    _this.cancelTimer = void 0;\n    _this.requestTimer = void 0;\n    _this.retryTimer = void 0;\n\n    if (typeof config !== 'object' || config === null) {\n      throw new TypeError('The \"config\" argument is required and must be of type Object.');\n    }\n\n    if (typeof config.server !== 'string') {\n      throw new TypeError('The \"config.server\" property is required and must be of type string.');\n    }\n\n    _this.fedAuthRequired = false;\n    _this.fedAuthInfoToken = undefined;\n    var authentication;\n\n    if (config.authentication !== undefined) {\n      if (typeof config.authentication !== 'object' || config.authentication === null) {\n        throw new TypeError('The \"config.authentication\" property must be of type Object.');\n      }\n\n      var type = config.authentication.type;\n      var options = config.authentication.options === undefined ? {} : config.authentication.options;\n\n      if (typeof type !== 'string') {\n        throw new TypeError('The \"config.authentication.type\" property must be of type string.');\n      }\n\n      if (type !== 'default' && type !== 'ntlm' && type !== 'azure-active-directory-password' && type !== 'azure-active-directory-access-token' && type !== 'azure-active-directory-msi-vm' && type !== 'azure-active-directory-msi-app-service' && type !== 'azure-active-directory-service-principal-secret') {\n        throw new TypeError('The \"type\" property must one of \"default\", \"ntlm\", \"azure-active-directory-password\", \"azure-active-directory-access-token\", \"azure-active-directory-msi-vm\" or \"azure-active-directory-msi-app-service\" or \"azure-active-directory-service-principal-secret\".');\n      }\n\n      if (typeof options !== 'object' || options === null) {\n        throw new TypeError('The \"config.authentication.options\" property must be of type object.');\n      }\n\n      if (type === 'ntlm') {\n        if (typeof options.domain !== 'string') {\n          throw new TypeError('The \"config.authentication.options.domain\" property must be of type string.');\n        }\n\n        if (options.userName !== undefined && typeof options.userName !== 'string') {\n          throw new TypeError('The \"config.authentication.options.userName\" property must be of type string.');\n        }\n\n        if (options.password !== undefined && typeof options.password !== 'string') {\n          throw new TypeError('The \"config.authentication.options.password\" property must be of type string.');\n        }\n\n        authentication = {\n          type: 'ntlm',\n          options: {\n            userName: options.userName,\n            password: options.password,\n            domain: options.domain && options.domain.toUpperCase()\n          }\n        };\n      } else if (type === 'azure-active-directory-password') {\n        if (options.userName !== undefined && typeof options.userName !== 'string') {\n          throw new TypeError('The \"config.authentication.options.userName\" property must be of type string.');\n        }\n\n        if (options.password !== undefined && typeof options.password !== 'string') {\n          throw new TypeError('The \"config.authentication.options.password\" property must be of type string.');\n        }\n\n        authentication = {\n          type: 'azure-active-directory-password',\n          options: {\n            userName: options.userName,\n            password: options.password\n          }\n        };\n      } else if (type === 'azure-active-directory-access-token') {\n        if (typeof options.token !== 'string') {\n          throw new TypeError('The \"config.authentication.options.token\" property must be of type string.');\n        }\n\n        authentication = {\n          type: 'azure-active-directory-access-token',\n          options: {\n            token: options.token\n          }\n        };\n      } else if (type === 'azure-active-directory-msi-vm') {\n        if (options.clientId !== undefined && typeof options.clientId !== 'string') {\n          throw new TypeError('The \"config.authentication.options.clientId\" property must be of type string.');\n        }\n\n        if (options.msiEndpoint !== undefined && typeof options.msiEndpoint !== 'string') {\n          throw new TypeError('The \"config.authentication.options.msiEndpoint\" property must be of type string.');\n        }\n\n        authentication = {\n          type: 'azure-active-directory-msi-vm',\n          options: {\n            clientId: options.clientId,\n            msiEndpoint: options.msiEndpoint\n          }\n        };\n      } else if (type === 'azure-active-directory-msi-app-service') {\n        if (options.clientId !== undefined && typeof options.clientId !== 'string') {\n          throw new TypeError('The \"config.authentication.options.clientId\" property must be of type string.');\n        }\n\n        if (options.msiEndpoint !== undefined && typeof options.msiEndpoint !== 'string') {\n          throw new TypeError('The \"config.authentication.options.msiEndpoint\" property must be of type string.');\n        }\n\n        if (options.msiSecret !== undefined && typeof options.msiSecret !== 'string') {\n          throw new TypeError('The \"config.authentication.options.msiSecret\" property must be of type string.');\n        }\n\n        authentication = {\n          type: 'azure-active-directory-msi-app-service',\n          options: {\n            clientId: options.clientId,\n            msiEndpoint: options.msiEndpoint,\n            msiSecret: options.msiSecret\n          }\n        };\n      } else if (type === 'azure-active-directory-service-principal-secret') {\n        if (typeof options.clientId !== 'string') {\n          throw new TypeError('The \"config.authentication.options.clientId\" property must be of type string.');\n        }\n\n        if (typeof options.clientSecret !== 'string') {\n          throw new TypeError('The \"config.authentication.options.clientSecret\" property must be of type string.');\n        }\n\n        if (typeof options.tenantId !== 'string') {\n          throw new TypeError('The \"config.authentication.options.tenantId\" property must be of type string.');\n        }\n\n        authentication = {\n          type: 'azure-active-directory-service-principal-secret',\n          options: {\n            clientId: options.clientId,\n            clientSecret: options.clientSecret,\n            tenantId: options.tenantId\n          }\n        };\n      } else {\n        if (options.userName !== undefined && typeof options.userName !== 'string') {\n          throw new TypeError('The \"config.authentication.options.userName\" property must be of type string.');\n        }\n\n        if (options.password !== undefined && typeof options.password !== 'string') {\n          throw new TypeError('The \"config.authentication.options.password\" property must be of type string.');\n        }\n\n        authentication = {\n          type: 'default',\n          options: {\n            userName: options.userName,\n            password: options.password\n          }\n        };\n      }\n    } else {\n      authentication = {\n        type: 'default',\n        options: {\n          userName: undefined,\n          password: undefined\n        }\n      };\n    }\n\n    _this.config = {\n      server: config.server,\n      authentication: authentication,\n      options: {\n        abortTransactionOnError: false,\n        appName: undefined,\n        camelCaseColumns: false,\n        cancelTimeout: DEFAULT_CANCEL_TIMEOUT,\n        columnNameReplacer: undefined,\n        connectionRetryInterval: DEFAULT_CONNECT_RETRY_INTERVAL,\n        connectTimeout: DEFAULT_CONNECT_TIMEOUT,\n        connectionIsolationLevel: _transaction.ISOLATION_LEVEL.READ_COMMITTED,\n        cryptoCredentialsDetails: {},\n        database: undefined,\n        datefirst: DEFAULT_DATEFIRST,\n        dateFormat: DEFAULT_DATEFORMAT,\n        debug: {\n          data: false,\n          packet: false,\n          payload: false,\n          token: false\n        },\n        enableAnsiNull: true,\n        enableAnsiNullDefault: true,\n        enableAnsiPadding: true,\n        enableAnsiWarnings: true,\n        enableArithAbort: false,\n        enableConcatNullYieldsNull: true,\n        enableCursorCloseOnCommit: null,\n        enableImplicitTransactions: false,\n        enableNumericRoundabort: false,\n        enableQuotedIdentifier: true,\n        encrypt: true,\n        fallbackToDefaultDb: false,\n        instanceName: undefined,\n        isolationLevel: _transaction.ISOLATION_LEVEL.READ_COMMITTED,\n        language: DEFAULT_LANGUAGE,\n        localAddress: undefined,\n        maxRetriesOnTransientErrors: 3,\n        multiSubnetFailover: false,\n        packetSize: DEFAULT_PACKET_SIZE,\n        port: DEFAULT_PORT,\n        readOnlyIntent: false,\n        requestTimeout: DEFAULT_CLIENT_REQUEST_TIMEOUT,\n        rowCollectionOnDone: false,\n        rowCollectionOnRequestCompletion: false,\n        tdsVersion: DEFAULT_TDS_VERSION,\n        textsize: DEFAULT_TEXTSIZE,\n        trustServerCertificate: true,\n        useColumnNames: false,\n        useUTC: true,\n        lowerCaseGuids: false\n      }\n    };\n\n    if (config.options) {\n      if (config.options.port && config.options.instanceName) {\n        throw new Error('Port and instanceName are mutually exclusive, but ' + config.options.port + ' and ' + config.options.instanceName + ' provided');\n      }\n\n      if (config.options.abortTransactionOnError !== undefined) {\n        if (typeof config.options.abortTransactionOnError !== 'boolean' && config.options.abortTransactionOnError !== null) {\n          throw new TypeError('The \"config.options.abortTransactionOnError\" property must be of type string or null.');\n        }\n\n        _this.config.options.abortTransactionOnError = config.options.abortTransactionOnError;\n      }\n\n      if (config.options.appName !== undefined) {\n        if (typeof config.options.appName !== 'string') {\n          throw new TypeError('The \"config.options.appName\" property must be of type string.');\n        }\n\n        _this.config.options.appName = config.options.appName;\n      }\n\n      if (config.options.camelCaseColumns !== undefined) {\n        if (typeof config.options.camelCaseColumns !== 'boolean') {\n          throw new TypeError('The \"config.options.camelCaseColumns\" property must be of type boolean.');\n        }\n\n        _this.config.options.camelCaseColumns = config.options.camelCaseColumns;\n      }\n\n      if (config.options.cancelTimeout !== undefined) {\n        if (typeof config.options.cancelTimeout !== 'number') {\n          throw new TypeError('The \"config.options.cancelTimeout\" property must be of type number.');\n        }\n\n        _this.config.options.cancelTimeout = config.options.cancelTimeout;\n      }\n\n      if (config.options.columnNameReplacer) {\n        if (typeof config.options.columnNameReplacer !== 'function') {\n          throw new TypeError('The \"config.options.cancelTimeout\" property must be of type function.');\n        }\n\n        _this.config.options.columnNameReplacer = config.options.columnNameReplacer;\n      }\n\n      if (config.options.connectTimeout !== undefined) {\n        if (typeof config.options.connectTimeout !== 'number') {\n          throw new TypeError('The \"config.options.connectTimeout\" property must be of type number.');\n        }\n\n        _this.config.options.connectTimeout = config.options.connectTimeout;\n      }\n\n      if (config.options.connectionIsolationLevel !== undefined) {\n        _this.config.options.connectionIsolationLevel = config.options.connectionIsolationLevel;\n      }\n\n      if (config.options.connectTimeout !== undefined) {\n        if (typeof config.options.connectTimeout !== 'number') {\n          throw new TypeError('The \"config.options.connectTimeout\" property must be of type number.');\n        }\n\n        _this.config.options.connectTimeout = config.options.connectTimeout;\n      }\n\n      if (config.options.cryptoCredentialsDetails !== undefined) {\n        if (typeof config.options.cryptoCredentialsDetails !== 'object' || config.options.cryptoCredentialsDetails === null) {\n          throw new TypeError('The \"config.options.cryptoCredentialsDetails\" property must be of type Object.');\n        }\n\n        _this.config.options.cryptoCredentialsDetails = config.options.cryptoCredentialsDetails;\n      }\n\n      if (config.options.database !== undefined) {\n        if (typeof config.options.database !== 'string') {\n          throw new TypeError('The \"config.options.database\" property must be of type string.');\n        }\n\n        _this.config.options.database = config.options.database;\n      }\n\n      if (config.options.datefirst !== undefined) {\n        if (typeof config.options.datefirst !== 'number' && config.options.datefirst !== null) {\n          throw new TypeError('The \"config.options.datefirst\" property must be of type number.');\n        }\n\n        if (config.options.datefirst !== null && (config.options.datefirst < 1 || config.options.datefirst > 7)) {\n          throw new RangeError('The \"config.options.datefirst\" property must be >= 1 and <= 7');\n        }\n\n        _this.config.options.datefirst = config.options.datefirst;\n      }\n\n      if (config.options.dateFormat !== undefined) {\n        if (typeof config.options.dateFormat !== 'string' && config.options.dateFormat !== null) {\n          throw new TypeError('The \"config.options.dateFormat\" property must be of type string or null.');\n        }\n\n        _this.config.options.dateFormat = config.options.dateFormat;\n      }\n\n      if (config.options.debug) {\n        if (config.options.debug.data !== undefined) {\n          if (typeof config.options.debug.data !== 'boolean') {\n            throw new TypeError('The \"config.options.debug.data\" property must be of type boolean.');\n          }\n\n          _this.config.options.debug.data = config.options.debug.data;\n        }\n\n        if (config.options.debug.packet !== undefined) {\n          if (typeof config.options.debug.packet !== 'boolean') {\n            throw new TypeError('The \"config.options.debug.packet\" property must be of type boolean.');\n          }\n\n          _this.config.options.debug.packet = config.options.debug.packet;\n        }\n\n        if (config.options.debug.payload !== undefined) {\n          if (typeof config.options.debug.payload !== 'boolean') {\n            throw new TypeError('The \"config.options.debug.payload\" property must be of type boolean.');\n          }\n\n          _this.config.options.debug.payload = config.options.debug.payload;\n        }\n\n        if (config.options.debug.token !== undefined) {\n          if (typeof config.options.debug.token !== 'boolean') {\n            throw new TypeError('The \"config.options.debug.token\" property must be of type boolean.');\n          }\n\n          _this.config.options.debug.token = config.options.debug.token;\n        }\n      }\n\n      if (config.options.enableAnsiNull !== undefined) {\n        if (typeof config.options.enableAnsiNull !== 'boolean' && config.options.enableAnsiNull !== null) {\n          throw new TypeError('The \"config.options.enableAnsiNull\" property must be of type boolean or null.');\n        }\n\n        _this.config.options.enableAnsiNull = config.options.enableAnsiNull;\n      }\n\n      if (config.options.enableAnsiNullDefault !== undefined) {\n        if (typeof config.options.enableAnsiNullDefault !== 'boolean' && config.options.enableAnsiNullDefault !== null) {\n          throw new TypeError('The \"config.options.enableAnsiNullDefault\" property must be of type boolean or null.');\n        }\n\n        _this.config.options.enableAnsiNullDefault = config.options.enableAnsiNullDefault;\n      }\n\n      if (config.options.enableAnsiPadding !== undefined) {\n        if (typeof config.options.enableAnsiPadding !== 'boolean' && config.options.enableAnsiPadding !== null) {\n          throw new TypeError('The \"config.options.enableAnsiPadding\" property must be of type boolean or null.');\n        }\n\n        _this.config.options.enableAnsiPadding = config.options.enableAnsiPadding;\n      }\n\n      if (config.options.enableAnsiWarnings !== undefined) {\n        if (typeof config.options.enableAnsiWarnings !== 'boolean' && config.options.enableAnsiWarnings !== null) {\n          throw new TypeError('The \"config.options.enableAnsiWarnings\" property must be of type boolean or null.');\n        }\n\n        _this.config.options.enableAnsiWarnings = config.options.enableAnsiWarnings;\n      }\n\n      if (config.options.enableArithAbort !== undefined) {\n        if (typeof config.options.enableArithAbort !== 'boolean' && config.options.enableArithAbort !== null) {\n          throw new TypeError('The \"config.options.enableArithAbort\" property must be of type boolean or null.');\n        }\n\n        _this.config.options.enableArithAbort = config.options.enableArithAbort;\n      } else {\n        deprecate('The default value for `config.options.enableArithAbort` will change from `false` to `true` in the next major version of `tedious`. Set the value to `true` or `false` explicitly to silence this message.');\n      }\n\n      if (config.options.enableConcatNullYieldsNull !== undefined) {\n        if (typeof config.options.enableConcatNullYieldsNull !== 'boolean' && config.options.enableConcatNullYieldsNull !== null) {\n          throw new TypeError('The \"config.options.enableConcatNullYieldsNull\" property must be of type boolean or null.');\n        }\n\n        _this.config.options.enableConcatNullYieldsNull = config.options.enableConcatNullYieldsNull;\n      }\n\n      if (config.options.enableCursorCloseOnCommit !== undefined) {\n        if (typeof config.options.enableCursorCloseOnCommit !== 'boolean' && config.options.enableCursorCloseOnCommit !== null) {\n          throw new TypeError('The \"config.options.enableCursorCloseOnCommit\" property must be of type boolean or null.');\n        }\n\n        _this.config.options.enableCursorCloseOnCommit = config.options.enableCursorCloseOnCommit;\n      }\n\n      if (config.options.enableImplicitTransactions !== undefined) {\n        if (typeof config.options.enableImplicitTransactions !== 'boolean' && config.options.enableImplicitTransactions !== null) {\n          throw new TypeError('The \"config.options.enableImplicitTransactions\" property must be of type boolean or null.');\n        }\n\n        _this.config.options.enableImplicitTransactions = config.options.enableImplicitTransactions;\n      }\n\n      if (config.options.enableNumericRoundabort !== undefined) {\n        if (typeof config.options.enableNumericRoundabort !== 'boolean' && config.options.enableNumericRoundabort !== null) {\n          throw new TypeError('The \"config.options.enableNumericRoundabort\" property must be of type boolean or null.');\n        }\n\n        _this.config.options.enableNumericRoundabort = config.options.enableNumericRoundabort;\n      }\n\n      if (config.options.enableQuotedIdentifier !== undefined) {\n        if (typeof config.options.enableQuotedIdentifier !== 'boolean' && config.options.enableQuotedIdentifier !== null) {\n          throw new TypeError('The \"config.options.enableQuotedIdentifier\" property must be of type boolean or null.');\n        }\n\n        _this.config.options.enableQuotedIdentifier = config.options.enableQuotedIdentifier;\n      }\n\n      if (config.options.encrypt !== undefined) {\n        if (typeof config.options.encrypt !== 'boolean') {\n          throw new TypeError('The \"config.options.encrypt\" property must be of type boolean.');\n        }\n\n        _this.config.options.encrypt = config.options.encrypt;\n      }\n\n      if (config.options.fallbackToDefaultDb !== undefined) {\n        if (typeof config.options.fallbackToDefaultDb !== 'boolean') {\n          throw new TypeError('The \"config.options.fallbackToDefaultDb\" property must be of type boolean.');\n        }\n\n        _this.config.options.fallbackToDefaultDb = config.options.fallbackToDefaultDb;\n      }\n\n      if (config.options.instanceName !== undefined) {\n        if (typeof config.options.instanceName !== 'string') {\n          throw new TypeError('The \"config.options.instanceName\" property must be of type string.');\n        }\n\n        _this.config.options.instanceName = config.options.instanceName;\n        _this.config.options.port = undefined;\n      }\n\n      if (config.options.isolationLevel !== undefined) {\n        if (typeof config.options.isolationLevel !== 'number') {\n          throw new TypeError('The \"config.options.isolationLevel\" property must be of type number.');\n        }\n\n        _this.config.options.isolationLevel = config.options.isolationLevel;\n      }\n\n      if (config.options.language !== undefined) {\n        if (typeof config.options.language !== 'string' && config.options.language !== null) {\n          throw new TypeError('The \"config.options.language\" property must be of type string or null.');\n        }\n\n        _this.config.options.language = config.options.language;\n      }\n\n      if (config.options.localAddress !== undefined) {\n        if (typeof config.options.localAddress !== 'string') {\n          throw new TypeError('The \"config.options.localAddress\" property must be of type string.');\n        }\n\n        _this.config.options.localAddress = config.options.localAddress;\n      }\n\n      if (config.options.multiSubnetFailover !== undefined) {\n        if (typeof config.options.multiSubnetFailover !== 'boolean') {\n          throw new TypeError('The \"config.options.multiSubnetFailover\" property must be of type boolean.');\n        }\n\n        _this.config.options.multiSubnetFailover = config.options.multiSubnetFailover;\n      }\n\n      if (config.options.packetSize !== undefined) {\n        if (typeof config.options.packetSize !== 'number') {\n          throw new TypeError('The \"config.options.packetSize\" property must be of type number.');\n        }\n\n        _this.config.options.packetSize = config.options.packetSize;\n      }\n\n      if (config.options.port !== undefined) {\n        if (typeof config.options.port !== 'number') {\n          throw new TypeError('The \"config.options.port\" property must be of type number.');\n        }\n\n        if (config.options.port <= 0 || config.options.port >= 65536) {\n          throw new RangeError('The \"config.options.port\" property must be > 0 and < 65536');\n        }\n\n        _this.config.options.port = config.options.port;\n        _this.config.options.instanceName = undefined;\n      }\n\n      if (config.options.readOnlyIntent !== undefined) {\n        if (typeof config.options.readOnlyIntent !== 'boolean') {\n          throw new TypeError('The \"config.options.readOnlyIntent\" property must be of type boolean.');\n        }\n\n        _this.config.options.readOnlyIntent = config.options.readOnlyIntent;\n      }\n\n      if (config.options.requestTimeout !== undefined) {\n        if (typeof config.options.requestTimeout !== 'number') {\n          throw new TypeError('The \"config.options.requestTimeout\" property must be of type number.');\n        }\n\n        _this.config.options.requestTimeout = config.options.requestTimeout;\n      }\n\n      if (config.options.maxRetriesOnTransientErrors !== undefined) {\n        if (typeof config.options.maxRetriesOnTransientErrors !== 'number') {\n          throw new TypeError('The \"config.options.maxRetriesOnTransientErrors\" property must be of type number.');\n        }\n\n        if (config.options.maxRetriesOnTransientErrors < 0) {\n          throw new TypeError('The \"config.options.maxRetriesOnTransientErrors\" property must be equal or greater than 0.');\n        }\n\n        _this.config.options.maxRetriesOnTransientErrors = config.options.maxRetriesOnTransientErrors;\n      }\n\n      if (config.options.connectionRetryInterval !== undefined) {\n        if (typeof config.options.connectionRetryInterval !== 'number') {\n          throw new TypeError('The \"config.options.connectionRetryInterval\" property must be of type number.');\n        }\n\n        if (config.options.connectionRetryInterval <= 0) {\n          throw new TypeError('The \"config.options.connectionRetryInterval\" property must be greater than 0.');\n        }\n\n        _this.config.options.connectionRetryInterval = config.options.connectionRetryInterval;\n      }\n\n      if (config.options.rowCollectionOnDone !== undefined) {\n        if (typeof config.options.rowCollectionOnDone !== 'boolean') {\n          throw new TypeError('The \"config.options.rowCollectionOnDone\" property must be of type boolean.');\n        }\n\n        _this.config.options.rowCollectionOnDone = config.options.rowCollectionOnDone;\n      }\n\n      if (config.options.rowCollectionOnRequestCompletion !== undefined) {\n        if (typeof config.options.rowCollectionOnRequestCompletion !== 'boolean') {\n          throw new TypeError('The \"config.options.rowCollectionOnRequestCompletion\" property must be of type boolean.');\n        }\n\n        _this.config.options.rowCollectionOnRequestCompletion = config.options.rowCollectionOnRequestCompletion;\n      }\n\n      if (config.options.tdsVersion !== undefined) {\n        if (typeof config.options.tdsVersion !== 'string') {\n          throw new TypeError('The \"config.options.tdsVersion\" property must be of type string.');\n        }\n\n        _this.config.options.tdsVersion = config.options.tdsVersion;\n      }\n\n      if (config.options.textsize !== undefined) {\n        if (typeof config.options.textsize !== 'number' && config.options.textsize !== null) {\n          throw new TypeError('The \"config.options.textsize\" property must be of type number or null.');\n        }\n\n        _this.config.options.textsize = config.options.textsize;\n      }\n\n      if (config.options.trustServerCertificate !== undefined) {\n        if (typeof config.options.trustServerCertificate !== 'boolean') {\n          throw new TypeError('The \"config.options.trustServerCertificate\" property must be of type boolean.');\n        }\n\n        _this.config.options.trustServerCertificate = config.options.trustServerCertificate;\n      }\n\n      if (config.options.useColumnNames !== undefined) {\n        if (typeof config.options.useColumnNames !== 'boolean') {\n          throw new TypeError('The \"config.options.useColumnNames\" property must be of type boolean.');\n        }\n\n        _this.config.options.useColumnNames = config.options.useColumnNames;\n      }\n\n      if (config.options.useUTC !== undefined) {\n        if (typeof config.options.useUTC !== 'boolean') {\n          throw new TypeError('The \"config.options.useUTC\" property must be of type boolean.');\n        }\n\n        _this.config.options.useUTC = config.options.useUTC;\n      }\n\n      if (config.options.lowerCaseGuids !== undefined) {\n        if (typeof config.options.lowerCaseGuids !== 'boolean') {\n          throw new TypeError('The \"config.options.lowerCaseGuids\" property must be of type boolean.');\n        }\n\n        _this.config.options.lowerCaseGuids = config.options.lowerCaseGuids;\n      }\n    }\n\n    var credentialsDetails = _this.config.options.cryptoCredentialsDetails;\n\n    if (credentialsDetails.secureOptions === undefined) {\n      // If the caller has not specified their own `secureOptions`,\n      // we set `SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS` here.\n      // Older SQL Server instances running on older Windows versions have\n      // trouble with the BEAST workaround in OpenSSL.\n      // As BEAST is a browser specific exploit, we can just disable this option here.\n      credentialsDetails = Object.create(credentialsDetails, {\n        secureOptions: {\n          value: _constants.default.SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS\n        }\n      });\n    }\n\n    _this.secureContext = (0, _tls.createSecureContext)(credentialsDetails);\n    _this.debug = _this.createDebug();\n    _this.tokenStreamParser = _this.createTokenStreamParser();\n    _this.inTransaction = false;\n    _this.transactionDescriptors = [Buffer.from([0, 0, 0, 0, 0, 0, 0, 0])]; // 'beginTransaction', 'commitTransaction' and 'rollbackTransaction'\n    // events are utilized to maintain inTransaction property state which in\n    // turn is used in managing transactions. These events are only fired for\n    // TDS version 7.2 and beyond. The properties below are used to emulate\n    // equivalent behavior for TDS versions before 7.2.\n\n    _this.transactionDepth = 0;\n    _this.isSqlBatch = false;\n    _this.closed = false;\n    _this.loggedIn = false;\n    _this.messageBuffer = Buffer.alloc(0);\n    _this.curTransientRetryCount = 0;\n    _this.transientErrorLookup = new _transientErrorLookup.TransientErrorLookup();\n    _this.state = _this.STATE.CONNECTING;\n\n    _this.state.enter.call(_assertThisInitialized(_assertThisInitialized(_this)));\n\n    return _this;\n  }\n\n  _createClass(Connection, [{\n    key: \"close\",\n    value: function close() {\n      this.transitionTo(this.STATE.FINAL);\n    }\n  }, {\n    key: \"initialiseConnection\",\n    value: function initialiseConnection() {\n      this.connect();\n      this.createConnectTimer();\n    }\n  }, {\n    key: \"cleanupConnection\",\n    value: function cleanupConnection(cleanupType) {\n      var _this2 = this;\n\n      if (!this.closed) {\n        this.clearConnectTimer();\n        this.clearRequestTimer();\n        this.clearRetryTimer();\n        this.closeConnection();\n\n        if (cleanupType === CLEANUP_TYPE.REDIRECT) {\n          this.emit('rerouting');\n        } else if (cleanupType !== CLEANUP_TYPE.RETRY) {\n          process.nextTick(function () {\n            _this2.emit('end');\n          });\n        }\n\n        var request = this.request;\n\n        if (request) {\n          var err = (0, _errors.RequestError)('Connection closed before request completed.', 'ECLOSE');\n          request.callback(err);\n          this.request = undefined;\n        }\n\n        this.closed = true;\n        this.loggedIn = false;\n        this.loginError = undefined;\n      }\n    }\n  }, {\n    key: \"createDebug\",\n    value: function createDebug() {\n      var _this3 = this;\n\n      var debug = new _debug.default(this.config.options.debug);\n      debug.on('debug', function (message) {\n        _this3.emit('debug', message);\n      });\n      return debug;\n    }\n  }, {\n    key: \"createTokenStreamParser\",\n    value: function createTokenStreamParser() {\n      var _this4 = this;\n\n      var tokenStreamParser = new _tokenStreamParser.Parser(this.debug, undefined, this.config.options);\n      tokenStreamParser.on('infoMessage', function (token) {\n        _this4.emit('infoMessage', token);\n      });\n      tokenStreamParser.on('sspichallenge', function (token) {\n        if (token.ntlmpacket) {\n          _this4.ntlmpacket = token.ntlmpacket;\n          _this4.ntlmpacketBuffer = token.ntlmpacketBuffer;\n        }\n\n        _this4.emit('sspichallenge', token);\n      });\n      tokenStreamParser.on('errorMessage', function (token) {\n        _this4.emit('errorMessage', token);\n\n        if (_this4.loggedIn) {\n          var request = _this4.request;\n\n          if (request) {\n            if (!request.canceled) {\n              var error = new _errors.RequestError(token.message, 'EREQUEST');\n              error.number = token.number;\n              error.state = token.state;\n              error.class = token.class;\n              error.serverName = token.serverName;\n              error.procName = token.procName;\n              error.lineNumber = token.lineNumber;\n              request.error = error;\n            }\n          }\n        } else {\n          var _error = (0, _errors.ConnectionError)(token.message, 'ELOGIN');\n\n          var isLoginErrorTransient = _this4.transientErrorLookup.isTransientError(token.number);\n\n          if (isLoginErrorTransient && _this4.curTransientRetryCount !== _this4.config.options.maxRetriesOnTransientErrors) {\n            _error.isTransient = true;\n          }\n\n          _this4.loginError = _error;\n        }\n      });\n      tokenStreamParser.on('databaseChange', function (token) {\n        _this4.emit('databaseChange', token.newValue);\n      });\n      tokenStreamParser.on('languageChange', function (token) {\n        _this4.emit('languageChange', token.newValue);\n      });\n      tokenStreamParser.on('charsetChange', function (token) {\n        _this4.emit('charsetChange', token.newValue);\n      });\n      tokenStreamParser.on('fedAuthInfo', function (token) {\n        _this4.dispatchEvent('fedAuthInfo', token);\n      });\n      tokenStreamParser.on('featureExtAck', function (token) {\n        _this4.dispatchEvent('featureExtAck', token);\n      });\n      tokenStreamParser.on('loginack', function (token) {\n        if (!token.tdsVersion) {\n          // unsupported TDS version\n          _this4.loginError = (0, _errors.ConnectionError)('Server responded with unknown TDS version.', 'ETDS');\n          _this4.loggedIn = false;\n          return;\n        }\n\n        if (!token.interface) {\n          // unsupported interface\n          _this4.loginError = (0, _errors.ConnectionError)('Server responded with unsupported interface.', 'EINTERFACENOTSUPP');\n          _this4.loggedIn = false;\n          return;\n        } // use negotiated version\n\n\n        _this4.config.options.tdsVersion = token.tdsVersion;\n        _this4.loggedIn = true;\n      });\n      tokenStreamParser.on('routingChange', function (token) {\n        _this4.routingData = token.newValue;\n\n        _this4.dispatchEvent('routingChange');\n      });\n      tokenStreamParser.on('packetSizeChange', function (token) {\n        _this4.messageIo.packetSize(token.newValue);\n      }); // A new top-level transaction was started. This is not fired\n      // for nested transactions.\n\n      tokenStreamParser.on('beginTransaction', function (token) {\n        _this4.transactionDescriptors.push(token.newValue);\n\n        _this4.inTransaction = true;\n      }); // A top-level transaction was committed. This is not fired\n      // for nested transactions.\n\n      tokenStreamParser.on('commitTransaction', function () {\n        _this4.transactionDescriptors.length = 1;\n        _this4.inTransaction = false;\n      }); // A top-level transaction was rolled back. This is not fired\n      // for nested transactions. This is also fired if a batch\n      // aborting error happened that caused a rollback.\n\n      tokenStreamParser.on('rollbackTransaction', function () {\n        _this4.transactionDescriptors.length = 1; // An outermost transaction was rolled back. Reset the transaction counter\n\n        _this4.inTransaction = false;\n\n        _this4.emit('rollbackTransaction');\n      });\n      tokenStreamParser.on('columnMetadata', function (token) {\n        var request = _this4.request;\n\n        if (request) {\n          if (!request.canceled) {\n            if (_this4.config.options.useColumnNames) {\n              var columns = {};\n\n              for (var j = 0, len = token.columns.length; j < len; j++) {\n                var col = token.columns[j];\n\n                if (columns[col.colName] == null) {\n                  columns[col.colName] = col;\n                }\n              }\n\n              request.emit('columnMetadata', columns);\n            } else {\n              request.emit('columnMetadata', token.columns);\n            }\n          }\n        } else {\n          _this4.emit('error', new Error(\"Received 'columnMetadata' when no sqlRequest is in progress\"));\n\n          _this4.close();\n        }\n      });\n      tokenStreamParser.on('order', function (token) {\n        var request = _this4.request;\n\n        if (request) {\n          if (!request.canceled) {\n            request.emit('order', token.orderColumns);\n          }\n        } else {\n          _this4.emit('error', new Error(\"Received 'order' when no sqlRequest is in progress\"));\n\n          _this4.close();\n        }\n      });\n      tokenStreamParser.on('row', function (token) {\n        var request = _this4.request;\n\n        if (request) {\n          if (!request.canceled) {\n            if (_this4.config.options.rowCollectionOnRequestCompletion) {\n              request.rows.push(token.columns);\n            }\n\n            if (_this4.config.options.rowCollectionOnDone) {\n              request.rst.push(token.columns);\n            }\n\n            if (!(_this4.state === _this4.STATE.SENT_ATTENTION && request.paused)) {\n              request.emit('row', token.columns);\n            }\n          }\n        } else {\n          _this4.emit('error', new Error(\"Received 'row' when no sqlRequest is in progress\"));\n\n          _this4.close();\n        }\n      });\n      tokenStreamParser.on('returnStatus', function (token) {\n        var request = _this4.request;\n\n        if (request) {\n          if (!request.canceled) {\n            // Keep value for passing in 'doneProc' event.\n            _this4.procReturnStatusValue = token.value;\n          }\n        }\n      });\n      tokenStreamParser.on('returnValue', function (token) {\n        var request = _this4.request;\n\n        if (request) {\n          if (!request.canceled) {\n            request.emit('returnValue', token.paramName, token.value, token.metadata);\n          }\n        }\n      });\n      tokenStreamParser.on('doneProc', function (token) {\n        var request = _this4.request;\n\n        if (request) {\n          if (!request.canceled) {\n            request.emit('doneProc', token.rowCount, token.more, _this4.procReturnStatusValue, request.rst);\n            _this4.procReturnStatusValue = undefined;\n\n            if (token.rowCount !== undefined) {\n              request.rowCount += token.rowCount;\n            }\n\n            if (_this4.config.options.rowCollectionOnDone) {\n              request.rst = [];\n            }\n          }\n        }\n      });\n      tokenStreamParser.on('doneInProc', function (token) {\n        var request = _this4.request;\n\n        if (request) {\n          if (!request.canceled) {\n            request.emit('doneInProc', token.rowCount, token.more, request.rst);\n\n            if (token.rowCount !== undefined) {\n              request.rowCount += token.rowCount;\n            }\n\n            if (_this4.config.options.rowCollectionOnDone) {\n              request.rst = [];\n            }\n          }\n        }\n      });\n      tokenStreamParser.on('done', function (token) {\n        var request = _this4.request;\n\n        if (request) {\n          if (token.attention) {\n            _this4.dispatchEvent('attention');\n          }\n\n          if (request.canceled) {\n            // If we received a `DONE` token with `DONE_ERROR`, but no previous `ERROR` token,\n            // We assume this is the indication that an in-flight request was canceled.\n            if (token.sqlError && !request.error) {\n              _this4.clearCancelTimer();\n\n              request.error = (0, _errors.RequestError)('Canceled.', 'ECANCEL');\n            }\n          } else {\n            if (token.sqlError && !request.error) {\n              // check if the DONE_ERROR flags was set, but an ERROR token was not sent.\n              request.error = (0, _errors.RequestError)('An unknown error has occurred.', 'UNKNOWN');\n            }\n\n            request.emit('done', token.rowCount, token.more, request.rst);\n\n            if (token.rowCount !== undefined) {\n              request.rowCount += token.rowCount;\n            }\n\n            if (_this4.config.options.rowCollectionOnDone) {\n              request.rst = [];\n            }\n          }\n        }\n      });\n      tokenStreamParser.on('endOfMessage', function () {\n        // EOM pseudo token received\n        if (_this4.state === _this4.STATE.SENT_CLIENT_REQUEST) {\n          _this4.dispatchEvent('endOfMessageMarkerReceived');\n        }\n      });\n      tokenStreamParser.on('resetConnection', function () {\n        _this4.emit('resetConnection');\n      });\n      tokenStreamParser.on('drain', function () {\n        // Bridge the release of backpressure from the token stream parser\n        // transform to the packet stream transform.\n        _this4.messageIo.resume();\n      });\n      return tokenStreamParser;\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var _this5 = this;\n\n      if (this.config.options.port) {\n        return this.connectOnPort(this.config.options.port, this.config.options.multiSubnetFailover);\n      } else {\n        return new _instanceLookup.InstanceLookup().instanceLookup({\n          server: this.config.server,\n          instanceName: this.config.options.instanceName,\n          timeout: this.config.options.connectTimeout\n        }, function (message, port) {\n          if (_this5.state === _this5.STATE.FINAL) {\n            return;\n          }\n\n          if (message) {\n            _this5.emit('connect', (0, _errors.ConnectionError)(message, 'EINSTLOOKUP'));\n          } else {\n            _this5.connectOnPort(port, _this5.config.options.multiSubnetFailover);\n          }\n        });\n      }\n    }\n  }, {\n    key: \"connectOnPort\",\n    value: function connectOnPort(port, multiSubnetFailover) {\n      var _this6 = this;\n\n      var connectOpts = {\n        host: this.routingData ? this.routingData.server : this.config.server,\n        port: this.routingData ? this.routingData.port : port,\n        localAddress: this.config.options.localAddress\n      };\n      new _connector.Connector(connectOpts, multiSubnetFailover).execute(function (err, socket) {\n        if (err) {\n          return _this6.socketError(err);\n        }\n\n        if (_this6.state === _this6.STATE.FINAL) {\n          socket.destroy();\n          return;\n        }\n\n        socket.on('error', function (error) {\n          _this6.socketError(error);\n        });\n        socket.on('close', function () {\n          _this6.socketClose();\n        });\n        socket.on('end', function () {\n          _this6.socketEnd();\n        });\n        socket.setKeepAlive(true, KEEP_ALIVE_INITIAL_DELAY);\n        _this6.messageIo = new _messageIo.default(socket, _this6.config.options.packetSize, _this6.debug);\n\n        _this6.messageIo.on('data', function (data) {\n          _this6.dispatchEvent('data', data);\n        });\n\n        _this6.messageIo.on('message', function () {\n          _this6.dispatchEvent('message');\n        });\n\n        _this6.messageIo.on('secure', function (cleartext) {\n          _this6.emit('secure', cleartext);\n        });\n\n        _this6.socket = socket;\n\n        _this6.socketConnect();\n      });\n    }\n  }, {\n    key: \"closeConnection\",\n    value: function closeConnection() {\n      if (this.socket) {\n        this.socket.destroy();\n      }\n    }\n  }, {\n    key: \"createConnectTimer\",\n    value: function createConnectTimer() {\n      var _this7 = this;\n\n      this.connectTimer = setTimeout(function () {\n        _this7.connectTimeout();\n      }, this.config.options.connectTimeout);\n    }\n  }, {\n    key: \"createCancelTimer\",\n    value: function createCancelTimer() {\n      var _this8 = this;\n\n      this.clearCancelTimer();\n      var timeout = this.config.options.cancelTimeout;\n\n      if (timeout > 0) {\n        this.cancelTimer = setTimeout(function () {\n          _this8.cancelTimeout();\n        }, timeout);\n      }\n    }\n  }, {\n    key: \"createRequestTimer\",\n    value: function createRequestTimer() {\n      var _this9 = this;\n\n      this.clearRequestTimer(); // release old timer, just to be safe\n\n      var request = this.request;\n      var timeout = request.timeout !== undefined ? request.timeout : this.config.options.requestTimeout;\n\n      if (timeout) {\n        this.requestTimer = setTimeout(function () {\n          _this9.requestTimeout();\n        }, timeout);\n      }\n    }\n  }, {\n    key: \"createRetryTimer\",\n    value: function createRetryTimer() {\n      var _this10 = this;\n\n      this.clearRetryTimer();\n      this.retryTimer = setTimeout(function () {\n        _this10.retryTimeout();\n      }, this.config.options.connectionRetryInterval);\n    }\n  }, {\n    key: \"connectTimeout\",\n    value: function connectTimeout() {\n      var message = \"Failed to connect to \".concat(this.config.server).concat(this.config.options.port ? \":\".concat(this.config.options.port) : \"\\\\\".concat(this.config.options.instanceName), \" in \").concat(this.config.options.connectTimeout, \"ms\");\n      this.debug.log(message);\n      this.emit('connect', (0, _errors.ConnectionError)(message, 'ETIMEOUT'));\n      this.connectTimer = undefined;\n      this.dispatchEvent('connectTimeout');\n    }\n  }, {\n    key: \"cancelTimeout\",\n    value: function cancelTimeout() {\n      var message = \"Failed to cancel request in \".concat(this.config.options.cancelTimeout, \"ms\");\n      this.debug.log(message);\n      this.dispatchEvent('socketError', (0, _errors.ConnectionError)(message, 'ETIMEOUT'));\n    }\n  }, {\n    key: \"requestTimeout\",\n    value: function requestTimeout() {\n      this.requestTimer = undefined;\n      var request = this.request;\n      request.cancel();\n      var timeout = request.timeout !== undefined ? request.timeout : this.config.options.requestTimeout;\n      var message = 'Timeout: Request failed to complete in ' + timeout + 'ms';\n      request.error = (0, _errors.RequestError)(message, 'ETIMEOUT');\n    }\n  }, {\n    key: \"retryTimeout\",\n    value: function retryTimeout() {\n      this.retryTimer = undefined;\n      this.emit('retry');\n      this.transitionTo(this.STATE.CONNECTING);\n    }\n  }, {\n    key: \"clearConnectTimer\",\n    value: function clearConnectTimer() {\n      if (this.connectTimer) {\n        clearTimeout(this.connectTimer);\n      }\n    }\n  }, {\n    key: \"clearCancelTimer\",\n    value: function clearCancelTimer() {\n      if (this.cancelTimer) {\n        clearTimeout(this.cancelTimer);\n      }\n    }\n  }, {\n    key: \"clearRequestTimer\",\n    value: function clearRequestTimer() {\n      if (this.requestTimer) {\n        clearTimeout(this.requestTimer);\n        this.requestTimer = undefined;\n      }\n    }\n  }, {\n    key: \"clearRetryTimer\",\n    value: function clearRetryTimer() {\n      if (this.retryTimer) {\n        clearTimeout(this.retryTimer);\n        this.retryTimer = undefined;\n      }\n    }\n  }, {\n    key: \"transitionTo\",\n    value: function transitionTo(newState) {\n      if (this.state === newState) {\n        this.debug.log('State is already ' + newState.name);\n        return;\n      }\n\n      if (this.state && this.state.exit) {\n        this.state.exit.call(this, newState);\n      }\n\n      this.debug.log('State change: ' + (this.state ? this.state.name : 'undefined') + ' -> ' + newState.name);\n      this.state = newState;\n\n      if (this.state.enter) {\n        this.state.enter.apply(this);\n      }\n    }\n  }, {\n    key: \"getEventHandler\",\n    value: function getEventHandler(eventName) {\n      var handler = this.state.events[eventName];\n\n      if (!handler) {\n        throw new Error(\"No event '\".concat(eventName, \"' in state '\").concat(this.state.name, \"'\"));\n      }\n\n      return handler;\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(eventName) {\n      var handler = this.state.events[eventName];\n\n      if (handler) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        handler.apply(this, args);\n      } else {\n        this.emit('error', new Error(\"No event '\".concat(eventName, \"' in state '\").concat(this.state.name, \"'\")));\n        this.close();\n      }\n    }\n  }, {\n    key: \"socketError\",\n    value: function socketError(error) {\n      if (this.state === this.STATE.CONNECTING || this.state === this.STATE.SENT_TLSSSLNEGOTIATION) {\n        var message = \"Failed to connect to \".concat(this.config.server, \":\").concat(this.config.options.port, \" - \").concat(error.message);\n        this.debug.log(message);\n        this.emit('connect', (0, _errors.ConnectionError)(message, 'ESOCKET'));\n      } else {\n        var _message = \"Connection lost - \".concat(error.message);\n\n        this.debug.log(_message);\n        this.emit('error', (0, _errors.ConnectionError)(_message, 'ESOCKET'));\n      }\n\n      this.dispatchEvent('socketError', error);\n    }\n  }, {\n    key: \"socketConnect\",\n    value: function socketConnect() {\n      this.closed = false;\n      this.debug.log('connected to ' + this.config.server + ':' + this.config.options.port);\n      this.dispatchEvent('socketConnect');\n    }\n  }, {\n    key: \"socketEnd\",\n    value: function socketEnd() {\n      this.debug.log('socket ended');\n\n      if (this.state !== this.STATE.FINAL) {\n        var error = new Error('socket hang up');\n        error.code = 'ECONNRESET';\n        this.socketError(error);\n      }\n    }\n  }, {\n    key: \"socketClose\",\n    value: function socketClose() {\n      this.debug.log('connection to ' + this.config.server + ':' + this.config.options.port + ' closed');\n\n      if (this.state === this.STATE.REROUTING) {\n        this.debug.log('Rerouting to ' + this.routingData.server + ':' + this.routingData.port);\n        this.dispatchEvent('reconnect');\n      } else if (this.state === this.STATE.TRANSIENT_FAILURE_RETRY) {\n        var server = this.routingData ? this.routingData.server : this.config.server;\n        var port = this.routingData ? this.routingData.port : this.config.options.port;\n        this.debug.log('Retry after transient failure connecting to ' + server + ':' + port);\n        this.dispatchEvent('retry');\n      } else {\n        this.transitionTo(this.STATE.FINAL);\n      }\n    }\n  }, {\n    key: \"sendPreLogin\",\n    value: function sendPreLogin() {\n      var payload = new _preloginPayload.default({\n        encrypt: this.config.options.encrypt\n      });\n      this.messageIo.sendMessage(_packet.TYPE.PRELOGIN, payload.data);\n      this.debug.payload(function () {\n        return payload.toString('  ');\n      });\n    }\n  }, {\n    key: \"emptyMessageBuffer\",\n    value: function emptyMessageBuffer() {\n      this.messageBuffer = Buffer.alloc(0);\n    }\n  }, {\n    key: \"addToMessageBuffer\",\n    value: function addToMessageBuffer(data) {\n      this.messageBuffer = Buffer.concat([this.messageBuffer, data]);\n    }\n  }, {\n    key: \"sendLogin7Packet\",\n    value: function sendLogin7Packet() {\n      var payload = new _login7Payload.default({\n        tdsVersion: _tdsVersions.versions[this.config.options.tdsVersion],\n        packetSize: this.config.options.packetSize,\n        clientProgVer: 0,\n        clientPid: process.pid,\n        connectionId: 0,\n        clientTimeZone: new Date().getTimezoneOffset(),\n        clientLcid: 0x00000409\n      });\n      var authentication = this.config.authentication;\n\n      switch (authentication.type) {\n        case 'azure-active-directory-password':\n          payload.fedAuth = {\n            type: 'ADAL',\n            echo: this.fedAuthRequired,\n            workflow: 'default'\n          };\n          break;\n\n        case 'azure-active-directory-access-token':\n          payload.fedAuth = {\n            type: 'SECURITYTOKEN',\n            echo: this.fedAuthRequired,\n            fedAuthToken: authentication.options.token\n          };\n          break;\n\n        case 'azure-active-directory-msi-vm':\n        case 'azure-active-directory-msi-app-service':\n        case 'azure-active-directory-service-principal-secret':\n          payload.fedAuth = {\n            type: 'ADAL',\n            echo: this.fedAuthRequired,\n            workflow: 'integrated'\n          };\n          break;\n\n        case 'ntlm':\n          payload.sspi = (0, _ntlm.createNTLMRequest)({\n            domain: authentication.options.domain\n          });\n          break;\n\n        default:\n          payload.userName = authentication.options.userName;\n          payload.password = authentication.options.password;\n      }\n\n      payload.hostname = _os.default.hostname();\n      payload.serverName = this.routingData ? this.routingData.server : this.config.server;\n      payload.appName = this.config.options.appName || 'Tedious';\n      payload.libraryName = _library.name;\n      payload.language = this.config.options.language;\n      payload.database = this.config.options.database;\n      payload.clientId = Buffer.from([1, 2, 3, 4, 5, 6]);\n      payload.readOnlyIntent = this.config.options.readOnlyIntent;\n      payload.initDbFatal = !this.config.options.fallbackToDefaultDb;\n      this.routingData = undefined;\n      this.messageIo.sendMessage(_packet.TYPE.LOGIN7, payload.toBuffer());\n      this.debug.payload(function () {\n        return payload.toString('  ');\n      });\n    }\n  }, {\n    key: \"sendFedAuthTokenMessage\",\n    value: function sendFedAuthTokenMessage(token) {\n      var accessTokenLen = Buffer.byteLength(token, 'ucs2');\n      var data = Buffer.alloc(8 + accessTokenLen);\n      var offset = 0;\n      offset = data.writeUInt32LE(accessTokenLen + 4, offset);\n      offset = data.writeUInt32LE(accessTokenLen, offset);\n      data.write(token, offset, 'ucs2');\n      this.messageIo.sendMessage(_packet.TYPE.FEDAUTH_TOKEN, data); // sent the fedAuth token message, the rest is similar to standard login 7\n\n      this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);\n    } // Returns false to apply backpressure.\n\n  }, {\n    key: \"sendDataToTokenStreamParser\",\n    value: function sendDataToTokenStreamParser(data) {\n      return this.tokenStreamParser.addBuffer(data);\n    } // This is an internal method that is called from Request.pause().\n    // It has to check whether the passed Request object represents the currently\n    // active request, because the application might have called Request.pause()\n    // on an old inactive Request object.\n\n  }, {\n    key: \"pauseRequest\",\n    value: function pauseRequest(request) {\n      if (this.isRequestActive(request)) {\n        this.tokenStreamParser.pause();\n      }\n    } // This is an internal method that is called from Request.resume().\n\n  }, {\n    key: \"resumeRequest\",\n    value: function resumeRequest(request) {\n      if (this.isRequestActive(request)) {\n        this.tokenStreamParser.resume();\n      }\n    } // Returns true if the passed request is the currently active request of the connection.\n\n  }, {\n    key: \"isRequestActive\",\n    value: function isRequestActive(request) {\n      return request === this.request && this.state === this.STATE.SENT_CLIENT_REQUEST;\n    }\n  }, {\n    key: \"sendInitialSql\",\n    value: function sendInitialSql() {\n      var _this11 = this;\n\n      var payload = new _sqlbatchPayload.default(this.getInitialSql(), this.currentTransactionDescriptor(), this.config.options);\n      payload.getData(function (data) {\n        return _this11.messageIo.sendMessage(_packet.TYPE.SQL_BATCH, data);\n      });\n    }\n  }, {\n    key: \"getInitialSql\",\n    value: function getInitialSql() {\n      var options = [];\n\n      if (this.config.options.enableAnsiNull === true) {\n        options.push('set ansi_nulls on');\n      } else if (this.config.options.enableAnsiNull === false) {\n        options.push('set ansi_nulls off');\n      }\n\n      if (this.config.options.enableAnsiNullDefault === true) {\n        options.push('set ansi_null_dflt_on on');\n      } else if (this.config.options.enableAnsiNullDefault === false) {\n        options.push('set ansi_null_dflt_on off');\n      }\n\n      if (this.config.options.enableAnsiPadding === true) {\n        options.push('set ansi_padding on');\n      } else if (this.config.options.enableAnsiPadding === false) {\n        options.push('set ansi_padding off');\n      }\n\n      if (this.config.options.enableAnsiWarnings === true) {\n        options.push('set ansi_warnings on');\n      } else if (this.config.options.enableAnsiWarnings === false) {\n        options.push('set ansi_warnings off');\n      }\n\n      if (this.config.options.enableArithAbort === true) {\n        options.push('set arithabort on');\n      } else if (this.config.options.enableArithAbort === false) {\n        options.push('set arithabort off');\n      }\n\n      if (this.config.options.enableConcatNullYieldsNull === true) {\n        options.push('set concat_null_yields_null on');\n      } else if (this.config.options.enableConcatNullYieldsNull === false) {\n        options.push('set concat_null_yields_null off');\n      }\n\n      if (this.config.options.enableCursorCloseOnCommit === true) {\n        options.push('set cursor_close_on_commit on');\n      } else if (this.config.options.enableCursorCloseOnCommit === false) {\n        options.push('set cursor_close_on_commit off');\n      }\n\n      if (this.config.options.datefirst !== null) {\n        options.push(\"set datefirst \".concat(this.config.options.datefirst));\n      }\n\n      if (this.config.options.dateFormat !== null) {\n        options.push(\"set dateformat \".concat(this.config.options.dateFormat));\n      }\n\n      if (this.config.options.enableImplicitTransactions === true) {\n        options.push('set implicit_transactions on');\n      } else if (this.config.options.enableImplicitTransactions === false) {\n        options.push('set implicit_transactions off');\n      }\n\n      if (this.config.options.language !== null) {\n        options.push(\"set language \".concat(this.config.options.language));\n      }\n\n      if (this.config.options.enableNumericRoundabort === true) {\n        options.push('set numeric_roundabort on');\n      } else if (this.config.options.enableNumericRoundabort === false) {\n        options.push('set numeric_roundabort off');\n      }\n\n      if (this.config.options.enableQuotedIdentifier === true) {\n        options.push('set quoted_identifier on');\n      } else if (this.config.options.enableQuotedIdentifier === false) {\n        options.push('set quoted_identifier off');\n      }\n\n      if (this.config.options.textsize !== null) {\n        options.push(\"set textsize \".concat(this.config.options.textsize));\n      }\n\n      if (this.config.options.connectionIsolationLevel !== null) {\n        options.push(\"set transaction isolation level \".concat(this.getIsolationLevelText(this.config.options.connectionIsolationLevel)));\n      }\n\n      if (this.config.options.abortTransactionOnError === true) {\n        options.push('set xact_abort on');\n      } else if (this.config.options.abortTransactionOnError === false) {\n        options.push('set xact_abort off');\n      }\n\n      return options.join('\\n');\n    }\n  }, {\n    key: \"processedInitialSql\",\n    value: function processedInitialSql() {\n      this.clearConnectTimer();\n      this.emit('connect');\n    }\n  }, {\n    key: \"execSqlBatch\",\n    value: function execSqlBatch(request) {\n      this.makeRequest(request, _packet.TYPE.SQL_BATCH, new _sqlbatchPayload.default(request.sqlTextOrProcedure, this.currentTransactionDescriptor(), this.config.options));\n    }\n  }, {\n    key: \"execSql\",\n    value: function execSql(request) {\n      var _this12 = this;\n\n      request.transformIntoExecuteSqlRpc();\n      var error = request.error;\n\n      if (error != null) {\n        process.nextTick(function () {\n          _this12.debug.log(error.message);\n\n          request.callback(error);\n        });\n        return;\n      }\n\n      this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(request, this.currentTransactionDescriptor(), this.config.options));\n    }\n    /**\n     @function newBulkLoad\n     @param {string} table - Table's name.\n     @param {Object} [options] - BulkLoad options.\n     @param {boolean} [options.checkConstraints=false] - Honors constraints during bulk load, it is disabled by default.\n     @param {boolean} [options.fireTriggers=false] - Honors insert triggers during bulk load, it is disabled by default.\n     @param {boolean} [options.keepNulls=false] - Honors null value passed, ignores the default values set on table.\n     @param {boolean} [options.tableLock=false] - Places a bulk update(BU) lock on table while performing bulk load. Uses row locks by default.\n     @param {callback} callback - Function to call after BulkLoad executes.\n     */\n\n  }, {\n    key: \"newBulkLoad\",\n    value: function newBulkLoad(table, callbackOrOptions, callback) {\n      var options;\n\n      if (callback === undefined) {\n        callback = callbackOrOptions;\n        options = {};\n      } else {\n        options = callbackOrOptions;\n      }\n\n      if (typeof options !== 'object') {\n        throw new TypeError('\"options\" argument must be an object');\n      }\n\n      return new _bulkLoad.default(table, this.config.options, options, callback);\n    }\n  }, {\n    key: \"execBulkLoad\",\n    value: function execBulkLoad(bulkLoad) {\n      var _this13 = this;\n\n      bulkLoad.executionStarted = true;\n      var request = new _request.default(bulkLoad.getBulkInsertSql(), function (error) {\n        if (error) {\n          if (error.code === 'UNKNOWN') {\n            error.message += ' This is likely because the schema of the BulkLoad does not match the schema of the table you are attempting to insert into.';\n          }\n\n          bulkLoad.error = error;\n          bulkLoad.callback(error);\n          return;\n        }\n\n        _this13.makeRequest(bulkLoad, _packet.TYPE.BULK_LOAD);\n      });\n      bulkLoad.once('cancel', function () {\n        request.cancel();\n      });\n      this.execSqlBatch(request);\n    }\n  }, {\n    key: \"prepare\",\n    value: function prepare(request) {\n      request.transformIntoPrepareRpc();\n      this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(request, this.currentTransactionDescriptor(), this.config.options));\n    }\n  }, {\n    key: \"unprepare\",\n    value: function unprepare(request) {\n      request.transformIntoUnprepareRpc();\n      this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(request, this.currentTransactionDescriptor(), this.config.options));\n    }\n  }, {\n    key: \"execute\",\n    value: function execute(request, parameters) {\n      var _this14 = this;\n\n      request.transformIntoExecuteRpc(parameters);\n      var error = request.error;\n\n      if (error != null) {\n        process.nextTick(function () {\n          _this14.debug.log(error.message);\n\n          request.callback(error);\n        });\n        return;\n      }\n\n      this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(request, this.currentTransactionDescriptor(), this.config.options));\n    }\n  }, {\n    key: \"callProcedure\",\n    value: function callProcedure(request) {\n      var _this15 = this;\n\n      request.validateParameters();\n      var error = request.error;\n\n      if (error != null) {\n        process.nextTick(function () {\n          _this15.debug.log(error.message);\n\n          request.callback(error);\n        });\n        return;\n      }\n\n      this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(request, this.currentTransactionDescriptor(), this.config.options));\n    }\n  }, {\n    key: \"beginTransaction\",\n    value: function beginTransaction(callback) {\n      var _this16 = this;\n\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var isolationLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.config.options.isolationLevel;\n      var transaction = new _transaction.Transaction(name, isolationLevel);\n\n      if (this.config.options.tdsVersion < '7_2') {\n        return this.execSqlBatch(new _request.default('SET TRANSACTION ISOLATION LEVEL ' + transaction.isolationLevelToTSQL() + ';BEGIN TRAN ' + transaction.name, function (err) {\n          _this16.transactionDepth++;\n\n          if (_this16.transactionDepth === 1) {\n            _this16.inTransaction = true;\n          }\n\n          callback(err);\n        }));\n      }\n\n      var request = new _request.default(undefined, function (err) {\n        return callback(err, _this16.currentTransactionDescriptor());\n      });\n      return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.beginPayload(this.currentTransactionDescriptor()));\n    }\n  }, {\n    key: \"commitTransaction\",\n    value: function commitTransaction(callback) {\n      var _this17 = this;\n\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var transaction = new _transaction.Transaction(name);\n\n      if (this.config.options.tdsVersion < '7_2') {\n        return this.execSqlBatch(new _request.default('COMMIT TRAN ' + transaction.name, function (err) {\n          _this17.transactionDepth--;\n\n          if (_this17.transactionDepth === 0) {\n            _this17.inTransaction = false;\n          }\n\n          callback(err);\n        }));\n      }\n\n      var request = new _request.default(undefined, callback);\n      return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.commitPayload(this.currentTransactionDescriptor()));\n    }\n  }, {\n    key: \"rollbackTransaction\",\n    value: function rollbackTransaction(callback) {\n      var _this18 = this;\n\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var transaction = new _transaction.Transaction(name);\n\n      if (this.config.options.tdsVersion < '7_2') {\n        return this.execSqlBatch(new _request.default('ROLLBACK TRAN ' + transaction.name, function (err) {\n          _this18.transactionDepth--;\n\n          if (_this18.transactionDepth === 0) {\n            _this18.inTransaction = false;\n          }\n\n          callback(err);\n        }));\n      }\n\n      var request = new _request.default(undefined, callback);\n      return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.rollbackPayload(this.currentTransactionDescriptor()));\n    }\n  }, {\n    key: \"saveTransaction\",\n    value: function saveTransaction(callback, name) {\n      var _this19 = this;\n\n      var transaction = new _transaction.Transaction(name);\n\n      if (this.config.options.tdsVersion < '7_2') {\n        return this.execSqlBatch(new _request.default('SAVE TRAN ' + transaction.name, function (err) {\n          _this19.transactionDepth++;\n          callback(err);\n        }));\n      }\n\n      var request = new _request.default(undefined, callback);\n      return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.savePayload(this.currentTransactionDescriptor()));\n    }\n  }, {\n    key: \"transaction\",\n    value: function transaction(cb, isolationLevel) {\n      var _this20 = this;\n\n      if (typeof cb !== 'function') {\n        throw new TypeError('`cb` must be a function');\n      }\n\n      var useSavepoint = this.inTransaction;\n\n      var name = '_tedious_' + _crypto.default.randomBytes(10).toString('hex');\n\n      var txDone = function txDone(err, done) {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n          args[_key2 - 2] = arguments[_key2];\n        }\n\n        if (err) {\n          if (_this20.inTransaction && _this20.state === _this20.STATE.LOGGED_IN) {\n            _this20.rollbackTransaction(function (txErr) {\n              done.apply(void 0, [txErr || err].concat(args));\n            }, name);\n          } else {\n            done.apply(void 0, [err].concat(args));\n          }\n        } else if (useSavepoint) {\n          if (_this20.config.options.tdsVersion < '7_2') {\n            _this20.transactionDepth--;\n          }\n\n          done.apply(void 0, [null].concat(args));\n        } else {\n          _this20.commitTransaction(function (txErr) {\n            done.apply(void 0, [txErr].concat(args));\n          }, name);\n        }\n      };\n\n      if (useSavepoint) {\n        return this.saveTransaction(function (err) {\n          if (err) {\n            return cb(err);\n          }\n\n          if (isolationLevel) {\n            return _this20.execSqlBatch(new _request.default('SET transaction isolation level ' + _this20.getIsolationLevelText(isolationLevel), function (err) {\n              return cb(err, txDone);\n            }));\n          } else {\n            return cb(null, txDone);\n          }\n        }, name);\n      } else {\n        return this.beginTransaction(function (err) {\n          if (err) {\n            return cb(err);\n          }\n\n          return cb(null, txDone);\n        }, name, isolationLevel);\n      }\n    }\n  }, {\n    key: \"makeRequest\",\n    value: function makeRequest(request, packetType, payload) {\n      var _this21 = this;\n\n      if (this.state !== this.STATE.LOGGED_IN) {\n        var message = 'Requests can only be made in the ' + this.STATE.LOGGED_IN.name + ' state, not the ' + this.state.name + ' state';\n        this.debug.log(message);\n        request.callback((0, _errors.RequestError)(message, 'EINVALIDSTATE'));\n      } else if (request.canceled) {\n        process.nextTick(function () {\n          request.callback((0, _errors.RequestError)('Canceled.', 'ECANCEL'));\n        });\n      } else {\n        if (packetType === _packet.TYPE.SQL_BATCH) {\n          this.isSqlBatch = true;\n        } else {\n          this.isSqlBatch = false;\n        }\n\n        this.request = request;\n        request.connection = this;\n        request.rowCount = 0;\n        request.rows = [];\n        request.rst = [];\n\n        var _message2;\n\n        request.once('cancel', function () {\n          if (!_this21.isRequestActive(request)) {\n            // Cancel was called on a request that is no longer active on this connection\n            return;\n          } // There's three ways to handle request cancelation:\n\n\n          if (_this21.state === _this21.STATE.BUILDING_CLIENT_REQUEST) {\n            // The request was cancelled before buffering finished\n            _this21.request = undefined;\n            request.callback((0, _errors.RequestError)('Canceled.', 'ECANCEL'));\n\n            _this21.transitionTo(_this21.STATE.LOGGED_IN);\n          } else if (_message2.writable) {\n            // - if the message is still writable, we'll set the ignore bit\n            //   and end the message.\n            _message2.ignore = true;\n\n            _message2.end();\n          } else {\n            // - but if the message has been ended (and thus has been fully sent off),\n            //   we need to send an `ATTENTION` message to the server\n            _this21.messageIo.sendMessage(_packet.TYPE.ATTENTION);\n\n            _this21.transitionTo(_this21.STATE.SENT_ATTENTION);\n          }\n\n          _this21.clearRequestTimer();\n\n          _this21.createCancelTimer();\n        });\n\n        if (request instanceof _bulkLoad.default) {\n          _message2 = request.getMessageStream(); // If the bulkload was not put into streaming mode by the user,\n          // we end the rowToPacketTransform here for them.\n          //\n          // If it was put into streaming mode, it's the user's responsibility\n          // to end the stream.\n\n          if (!request.streamingMode) {\n            request.rowToPacketTransform.end();\n          }\n\n          this.messageIo.outgoingMessageStream.write(_message2);\n          this.transitionTo(this.STATE.SENT_CLIENT_REQUEST);\n\n          if (request.paused) {\n            // Request.pause() has been called before the request was started\n            this.pauseRequest(request);\n          }\n        } else {\n          this.createRequestTimer(); // Transition to an intermediate state to ensure that no new requests\n          // are made on the connection while the buffer is being populated.\n\n          this.transitionTo(this.STATE.BUILDING_CLIENT_REQUEST);\n          payload.getData(function (data) {\n            if (_this21.state !== _this21.STATE.BUILDING_CLIENT_REQUEST) {\n              // Something else has happened on the connection since starting to\n              // build the request. That state change should have invoked the\n              // request handler so there is nothing to do at this point.\n              return;\n            }\n\n            _message2 = _this21.messageIo.sendMessage(packetType, data, _this21.resetConnectionOnNextRequest);\n            _this21.resetConnectionOnNextRequest = false;\n\n            _this21.debug.payload(function () {\n              return payload.toString('  ');\n            });\n\n            _this21.transitionTo(_this21.STATE.SENT_CLIENT_REQUEST);\n\n            if (request.paused) {\n              // Request.pause() has been called before the request was started\n              _this21.pauseRequest(request);\n            }\n          });\n        }\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (!this.request) {\n        return false;\n      }\n\n      if (this.request.canceled) {\n        return false;\n      }\n\n      this.request.cancel();\n      return true;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(callback) {\n      var _this22 = this;\n\n      var request = new _request.default(this.getInitialSql(), function (err) {\n        if (_this22.config.options.tdsVersion < '7_2') {\n          _this22.inTransaction = false;\n        }\n\n        callback(err);\n      });\n      this.resetConnectionOnNextRequest = true;\n      this.execSqlBatch(request);\n    }\n  }, {\n    key: \"currentTransactionDescriptor\",\n    value: function currentTransactionDescriptor() {\n      return this.transactionDescriptors[this.transactionDescriptors.length - 1];\n    }\n  }, {\n    key: \"getIsolationLevelText\",\n    value: function getIsolationLevelText(isolationLevel) {\n      switch (isolationLevel) {\n        case _transaction.ISOLATION_LEVEL.READ_UNCOMMITTED:\n          return 'read uncommitted';\n\n        case _transaction.ISOLATION_LEVEL.REPEATABLE_READ:\n          return 'repeatable read';\n\n        case _transaction.ISOLATION_LEVEL.SERIALIZABLE:\n          return 'serializable';\n\n        case _transaction.ISOLATION_LEVEL.SNAPSHOT:\n          return 'snapshot';\n\n        default:\n          return 'read committed';\n      }\n    }\n  }]);\n\n  return Connection;\n}(_events.EventEmitter);\n\nvar _default = Connection;\nexports.default = _default;\nmodule.exports = Connection;\nConnection.prototype.STATE = {\n  CONNECTING: {\n    name: 'Connecting',\n    enter: function enter() {\n      this.initialiseConnection();\n    },\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      socketConnect: function socketConnect() {\n        this.sendPreLogin();\n        this.transitionTo(this.STATE.SENT_PRELOGIN);\n      }\n    }\n  },\n  SENT_PRELOGIN: {\n    name: 'SentPrelogin',\n    enter: function enter() {\n      this.emptyMessageBuffer();\n    },\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function (_data) {\n        function data(_x) {\n          return _data.apply(this, arguments);\n        }\n\n        data.toString = function () {\n          return _data.toString();\n        };\n\n        return data;\n      }(function (data) {\n        this.addToMessageBuffer(data);\n      }),\n      message: function message() {\n        var preloginPayload = new _preloginPayload.default(this.messageBuffer);\n        this.debug.payload(function () {\n          return preloginPayload.toString('  ');\n        });\n\n        if (preloginPayload.fedAuthRequired === 1) {\n          this.fedAuthRequired = true;\n        }\n\n        if (preloginPayload.encryptionString === 'ON' || preloginPayload.encryptionString === 'REQ') {\n          if (!this.config.options.encrypt) {\n            this.emit('connect', (0, _errors.ConnectionError)(\"Server requires encryption, set 'encrypt' config option to true.\", 'EENCRYPT'));\n            return this.close();\n          }\n\n          this.messageIo.startTls(this.secureContext, this.config.server, this.config.options.trustServerCertificate);\n          this.transitionTo(this.STATE.SENT_TLSSSLNEGOTIATION);\n        } else {\n          this.sendLogin7Packet();\n          var authentication = this.config.authentication;\n\n          if (authentication.type === 'ntlm') {\n            this.transitionTo(this.STATE.SENT_LOGIN7_WITH_NTLM);\n          } else {\n            this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);\n          }\n        }\n      }\n    }\n  },\n  REROUTING: {\n    name: 'ReRouting',\n    enter: function enter() {\n      this.cleanupConnection(CLEANUP_TYPE.REDIRECT);\n    },\n    events: {\n      message: function message() {},\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      reconnect: function reconnect() {\n        this.transitionTo(this.STATE.CONNECTING);\n      }\n    }\n  },\n  TRANSIENT_FAILURE_RETRY: {\n    name: 'TRANSIENT_FAILURE_RETRY',\n    enter: function enter() {\n      this.curTransientRetryCount++;\n      this.cleanupConnection(CLEANUP_TYPE.RETRY);\n    },\n    events: {\n      message: function message() {},\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      retry: function retry() {\n        this.createRetryTimer();\n      }\n    }\n  },\n  SENT_TLSSSLNEGOTIATION: {\n    name: 'SentTLSSSLNegotiation',\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function (_data2) {\n        function data(_x2) {\n          return _data2.apply(this, arguments);\n        }\n\n        data.toString = function () {\n          return _data2.toString();\n        };\n\n        return data;\n      }(function (data) {\n        this.messageIo.tlsHandshakeData(data);\n      }),\n      message: function message() {\n        if (this.messageIo.tlsNegotiationComplete) {\n          this.sendLogin7Packet();\n          var authentication = this.config.authentication;\n\n          if (authentication.type === 'azure-active-directory-password' || authentication.type === 'azure-active-directory-msi-vm' || authentication.type === 'azure-active-directory-msi-app-service' || authentication.type === 'azure-active-directory-service-principal-secret') {\n            this.transitionTo(this.STATE.SENT_LOGIN7_WITH_FEDAUTH);\n          } else if (authentication.type === 'ntlm') {\n            this.transitionTo(this.STATE.SENT_LOGIN7_WITH_NTLM);\n          } else {\n            this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);\n          }\n        }\n      }\n    }\n  },\n  SENT_LOGIN7_WITH_STANDARD_LOGIN: {\n    name: 'SentLogin7WithStandardLogin',\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function (_data3) {\n        function data(_x3) {\n          return _data3.apply(this, arguments);\n        }\n\n        data.toString = function () {\n          return _data3.toString();\n        };\n\n        return data;\n      }(function (data) {\n        this.sendDataToTokenStreamParser(data);\n      }),\n      routingChange: function routingChange() {\n        this.transitionTo(this.STATE.REROUTING);\n      },\n      featureExtAck: function featureExtAck(token) {\n        var authentication = this.config.authentication;\n\n        if (authentication.type === 'azure-active-directory-password' || authentication.type === 'azure-active-directory-access-token' || authentication.type === 'azure-active-directory-msi-vm' || authentication.type === 'azure-active-directory-msi-app-service' || authentication.type === 'azure-active-directory-service-principal-secret') {\n          if (token.fedAuth === undefined) {\n            this.loginError = (0, _errors.ConnectionError)('Did not receive Active Directory authentication acknowledgement');\n            this.loggedIn = false;\n          } else if (token.fedAuth.length !== 0) {\n            this.loginError = (0, _errors.ConnectionError)(\"Active Directory authentication acknowledgment for \".concat(authentication.type, \" authentication method includes extra data\"));\n            this.loggedIn = false;\n          }\n        } else if (token.fedAuth === undefined) {\n          this.loginError = (0, _errors.ConnectionError)('Received acknowledgement for unknown feature');\n          this.loggedIn = false;\n        } else {\n          this.loginError = (0, _errors.ConnectionError)('Did not request Active Directory authentication, but received the acknowledgment');\n          this.loggedIn = false;\n        }\n      },\n      message: function message() {\n        if (this.loggedIn) {\n          this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);\n        } else if (this.loginError) {\n          if (this.loginError.isTransient) {\n            this.debug.log('Initiating retry on transient error');\n            this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);\n          } else {\n            this.emit('connect', this.loginError);\n            this.transitionTo(this.STATE.FINAL);\n          }\n        } else {\n          this.emit('connect', (0, _errors.ConnectionError)('Login failed.', 'ELOGIN'));\n          this.transitionTo(this.STATE.FINAL);\n        }\n      }\n    }\n  },\n  SENT_LOGIN7_WITH_NTLM: {\n    name: 'SentLogin7WithNTLMLogin',\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function (_data4) {\n        function data(_x4) {\n          return _data4.apply(this, arguments);\n        }\n\n        data.toString = function () {\n          return _data4.toString();\n        };\n\n        return data;\n      }(function (data) {\n        this.sendDataToTokenStreamParser(data);\n      }),\n      message: function message() {\n        if (this.ntlmpacket) {\n          var authentication = this.config.authentication;\n          var payload = new _ntlmPayload.default({\n            domain: authentication.options.domain,\n            userName: authentication.options.userName,\n            password: authentication.options.password,\n            ntlmpacket: this.ntlmpacket\n          });\n          this.messageIo.sendMessage(_packet.TYPE.NTLMAUTH_PKT, payload.data);\n          this.debug.payload(function () {\n            return payload.toString('  ');\n          });\n          this.ntlmpacket = undefined;\n        } else if (this.loggedIn) {\n          this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);\n        } else if (this.loginError) {\n          if (this.loginError.isTransient) {\n            this.debug.log('Initiating retry on transient error');\n            this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);\n          } else {\n            this.emit('connect', this.loginError);\n            this.transitionTo(this.STATE.FINAL);\n          }\n        } else {\n          this.emit('connect', (0, _errors.ConnectionError)('Login failed.', 'ELOGIN'));\n          this.transitionTo(this.STATE.FINAL);\n        }\n      }\n    }\n  },\n  SENT_LOGIN7_WITH_FEDAUTH: {\n    name: 'SentLogin7Withfedauth',\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function (_data5) {\n        function data(_x5) {\n          return _data5.apply(this, arguments);\n        }\n\n        data.toString = function () {\n          return _data5.toString();\n        };\n\n        return data;\n      }(function (data) {\n        this.sendDataToTokenStreamParser(data);\n      }),\n      routingChange: function routingChange() {\n        this.transitionTo(this.STATE.REROUTING);\n      },\n      fedAuthInfo: function fedAuthInfo(token) {\n        this.fedAuthInfoToken = token;\n      },\n      message: function message() {\n        var _this23 = this;\n\n        var fedAuthInfoToken = this.fedAuthInfoToken;\n\n        if (fedAuthInfoToken && fedAuthInfoToken.stsurl && fedAuthInfoToken.spn) {\n          var authentication = this.config.authentication;\n\n          var getToken = function getToken(callback) {\n            var getTokenFromCredentials = function getTokenFromCredentials(err, credentials) {\n              if (err) {\n                return callback(err);\n              }\n\n              credentials.getToken().then(function (tokenResponse) {\n                callback(null, tokenResponse.accessToken);\n              }, callback);\n            };\n\n            if (authentication.type === 'azure-active-directory-password') {\n              (0, _msRestNodeauth.loginWithUsernamePassword)(authentication.options.userName, authentication.options.password, {\n                clientId: '7f98cb04-cd1e-40df-9140-3bf7e2cea4db',\n                tokenAudience: fedAuthInfoToken.spn\n              }, getTokenFromCredentials);\n            } else if (authentication.type === 'azure-active-directory-msi-vm') {\n              (0, _msRestNodeauth.loginWithVmMSI)({\n                clientId: authentication.options.clientId,\n                msiEndpoint: authentication.options.msiEndpoint,\n                resource: fedAuthInfoToken.spn\n              }, getTokenFromCredentials);\n            } else if (authentication.type === 'azure-active-directory-msi-app-service') {\n              (0, _msRestNodeauth.loginWithAppServiceMSI)({\n                msiEndpoint: authentication.options.msiEndpoint,\n                msiSecret: authentication.options.msiSecret,\n                resource: fedAuthInfoToken.spn\n              }, getTokenFromCredentials);\n            } else if (authentication.type === 'azure-active-directory-service-principal-secret') {\n              (0, _msRestNodeauth.loginWithServicePrincipalSecret)(authentication.options.clientId, authentication.options.clientSecret, authentication.options.tenantId, {\n                tokenAudience: fedAuthInfoToken.spn\n              }, getTokenFromCredentials);\n            }\n          };\n\n          getToken(function (err, token) {\n            if (err) {\n              _this23.loginError = (0, _errors.ConnectionError)('Security token could not be authenticated or authorized.', 'EFEDAUTH');\n\n              _this23.emit('connect', _this23.loginError);\n\n              _this23.transitionTo(_this23.STATE.FINAL);\n\n              return;\n            }\n\n            _this23.sendFedAuthTokenMessage(token);\n          });\n        } else if (this.loginError) {\n          if (this.loginError.isTransient) {\n            this.debug.log('Initiating retry on transient error');\n            this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);\n          } else {\n            this.emit('connect', this.loginError);\n            this.transitionTo(this.STATE.FINAL);\n          }\n        } else {\n          this.emit('connect', (0, _errors.ConnectionError)('Login failed.', 'ELOGIN'));\n          this.transitionTo(this.STATE.FINAL);\n        }\n      }\n    }\n  },\n  LOGGED_IN_SENDING_INITIAL_SQL: {\n    name: 'LoggedInSendingInitialSql',\n    enter: function enter() {\n      this.sendInitialSql();\n    },\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      connectTimeout: function connectTimeout() {\n        this.transitionTo(this.STATE.FINAL);\n      },\n      data: function (_data6) {\n        function data(_x6) {\n          return _data6.apply(this, arguments);\n        }\n\n        data.toString = function () {\n          return _data6.toString();\n        };\n\n        return data;\n      }(function (data) {\n        this.sendDataToTokenStreamParser(data);\n      }),\n      message: function message() {\n        this.transitionTo(this.STATE.LOGGED_IN);\n        this.processedInitialSql();\n      }\n    }\n  },\n  LOGGED_IN: {\n    name: 'LoggedIn',\n    events: {\n      socketError: function socketError() {\n        this.transitionTo(this.STATE.FINAL);\n      }\n    }\n  },\n  BUILDING_CLIENT_REQUEST: {\n    name: 'BuildingClientRequest',\n    events: {\n      socketError: function socketError(err) {\n        var sqlRequest = this.request;\n        this.request = undefined;\n        this.transitionTo(this.STATE.FINAL);\n        sqlRequest.callback(err);\n      }\n    }\n  },\n  SENT_CLIENT_REQUEST: {\n    name: 'SentClientRequest',\n    exit: function exit(nextState) {\n      this.clearRequestTimer();\n\n      if (nextState !== this.STATE.FINAL) {\n        this.tokenStreamParser.resume();\n      }\n    },\n    events: {\n      socketError: function socketError(err) {\n        var sqlRequest = this.request;\n        this.request = undefined;\n        this.transitionTo(this.STATE.FINAL);\n        sqlRequest.callback(err);\n      },\n      data: function (_data7) {\n        function data(_x7) {\n          return _data7.apply(this, arguments);\n        }\n\n        data.toString = function () {\n          return _data7.toString();\n        };\n\n        return data;\n      }(function (data) {\n        this.clearRequestTimer(); // request timer is stopped on first data package\n\n        var ret = this.sendDataToTokenStreamParser(data);\n\n        if (ret === false) {\n          // Bridge backpressure from the token stream parser transform to the\n          // packet stream transform.\n          this.messageIo.pause();\n        }\n      }),\n      message: function message() {\n        // We have to channel the 'message' (EOM) event through the token stream\n        // parser transform, to keep it in line with the flow of the tokens, when\n        // the incoming data flow is paused and resumed.\n        this.tokenStreamParser.addEndOfMessageMarker();\n      },\n      endOfMessageMarkerReceived: function endOfMessageMarkerReceived() {\n        this.transitionTo(this.STATE.LOGGED_IN);\n        var sqlRequest = this.request;\n        this.request = undefined;\n\n        if (this.config.options.tdsVersion < '7_2' && sqlRequest.error && this.isSqlBatch) {\n          this.inTransaction = false;\n        }\n\n        sqlRequest.callback(sqlRequest.error, sqlRequest.rowCount, sqlRequest.rows);\n      }\n    }\n  },\n  SENT_ATTENTION: {\n    name: 'SentAttention',\n    enter: function enter() {\n      this.attentionReceived = false;\n    },\n    events: {\n      socketError: function socketError(err) {\n        var sqlRequest = this.request;\n        this.request = undefined;\n        this.transitionTo(this.STATE.FINAL);\n        sqlRequest.callback(err);\n      },\n      data: function (_data8) {\n        function data(_x8) {\n          return _data8.apply(this, arguments);\n        }\n\n        data.toString = function () {\n          return _data8.toString();\n        };\n\n        return data;\n      }(function (data) {\n        this.sendDataToTokenStreamParser(data);\n      }),\n      attention: function attention() {\n        this.attentionReceived = true;\n      },\n      message: function message() {\n        // 3.2.5.7 Sent Attention State\n        // Discard any data contained in the response, until we receive the attention response\n        if (this.attentionReceived) {\n          this.clearCancelTimer();\n          var sqlRequest = this.request;\n          this.request = undefined;\n          this.transitionTo(this.STATE.LOGGED_IN);\n\n          if (sqlRequest.error && sqlRequest.error instanceof _errors.RequestError && sqlRequest.error.code === 'ETIMEOUT') {\n            sqlRequest.callback(sqlRequest.error);\n          } else {\n            sqlRequest.callback((0, _errors.RequestError)('Canceled.', 'ECANCEL'));\n          }\n        }\n      }\n    }\n  },\n  FINAL: {\n    name: 'Final',\n    enter: function enter() {\n      this.cleanupConnection(CLEANUP_TYPE.NORMAL);\n    },\n    events: {\n      loginFailed: function loginFailed() {// Do nothing. The connection was probably closed by the client code.\n      },\n      connectTimeout: function connectTimeout() {// Do nothing, as the timer should be cleaned up.\n      },\n      message: function message() {// Do nothing\n      },\n      socketError: function socketError() {// Do nothing\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}