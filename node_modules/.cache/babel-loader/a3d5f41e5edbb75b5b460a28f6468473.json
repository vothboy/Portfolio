{"ast":null,"code":"/*\r\n * @copyright\r\n * Copyright Â© Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\n'use strict';\n\nvar _ = require('underscore');\n\nrequire('date-utils'); // Adds a number of convenience methods to the builtin Date object.\n\n\nvar querystring = require('querystring');\n\nvar uuid = require('uuid');\n\nvar request = require('request');\n\nvar url = require('url');\n\nvar async = require('async');\n\nvar constants = require('./constants');\n\nvar Logger = require('./log').Logger;\n\nvar util = require('./util');\n\nvar OAuth2Parameters = constants.OAuth2.Parameters;\nvar OAuth2ResponseParameters = constants.OAuth2.ResponseParameters;\nvar DeviceCodeResponseParameters = constants.OAuth2.DeviceCodeResponseParameters;\nvar IdTokenMap = constants.OAuth2.IdTokenMap;\nvar TokenResponseFields = constants.TokenResponseFields;\nvar UserCodeResponseFields = constants.UserCodeResponseFields;\nvar IdTokenFields = constants.IdTokenFields;\nvar TOKEN_RESPONSE_MAP = {};\nTOKEN_RESPONSE_MAP[OAuth2ResponseParameters.TOKEN_TYPE] = TokenResponseFields.TOKEN_TYPE;\nTOKEN_RESPONSE_MAP[OAuth2ResponseParameters.ACCESS_TOKEN] = TokenResponseFields.ACCESS_TOKEN;\nTOKEN_RESPONSE_MAP[OAuth2ResponseParameters.REFRESH_TOKEN] = TokenResponseFields.REFRESH_TOKEN;\nTOKEN_RESPONSE_MAP[OAuth2ResponseParameters.CREATED_ON] = TokenResponseFields.CREATED_ON;\nTOKEN_RESPONSE_MAP[OAuth2ResponseParameters.EXPIRES_ON] = TokenResponseFields.EXPIRES_ON;\nTOKEN_RESPONSE_MAP[OAuth2ResponseParameters.EXPIRES_IN] = TokenResponseFields.EXPIRES_IN;\nTOKEN_RESPONSE_MAP[OAuth2ResponseParameters.RESOURCE] = TokenResponseFields.RESOURCE;\nTOKEN_RESPONSE_MAP[OAuth2ResponseParameters.ERROR] = TokenResponseFields.ERROR;\nTOKEN_RESPONSE_MAP[OAuth2ResponseParameters.ERROR_DESCRIPTION] = TokenResponseFields.ERROR_DESCRIPTION;\nvar DEVICE_CODE_RESPONSE_MAP = {};\nDEVICE_CODE_RESPONSE_MAP[DeviceCodeResponseParameters.DEVICE_CODE] = UserCodeResponseFields.DEVICE_CODE;\nDEVICE_CODE_RESPONSE_MAP[DeviceCodeResponseParameters.USER_CODE] = UserCodeResponseFields.USER_CODE;\nDEVICE_CODE_RESPONSE_MAP[DeviceCodeResponseParameters.VERIFICATION_URL] = UserCodeResponseFields.VERIFICATION_URL;\nDEVICE_CODE_RESPONSE_MAP[DeviceCodeResponseParameters.INTERVAL] = UserCodeResponseFields.INTERVAL;\nDEVICE_CODE_RESPONSE_MAP[DeviceCodeResponseParameters.EXPIRES_IN] = UserCodeResponseFields.EXPIRES_IN;\nDEVICE_CODE_RESPONSE_MAP[DeviceCodeResponseParameters.MESSAGE] = UserCodeResponseFields.MESSAGE;\nDEVICE_CODE_RESPONSE_MAP[DeviceCodeResponseParameters.ERROR] = UserCodeResponseFields.ERROR;\nDEVICE_CODE_RESPONSE_MAP[DeviceCodeResponseParameters.ERROR_DESCRIPTION] = UserCodeResponseFields.ERROR_DESCRIPTION;\n/**\r\n * Constructs an instances of OAuth2Client\r\n * @constructor\r\n * @private\r\n * @param {object} callContext Contains any context information that applies to the request.\r\n * @param {string|url} authority  An url that points to an authority.\r\n */\n\nfunction OAuth2Client(callContext, authority) {\n  this._tokenEndpoint = authority.tokenEndpoint;\n  this._deviceCodeEndpoint = authority.deviceCodeEndpoint;\n  this._log = new Logger('OAuth2Client', callContext._logContext);\n  this._callContext = callContext;\n  this._cancelPollingRequest = false;\n}\n/**\r\n * Constructs an OAuth 2.0 token request url.\r\n * @private\r\n * @return {URL}\r\n */\n\n\nOAuth2Client.prototype._createTokenUrl = function () {\n  var tokenUrl = url.parse(this._tokenEndpoint);\n  var parameters = {};\n  parameters[OAuth2Parameters.AAD_API_VERSION] = '1.0';\n  tokenUrl.search = querystring.stringify(parameters);\n  return tokenUrl;\n};\n/**\r\n * Constructs the user code info request url. \r\n * @private \r\n * @return {URL}\r\n */\n\n\nOAuth2Client.prototype._createDeviceCodeUrl = function () {\n  var deviceCodeUrl = url.parse(this._deviceCodeEndpoint);\n  var parameters = {};\n  parameters[OAuth2Parameters.AAD_API_VERSION] = '1.0';\n  deviceCodeUrl.search = querystring.stringify(parameters);\n  return deviceCodeUrl;\n};\n/**\r\n * @private\r\n * @param {object}   obj         An object in which integer values may reside.\r\n * @param {array}    keys        An array of strings that specify keys in which integers may need parsing.\r\n */\n\n\nOAuth2Client.prototype._parseOptionalInts = function (obj, keys) {\n  var self = this;\n  keys.forEach(function (element) {\n    if (_.has(obj, element)) {\n      obj[element] = parseInt(obj[element], 10);\n\n      if (isNaN(obj[element])) {\n        throw self._log.createError(element + ' could not be parsed as an int.');\n      }\n    }\n  });\n};\n/**\r\n * Parses a JWS encoded JWT into it's three parts.\r\n * @param  {string} jwtToken The token to parse.\r\n * @return {object}          The three JWS parts, header, JWSPayload, and JWSSig, or undefined.\r\n */\n\n\nOAuth2Client.prototype._crackJwt = function (jwtToken) {\n  var idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\n  var matches = idTokenPartsRegex.exec(jwtToken);\n\n  if (!matches || matches.length < 4) {\n    this._log.warn('The returned id_token is not parseable.');\n\n    return;\n  }\n\n  var crackedToken = {\n    header: matches[1],\n    JWSPayload: matches[2],\n    JWSSig: matches[3]\n  };\n  return crackedToken;\n};\n/**\r\n * Finds the value that should be used as the userId value.\r\n * @param {object} idToken The id token that parsed.\r\n * @returns {object} An object with a userId field and maybe a userIdIsDisplayable field.\r\n */\n\n\nOAuth2Client.prototype._getUserId = function (idToken) {\n  var userId;\n  var isDisplayable;\n\n  if (idToken.upn) {\n    userId = idToken.upn;\n    isDisplayable = true;\n  } else if (idToken.email) {\n    userId = idToken.email;\n    isDisplayable = true;\n  } else if (idToken.sub) {\n    userId = idToken.sub;\n  }\n\n  if (!userId) {\n    // generate a random GUID.\n    userId = uuid.v4();\n  }\n\n  var userIdVals = {};\n  userIdVals[IdTokenFields.USER_ID] = userId;\n\n  if (isDisplayable) {\n    userIdVals[IdTokenFields.IS_USER_ID_DISPLAYABLE] = true;\n  }\n\n  return userIdVals;\n};\n\nfunction mapFields(inObj, outObj, map) {\n  for (var key in inObj) {\n    if (map[key]) {\n      var mappedKey = map[key];\n      outObj[mappedKey] = inObj[key];\n    }\n  }\n}\n/**\r\n * Given a decoded id token off the wire, this function extracts the values that\r\n * ADAL commonly returns to callers and translates the names to more user\r\n * friendly names.\r\n * @param  {Object} idToken A decoded id token.\r\n * @return {Object}         The set of extracted values with their new names.\r\n */\n\n\nOAuth2Client.prototype._extractIdTokenValues = function (idToken) {\n  var extractedValues = {};\n\n  _.extend(extractedValues, this._getUserId(idToken));\n\n  mapFields(idToken, extractedValues, IdTokenMap);\n  return extractedValues;\n};\n/**\r\n * Parses the value of the id_token OAuth 2 Reponse.\r\n * @param  {string} encodedIdToken An unencrypted JWT token.\r\n * @return {object}                 returns the decoded id_token or undefined.\r\n */\n\n\nOAuth2Client.prototype._parseIdToken = function (encodedIdToken) {\n  var crackedToken = this._crackJwt(encodedIdToken);\n\n  if (!crackedToken) {\n    return;\n  }\n\n  var idToken;\n\n  try {\n    var base64IdToken = crackedToken.JWSPayload;\n    var base64Decoded = util.base64DecodeStringUrlSafe(base64IdToken);\n\n    if (!base64Decoded) {\n      this._log.warn('The returned id_token could not be base64 url safe decoded.');\n\n      return;\n    }\n\n    idToken = JSON.parse(base64Decoded);\n  } catch (err) {\n    this._log.warn('the returned id_token could not be decoded');\n\n    this._log.warn('The returned id_token could not be decoded: ' + err.stack, true);\n\n    return;\n  }\n\n  return this._extractIdTokenValues(idToken);\n};\n/**\r\n * Validates the response returned from an OAuth 2.0 token request.\r\n * @private\r\n * @param  {string} body  The response as a string encoded JSON object.\r\n * @return {object}       The parsed response.\r\n */\n\n\nOAuth2Client.prototype._validateTokenResponse = function (body) {\n  var wireResponse;\n  var tokenResponse = {};\n\n  try {\n    wireResponse = JSON.parse(body);\n  } catch (e) {\n    throw new Error('The token response returned from the server is unparseable as JSON');\n  }\n\n  var intKeys = [OAuth2ResponseParameters.EXPIRES_ON, OAuth2ResponseParameters.EXPIRES_IN, OAuth2ResponseParameters.CREATED_ON];\n\n  this._parseOptionalInts(wireResponse, intKeys);\n\n  if (wireResponse[OAuth2ResponseParameters.EXPIRES_IN]) {\n    var expiresIn = wireResponse[OAuth2ResponseParameters.EXPIRES_IN];\n    var now = new Date();\n    wireResponse[OAuth2ResponseParameters.EXPIRES_ON] = now.add({\n      seconds: expiresIn\n    });\n  }\n\n  if (wireResponse[OAuth2ResponseParameters.CREATED_ON]) {\n    var tempDate = new Date();\n    var createdOn = wireResponse[OAuth2ResponseParameters.CREATED_ON];\n    tempDate.setTime(createdOn);\n    wireResponse[OAuth2ResponseParameters.CREATED_ON] = tempDate;\n  }\n\n  if (!wireResponse[OAuth2ResponseParameters.TOKEN_TYPE]) {\n    throw this._log.createError('wireResponse is missing token_type');\n  }\n\n  if (!wireResponse[OAuth2ResponseParameters.ACCESS_TOKEN]) {\n    throw this._log.createError('wireResponse missing access_token');\n  }\n\n  mapFields(wireResponse, tokenResponse, TOKEN_RESPONSE_MAP);\n\n  if (wireResponse[OAuth2ResponseParameters.ID_TOKEN]) {\n    var idToken = this._parseIdToken(wireResponse[OAuth2ResponseParameters.ID_TOKEN]);\n\n    if (idToken) {\n      _.extend(tokenResponse, idToken);\n    }\n  }\n\n  return tokenResponse;\n};\n/**\r\n * Validates the response returned from an OAuth 2.0 device code request.\r\n * @private\r\n * @param  {string} body  The response as a string encoded JSON object.\r\n * @return {object}       The parsed response.\r\n */\n\n\nOAuth2Client.prototype._validateDeviceCodeResponse = function (body) {\n  var wireResponse;\n  var deviceCodeResponse = {};\n\n  try {\n    wireResponse = JSON.parse(body);\n  } catch (e) {\n    throw new Error('The device code response returned from the server is unparseable as JSON.');\n  }\n\n  var intKeys = [DeviceCodeResponseParameters.EXPIRES_IN, DeviceCodeResponseParameters.INTERVAL];\n\n  this._parseOptionalInts(wireResponse, intKeys);\n\n  if (!wireResponse[DeviceCodeResponseParameters.EXPIRES_IN]) {\n    throw this._log.createError('wireResponse is missing expires_in');\n  }\n\n  if (!wireResponse[DeviceCodeResponseParameters.DEVICE_CODE]) {\n    throw this._log.createError('wireResponse is missing device code');\n  }\n\n  if (!wireResponse[DeviceCodeResponseParameters.USER_CODE]) {\n    throw this._log.createError('wireResponse is missing user code');\n  }\n\n  mapFields(wireResponse, deviceCodeResponse, DEVICE_CODE_RESPONSE_MAP);\n  return deviceCodeResponse;\n};\n/**\r\n * @private\r\n * @param {string}                   body        The body of a http token response.\r\n */\n\n\nOAuth2Client.prototype._handlePollingResponse = function (body) {\n  //handle token error response\n  var tokenResponse = this._handlePollingRequestErrorResponse(body);\n\n  if (_.isEmpty(tokenResponse)) {\n    tokenResponse = this._validateTokenResponse(body);\n  }\n\n  return tokenResponse;\n};\n/**\r\n * @private\r\n * @param {string}                   body        The body of a http token response.\r\n */\n\n\nOAuth2Client.prototype._handlePollingRequestErrorResponse = function (body) {\n  var wireResponse;\n  var tokenResponse = {};\n\n  try {\n    wireResponse = JSON.parse(body);\n  } catch (e) {\n    throw new Error('The token response returned from the server is unparsable as JSON');\n  }\n\n  if (wireResponse[OAuth2ResponseParameters.ERROR]) {\n    mapFields(wireResponse, tokenResponse, TOKEN_RESPONSE_MAP);\n  }\n\n  return tokenResponse;\n};\n/**\r\n * @private\r\n * @param {object}                   response    An http response object.\r\n * @param {string}                   body        The body of a http token response.\r\n * @param {OAuth2Client.GetTokenCallback}    callback    A call back function.  The body parameter is the body parameter passed\r\n *                                               into this function.\r\n */\n\n\nOAuth2Client.prototype._handleGetTokenResponse = function (response, body, callback) {\n  var tokenResponse;\n\n  try {\n    tokenResponse = this._validateTokenResponse(body);\n  } catch (e) {\n    this._log.error('Error validating get token response', e, true);\n\n    callback(e);\n    return;\n  }\n\n  callback(null, tokenResponse);\n};\n\nOAuth2Client.prototype._handleGetDeviceCodeResponse = function (response, body, callback) {\n  var deviceCodeResponse;\n\n  try {\n    deviceCodeResponse = this._validateDeviceCodeResponse(body);\n  } catch (e) {\n    this._log.error('Error validating get user code response', e, true);\n\n    callback(e);\n    return;\n  }\n\n  callback(null, deviceCodeResponse);\n};\n\nOAuth2Client.prototype._getTokenWithPolling = function (postOptions, callback) {\n  var self = this;\n\n  if (self._cancelPollingRequest === true) {\n    callback(null, new Error('Polling_Request_Cancelled'));\n    return;\n  }\n\n  request.post(postOptions, util.createRequestHandler('Get Token', this._log, function (response, body) {\n    //error response callback, for error response, it's already parsed as Json. \n    if (body && body.hasOwnProperty(TokenResponseFields.ERROR) && body[TokenResponseFields.ERROR] === 'authorization_pending') {\n      callback(new Error(body[TokenResponseFields.ERROR]), body);\n    } else {\n      callback(null, body);\n    }\n  }, // success response callback\n  function (response, body) {\n    var tokenResponse;\n\n    try {\n      tokenResponse = self._handlePollingResponse(body);\n    } catch (e) {\n      self._log.error('Error validating get token response', e, true);\n\n      callback(null, e);\n      return;\n    }\n\n    callback(null, tokenResponse);\n  }));\n};\n\nOAuth2Client.prototype._createPostOption = function (postUrl, urlEncodedRequestForm) {\n  var postOptions = util.createRequestOptions(this, {\n    'url': url.format(postUrl),\n    body: urlEncodedRequestForm,\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    },\n    followRedirect: false,\n    encoding: 'utf8'\n  });\n  return postOptions;\n};\n/**\r\n * @callback GetTokenCallback\r\n * @memberOf OAuth2Client\r\n * @param {Error} [error] In case of an error this will hold the associated Error object.\r\n * @param {TokenResponse} tokenResponse Contains the parsed result of a get token request.\r\n */\n\n/**\r\n* @param {object}                           oauthParameters     An object whose keys come from\r\n*                                                               Constants.OAuth2.Parameters\r\n* @param {OAuth2Client.GetTokenCallback}   callback            The callback function.\r\n*/\n\n\nOAuth2Client.prototype.getToken = function (oauthParameters, callback) {\n  var self = this;\n\n  var tokenUrl = self._createTokenUrl();\n\n  var urlEncodedTokenRequestForm = querystring.stringify(oauthParameters);\n\n  var postOptions = self._createPostOption(tokenUrl, urlEncodedTokenRequestForm);\n\n  request.post(postOptions, util.createRequestHandler('Get Token', this._log, callback, function (response, body) {\n    self._handleGetTokenResponse(response, body, callback);\n  }));\n};\n/**\r\n * @param {object}                          oauthParameters     An object whose keys come from\r\n *                                                               Constants.OAuth2.Parameters\r\n * @param {integer}                         refresh_interval    The interval for polling request. \r\n * @param {integer}                         exipres_in          The timeout for polling request. \r\n * @param {OAuth2Client.GetTokenCallback}   callback            The callback function.\r\n */\n\n\nOAuth2Client.prototype.getTokenWithPolling = function (oauthParameters, refresh_interval, expires_in, callback) {\n  var self = this;\n  var maxTimesForRetry = Math.floor(expires_in / refresh_interval);\n\n  var tokenUrl = self._createTokenUrl();\n\n  var urlEncodedTokenRequestForm = querystring.stringify(oauthParameters);\n\n  var postOptions = self._createPostOption(tokenUrl, urlEncodedTokenRequestForm);\n\n  var optionsForRetry = {\n    times: maxTimesForRetry,\n    interval: refresh_interval * 1000\n  };\n  async.retry(optionsForRetry, function (retryCallback, response) {\n    self._getTokenWithPolling(postOptions, retryCallback);\n  }, function (err, response) {\n    if (response && response instanceof Error) {\n      callback(response);\n      return;\n    } else if (response && response.hasOwnProperty(DeviceCodeResponseParameters.ERROR)) {\n      callback(response);\n      return;\n    }\n\n    callback(err, response);\n  });\n};\n\nOAuth2Client.prototype.getUserCodeInfo = function (oauthParameters, callback) {\n  // for now make it as a post request\n  var self = this;\n\n  var deviceCodeUrl = self._createDeviceCodeUrl();\n\n  var urlEncodedDeviceCodeRequestForm = querystring.stringify(oauthParameters);\n\n  var postOptions = self._createPostOption(deviceCodeUrl, urlEncodedDeviceCodeRequestForm);\n\n  request.post(postOptions, util.createRequestHandler('Get Device Code ', this._log, callback, function (response, body) {\n    self._handleGetDeviceCodeResponse(response, body, callback);\n  }));\n};\n/**\r\n * Cancel the polling request made for acquiring token by device code. \r\n */\n\n\nOAuth2Client.prototype.cancelPollingRequest = function () {\n  this._cancelPollingRequest = true;\n};\n\nmodule.exports = OAuth2Client;","map":null,"metadata":{},"sourceType":"script"}