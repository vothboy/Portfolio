{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Connector = exports.SequentialConnectionStrategy = exports.ParallelConnectionStrategy = void 0;\n\nvar _net = _interopRequireDefault(require(\"net\"));\n\nvar _dns = _interopRequireDefault(require(\"dns\"));\n\nvar punycode = _interopRequireWildcard(require(\"punycode\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar ParallelConnectionStrategy = /*#__PURE__*/function () {\n  function ParallelConnectionStrategy(addresses, options) {\n    _classCallCheck(this, ParallelConnectionStrategy);\n\n    this.addresses = void 0;\n    this.options = void 0;\n    this.addresses = addresses;\n    this.options = options;\n  }\n\n  _createClass(ParallelConnectionStrategy, [{\n    key: \"connect\",\n    value: function connect(callback) {\n      var addresses = this.addresses;\n      var sockets = new Array(addresses.length);\n      var errorCount = 0;\n\n      function onError(_err) {\n        errorCount += 1;\n        this.removeListener('error', onError);\n        this.removeListener('connect', onConnect);\n\n        if (errorCount === addresses.length) {\n          callback(new Error('Could not connect (parallel)'));\n        }\n      }\n\n      function onConnect() {\n        for (var j = 0; j < sockets.length; j++) {\n          var socket = sockets[j];\n\n          if (this === socket) {\n            continue;\n          }\n\n          socket.removeListener('error', onError);\n          socket.removeListener('connect', onConnect);\n          socket.destroy();\n        }\n\n        callback(null, this);\n      }\n\n      for (var i = 0, len = addresses.length; i < len; i++) {\n        var socket = sockets[i] = _net.default.connect(Object.create(this.options, {\n          host: {\n            value: addresses[i].address\n          }\n        }));\n\n        socket.on('error', onError);\n        socket.on('connect', onConnect);\n      }\n    }\n  }]);\n\n  return ParallelConnectionStrategy;\n}();\n\nexports.ParallelConnectionStrategy = ParallelConnectionStrategy;\n\nvar SequentialConnectionStrategy = /*#__PURE__*/function () {\n  function SequentialConnectionStrategy(addresses, options) {\n    _classCallCheck(this, SequentialConnectionStrategy);\n\n    this.addresses = void 0;\n    this.options = void 0;\n    this.addresses = addresses;\n    this.options = options;\n  }\n\n  _createClass(SequentialConnectionStrategy, [{\n    key: \"connect\",\n    value: function connect(callback) {\n      var _this = this;\n\n      var next = this.addresses.shift();\n\n      if (!next) {\n        return callback(new Error('Could not connect (sequence)'));\n      }\n\n      var socket = _net.default.connect(Object.create(this.options, {\n        host: {\n          value: next.address\n        }\n      }));\n\n      var onError = function onError(_err) {\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n        socket.destroy();\n\n        _this.connect(callback);\n      };\n\n      var onConnect = function onConnect() {\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n        callback(null, socket);\n      };\n\n      socket.on('error', onError);\n      socket.on('connect', onConnect);\n    }\n  }]);\n\n  return SequentialConnectionStrategy;\n}();\n\nexports.SequentialConnectionStrategy = SequentialConnectionStrategy;\n\nvar Connector = /*#__PURE__*/function () {\n  function Connector(options, multiSubnetFailover) {\n    _classCallCheck(this, Connector);\n\n    this.options = void 0;\n    this.multiSubnetFailover = void 0;\n    this.options = options;\n    this.multiSubnetFailover = multiSubnetFailover;\n  }\n\n  _createClass(Connector, [{\n    key: \"execute\",\n    value: function execute(cb) {\n      if (_net.default.isIP(this.options.host)) {\n        this.executeForIP(cb);\n      } else {\n        this.executeForHostname(cb);\n      }\n    }\n  }, {\n    key: \"executeForIP\",\n    value: function executeForIP(cb) {\n      var socket = _net.default.connect(this.options);\n\n      var onError = function onError(err) {\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n        socket.destroy();\n        cb(err);\n      };\n\n      var onConnect = function onConnect() {\n        socket.removeListener('error', onError);\n        socket.removeListener('connect', onConnect);\n        cb(null, socket);\n      };\n\n      socket.on('error', onError);\n      socket.on('connect', onConnect);\n    }\n  }, {\n    key: \"executeForHostname\",\n    value: function executeForHostname(cb) {\n      var _this2 = this;\n\n      _dns.default.lookup(punycode.toASCII(this.options.host), {\n        all: true\n      }, function (err, addresses) {\n        if (err) {\n          return cb(err);\n        }\n\n        if (_this2.multiSubnetFailover) {\n          new ParallelConnectionStrategy(addresses, _this2.options).connect(cb);\n        } else {\n          new SequentialConnectionStrategy(addresses, _this2.options).connect(cb);\n        }\n      });\n    }\n  }]);\n\n  return Connector;\n}();\n\nexports.Connector = Connector;","map":null,"metadata":{},"sourceType":"script"}