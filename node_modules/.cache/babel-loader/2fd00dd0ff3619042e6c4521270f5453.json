{"ast":null,"code":"/*\r\n * @copyright\r\n * Copyright Â© Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\n'use strict';\n\nvar xmldom = require('xmldom');\n\nvar xmlutil = require('./xmlutil');\n\nvar Logger = require('./log').Logger;\n\nvar WSTrustVersion = require('./constants').WSTrustVersion;\n\nvar select = xmlutil.xpathSelect;\nvar DOMParser = xmldom.DOMParser; // A regular expression for finding the SAML Assertion in an RSTR.  Used to remove the SAML\n// assertion when logging the RSTR.\n\nvar assertionRegEx = /RequestedSecurityToken.*?((<.*?:Assertion.*?>).*<\\/.*?Assertion>).*?/;\n/**\r\n * Creates a log message that contains the RSTR scrubbed of the actual SAML assertion.\r\n * @private\r\n * @return {string} A log message.\r\n */\n\nfunction scrubRSTRLogMessage(RSTR) {\n  var scrubbedRSTR = null;\n  var singleLineRSTR = RSTR.replace(/(\\r\\n|\\n|\\r)/gm, '');\n  var matchResult = assertionRegEx.exec(singleLineRSTR);\n\n  if (null === matchResult) {\n    // No Assertion was matched so just return the RSTR as is.\n    scrubbedRSTR = singleLineRSTR;\n  } else {\n    var samlAssertion = matchResult[1];\n    var samlAssertionStartTag = matchResult[2];\n    scrubbedRSTR = singleLineRSTR.replace(samlAssertion, samlAssertionStartTag + 'ASSERTION CONTENTS REDACTED</saml:Assertion>');\n  }\n\n  return 'RSTR Response: ' + scrubbedRSTR;\n}\n/**\r\n * Creates a new WSTrustResponse instance.\r\n * @constructor\r\n * @private\r\n * @param {object} callContext Contains any context information that applies to the request.\r\n * @param {string} response   A soap response from a WS-Trust request.\r\n * @param {sting}  wstrustVersion The version for the WS-Trust request. \r\n */\n\n\nfunction WSTrustResponse(callContext, response, wstrustVersion) {\n  this._log = new Logger('WSTrustResponse', callContext._logContext);\n  this._callContext = callContext;\n  this._response = response;\n  this._dom = null;\n  this._errorCode = null;\n  this._faultMessage = null;\n  this._tokenType = null;\n  this._token = null;\n  this._wstrustVersion = wstrustVersion;\n\n  this._log.verbose(function () {\n    return scrubRSTRLogMessage(response);\n  });\n}\n/**\r\n * If the soap response contained a soap fault then this property will contain the fault\r\n * error code.  Otherwise it will return null\r\n * @instance\r\n * @type {string}\r\n * @memberOf WSTrustResponse\r\n * @name errorCode\r\n */\n\n\nObject.defineProperty(WSTrustResponse.prototype, 'errorCode', {\n  get: function get() {\n    return this._errorCode;\n  }\n});\n/**\r\n * @property {string} FaultMessage If the soap resopnse contained a soap fault with a fault message then it will\r\n * be returned by this property.\r\n * @instance\r\n * @type {string}\r\n * @memberOf WSTrustResponse\r\n * @name faultMessage\r\n */\n\nObject.defineProperty(WSTrustResponse.prototype, 'faultMessage', {\n  get: function get() {\n    return this._faultMessage;\n  }\n});\n/**\r\n * @property {string} TokenType If the soap resonse contained a token then this property will contain\r\n * the token type uri\r\n * @instance\r\n * @type {string}\r\n * @memberOf WSTrustResponse\r\n * @name tokenType\r\n */\n\nObject.defineProperty(WSTrustResponse.prototype, 'tokenType', {\n  get: function get() {\n    return this._tokenType;\n  }\n});\n/**\r\n * @property {string} Token If the soap response contained a token then this property will hold that token.\r\n * @instance\r\n * @type {string}\r\n * @memberOf WSTrustResponse\r\n * @name token\r\n */\n\nObject.defineProperty(WSTrustResponse.prototype, 'token', {\n  get: function get() {\n    return this._token;\n  }\n}); // Sample error message\n//<s:Envelope xmlns:s=\"http://www.w3.org/2003/05/soap-envelope\" xmlns:a=\"http://www.w3.org/2005/08/addressing\" xmlns:u=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">\n//   <s:Header>\n//    <a:Action s:mustUnderstand=\"1\">http://www.w3.org/2005/08/addressing/soap/fault</a:Action>\n//  - <o:Security s:mustUnderstand=\"1\" xmlns:o=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\">\n//      <u:Timestamp u:Id=\"_0\">\n//      <u:Created>2013-07-30T00:32:21.989Z</u:Created>\n//      <u:Expires>2013-07-30T00:37:21.989Z</u:Expires>\n//      </u:Timestamp>\n//    </o:Security>\n//    </s:Header>\n//  <s:Body>\n//    <s:Fault>\n//      <s:Code>\n//        <s:Value>s:Sender</s:Value>\n//        <s:Subcode>\n//        <s:Value xmlns:a=\"http://docs.oasis-open.org/ws-sx/ws-trust/200512\">a:RequestFailed</s:Value>\n//        </s:Subcode>\n//      </s:Code>\n//      <s:Reason>\n//      <s:Text xml:lang=\"en-US\">MSIS3127: The specified request failed.</s:Text>\n//      </s:Reason>\n//    </s:Fault>\n// </s:Body>\n//</s:Envelope>\n\n/**\r\n * Attempts to parse an error from the soap response.  If there is one then it\r\n * will fill in the error related properties.  Otherwsie it will do nothing.\r\n * @private\r\n * @returns {bool} true if an error was found and parsed in the response.\r\n */\n\nWSTrustResponse.prototype._parseError = function () {\n  var errorFound = false;\n  var faultNode = select(this._dom, '//s:Envelope/s:Body/s:Fault/s:Reason');\n\n  if (faultNode.length) {\n    this._faultMessage = xmlutil.serializeNodeChildren(faultNode[0]);\n\n    if (this._faultMessage) {\n      errorFound = true;\n    }\n  } // Subcode has minoccurs=0 and maxoccurs=1(default) according to the http://www.w3.org/2003/05/soap-envelope\n  // Subcode may have another subcode as well. This is only targetting at top level subcode.\n  // Subcode value may have different messages not always uses http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd.\n  // text inside the value is not possible to select without prefix, so substring is necessary\n\n\n  var subcodeNode = select(this._dom, '//s:Envelope/s:Body/s:Fault/s:Code/s:Subcode/s:Value');\n\n  if (1 < subcodeNode.length) {\n    throw this._log.createError('Found too many fault code values:' + subcodeNode.length);\n  }\n\n  if (subcodeNode.length) {\n    var errorCode = subcodeNode[0].firstChild.data;\n    this._errorCode = errorCode.split(':')[1];\n    errorFound = true;\n  }\n\n  return errorFound;\n};\n/**\r\n * Attempts to parse a token from the soap response.  If there is one then it will fill in the\r\n * token related properties.  Otherwise it does nothing.\r\n * @private\r\n * @throws {Error} If the response is not parseable, or too many tokens are found.\r\n */\n\n\nWSTrustResponse.prototype._parseToken = function () {\n  var xPath = this._wstrustVersion === WSTrustVersion.WSTRUST2005 ? '//s:Envelope/s:Body/t:RequestSecurityTokenResponse/t:TokenType' : '//s:Envelope/s:Body/wst:RequestSecurityTokenResponseCollection/wst:RequestSecurityTokenResponse/wst:TokenType';\n  var tokenTypeNodes = select(this._dom, xPath);\n\n  if (!tokenTypeNodes.length) {\n    this._log.warn('No TokenType elements found in RSTR');\n  }\n\n  for (var i = 0, length = tokenTypeNodes.length; i < length; i++) {\n    if (this._token) {\n      this._log.warn('Found more than one returned token.  Using the first.');\n\n      break;\n    }\n\n    var tokenTypeNode = tokenTypeNodes[i];\n    var tokenType = xmlutil.findElementText(tokenTypeNode);\n\n    if (!tokenType) {\n      this._log.warn('Could not find token type in RSTR token');\n    }\n\n    var securityTokenPath = this._wstrustVersion === WSTrustVersion.WSTRUST2005 ? 't:RequestedSecurityToken' : 'wst:RequestedSecurityToken';\n    var requestedTokenNode = select(tokenTypeNode.parentNode, securityTokenPath);\n\n    if (1 < requestedTokenNode) {\n      throw this._log.createError('Found too many RequestedSecurityToken nodes for token type: ' + tokenType);\n    }\n\n    if (!requestedTokenNode.length) {\n      this._log.warn('Unable to find RequestsSecurityToken element associated with TokenType element: ' + tokenType);\n\n      continue;\n    }\n\n    var token = xmlutil.serializeNodeChildren(requestedTokenNode[0]);\n\n    if (!token) {\n      this._log.warn('Unable to find token associated with TokenType element: ' + tokenType);\n\n      continue;\n    }\n\n    this._token = token;\n    this._tokenType = tokenType;\n\n    this._log.info('Found token of type: ' + this._tokenType);\n  }\n\n  if (!this._token) {\n    throw this._log.createError('Unable to find any tokens in RSTR.');\n  }\n};\n/**\r\n * This method parses the soap response that was passed in at construction.\r\n * @throws {Error} If the server returned an error, or there was any failure to parse the response.\r\n */\n\n\nWSTrustResponse.prototype.parse = function () {\n  if (!this._response) {\n    throw this._log.createError('Received empty RSTR response body.');\n  }\n\n  try {\n    try {\n      var options = {\n        errorHandler: this._log.error\n      };\n      this._dom = new DOMParser(options).parseFromString(this._response);\n    } catch (err) {\n      throw this._log.createError('Failed to parse RSTR in to DOM', err, true);\n    }\n\n    var errorFound = this._parseError();\n\n    if (errorFound) {\n      var stringErrorCode = this.ErrorCode || 'NONE';\n      var stringFaultMessage = this.FaultMessage || 'NONE';\n      throw this._log.createError('Server returned error in RSTR - ErrorCode: ' + stringErrorCode + ' : FaultMessage: ' + stringFaultMessage, true);\n    }\n\n    this._parseToken();\n  } catch (err) {\n    delete this._dom;\n    throw err;\n  }\n};\n\nmodule.exports = WSTrustResponse;","map":null,"metadata":{},"sourceType":"script"}