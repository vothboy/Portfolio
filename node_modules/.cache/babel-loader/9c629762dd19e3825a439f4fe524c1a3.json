{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar adal = require(\"adal-node\");\n\nvar msRest = require(\"@azure/ms-rest-js\");\n\nvar child_process_1 = require(\"child_process\");\n\nvar fs_1 = require(\"fs\");\n\nvar ms_rest_azure_env_1 = require(\"@azure/ms-rest-azure-env\");\n\nvar applicationTokenCredentials_1 = require(\"./credentials/applicationTokenCredentials\");\n\nvar applicationTokenCertificateCredentials_1 = require(\"./credentials/applicationTokenCertificateCredentials\");\n\nvar deviceTokenCredentials_1 = require(\"./credentials/deviceTokenCredentials\");\n\nvar userTokenCredentials_1 = require(\"./credentials/userTokenCredentials\");\n\nvar authConstants_1 = require(\"./util/authConstants\");\n\nvar subscriptionUtils_1 = require(\"./subscriptionManagement/subscriptionUtils\");\n\nvar msiVmTokenCredentials_1 = require(\"./credentials/msiVmTokenCredentials\");\n\nvar msiAppServiceTokenCredentials_1 = require(\"./credentials/msiAppServiceTokenCredentials\");\n/**\n * @constant {Array<string>} managementPlaneTokenAudiences - Urls for management plane token\n * audience across different azure environments.\n */\n\n\nvar managementPlaneTokenAudiences = [\"https://management.core.windows.net/\", \"https://management.core.chinacloudapi.cn/\", \"https://management.core.usgovcloudapi.net/\", \"https://management.core.cloudapi.de/\", \"https://management.azure.com/\", \"https://management.core.windows.net\", \"https://management.core.chinacloudapi.cn\", \"https://management.core.usgovcloudapi.net\", \"https://management.core.cloudapi.de\", \"https://management.azure.com\"];\n\nfunction turnOnLogging() {\n  var log = adal.Logging;\n  log.setLoggingOptions({\n    level: 3,\n    log: function log(level, message, error) {\n      level;\n      console.info(message);\n\n      if (error) {\n        console.error(error);\n      }\n    }\n  });\n}\n\nif (process.env[\"AZURE_ADAL_LOGGING_ENABLED\"]) {\n  turnOnLogging();\n}\n/**\n * Provides a UserTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\n * This method is applicable only for organizational ids that are not 2FA enabled otherwise please use interactive login.\n *\n * @param {string} username The user name for the Organization Id account.\n * @param {string} password The password for the Organization Id account.\n * @param {object} [options] Object representing optional parameters.\n * @param {string} [options.clientId] The active directory application client id.\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferrably in a guid format).\n * @param {string} [options.domain] The domain or tenant id containing this application. Default value \"common\".\n * @param {Environment} [options.environment] The azure environment to authenticate with.\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse that contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\n\nfunction withUsernamePasswordWithAuthResponse(username, password, options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var creds, tenantList, subscriptionList;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!options) {\n              options = {};\n            }\n\n            if (!options.clientId) {\n              options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\n            }\n\n            if (!options.domain) {\n              options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\n            }\n\n            if (!options.environment) {\n              options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n            }\n\n            tenantList = [];\n            subscriptionList = [];\n            _context.prev = 6;\n            creds = new userTokenCredentials_1.UserTokenCredentials(options.clientId, options.domain, username, password, options.tokenAudience, options.environment);\n            _context.next = 10;\n            return creds.getToken();\n\n          case 10:\n            _context.next = 12;\n            return subscriptionUtils_1.buildTenantList(creds);\n\n          case 12:\n            tenantList = _context.sent;\n            _context.next = 15;\n            return _getSubscriptions(creds, tenantList, options.tokenAudience);\n\n          case 15:\n            subscriptionList = _context.sent;\n            _context.next = 21;\n            break;\n\n          case 18:\n            _context.prev = 18;\n            _context.t0 = _context[\"catch\"](6);\n            return _context.abrupt(\"return\", Promise.reject(_context.t0));\n\n          case 21:\n            return _context.abrupt(\"return\", Promise.resolve({\n              credentials: creds,\n              subscriptions: subscriptionList\n            }));\n\n          case 22:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[6, 18]]);\n  }));\n}\n\nexports.withUsernamePasswordWithAuthResponse = withUsernamePasswordWithAuthResponse;\n/**\n * Provides an ApplicationTokenCredentials object and the list of subscriptions associated with that servicePrinicpalId/clientId across all the applicable tenants.\n *\n * @param {string} clientId The active directory application client id also known as the SPN (ServicePrincipal Name).\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param {string} secret The application secret for the service principal.\n * @param {string} domain The domain or tenant id containing this application.\n * @param {object} [options] Object representing optional parameters.\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferrably in a guid format).\n * @param {Environment} [options.environment] The azure environment to authenticate with.\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse that contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\nfunction withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var creds, subscriptionList;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!options) {\n              options = {};\n            }\n\n            if (!options.environment) {\n              options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n            }\n\n            subscriptionList = [];\n            _context2.prev = 3;\n            creds = new applicationTokenCredentials_1.ApplicationTokenCredentials(clientId, domain, secret, options.tokenAudience, options.environment);\n            _context2.next = 7;\n            return creds.getToken();\n\n          case 7:\n            _context2.next = 9;\n            return _getSubscriptions(creds, [domain], options.tokenAudience);\n\n          case 9:\n            subscriptionList = _context2.sent;\n            _context2.next = 15;\n            break;\n\n          case 12:\n            _context2.prev = 12;\n            _context2.t0 = _context2[\"catch\"](3);\n            return _context2.abrupt(\"return\", Promise.reject(_context2.t0));\n\n          case 15:\n            return _context2.abrupt(\"return\", Promise.resolve({\n              credentials: creds,\n              subscriptions: subscriptionList\n            }));\n\n          case 16:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[3, 12]]);\n  }));\n}\n\nexports.withServicePrincipalSecretWithAuthResponse = withServicePrincipalSecretWithAuthResponse;\n/**\n * Provides an ApplicationTokenCertificateCredentials object and the list of subscriptions associated with that servicePrinicpalId/clientId across all the applicable tenants.\n *\n * @param {string} clientId The active directory application client id also known as the SPN (ServicePrincipal Name).\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param {string} certificateStringOrFilePath A PEM encoded certificate and private key OR an absolute filepath to the .pem file containing that information. For example:\n * - CertificateString: \"-----BEGIN PRIVATE KEY-----\\n<xxxxx>\\n-----END PRIVATE KEY-----\\n-----BEGIN CERTIFICATE-----\\n<yyyyy>\\n-----END CERTIFICATE-----\\n\"\n * - CertificateFilePath: **Absolute** file path of the .pem file.\n * @param {string} domain The domain or tenant id containing this application.\n * @param {object} [options] Object representing optional parameters.\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferrably in a guid format).\n * @param {Environment} [options.environment] The azure environment to authenticate with.\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse that contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\nfunction withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var creds, subscriptionList;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!options) {\n              options = {};\n            }\n\n            if (!options.environment) {\n              options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n            }\n\n            subscriptionList = [];\n            _context3.prev = 3;\n            creds = applicationTokenCertificateCredentials_1.ApplicationTokenCertificateCredentials.create(clientId, certificateStringOrFilePath, domain, options);\n            _context3.next = 7;\n            return creds.getToken();\n\n          case 7:\n            _context3.next = 9;\n            return _getSubscriptions(creds, [domain], options.tokenAudience);\n\n          case 9:\n            subscriptionList = _context3.sent;\n            _context3.next = 15;\n            break;\n\n          case 12:\n            _context3.prev = 12;\n            _context3.t0 = _context3[\"catch\"](3);\n            return _context3.abrupt(\"return\", Promise.reject(_context3.t0));\n\n          case 15:\n            return _context3.abrupt(\"return\", Promise.resolve({\n              credentials: creds,\n              subscriptions: subscriptionList\n            }));\n\n          case 16:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[3, 12]]);\n  }));\n}\n\nexports.withServicePrincipalCertificateWithAuthResponse = withServicePrincipalCertificateWithAuthResponse;\n\nfunction validateAuthFileContent(credsObj, filePath) {\n  if (!credsObj) {\n    throw new Error(\"Please provide a credsObj to validate.\");\n  }\n\n  if (!filePath) {\n    throw new Error(\"Please provide a filePath.\");\n  }\n\n  if (!credsObj.clientId) {\n    throw new Error(\"\\\"clientId\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.clientSecret && !credsObj.clientCertificate) {\n    throw new Error(\"Either \\\"clientSecret\\\" or \\\"clientCertificate\\\" must be present in the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.subscriptionId) {\n    throw new Error(\"\\\"subscriptionId\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.tenantId) {\n    throw new Error(\"\\\"tenantId\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.activeDirectoryEndpointUrl) {\n    throw new Error(\"\\\"activeDirectoryEndpointUrl\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.resourceManagerEndpointUrl) {\n    throw new Error(\"\\\"resourceManagerEndpointUrl\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.activeDirectoryGraphResourceId) {\n    throw new Error(\"\\\"activeDirectoryGraphResourceId\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.sqlManagementEndpointUrl) {\n    throw new Error(\"\\\"sqlManagementEndpointUrl\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n}\n\nfunction foundManagementEndpointUrl(authFileUrl, envUrl) {\n  if (!authFileUrl || authFileUrl && typeof authFileUrl.valueOf() !== \"string\") {\n    throw new Error(\"authFileUrl cannot be null or undefined and must be of type string.\");\n  }\n\n  if (!envUrl || envUrl && typeof envUrl.valueOf() !== \"string\") {\n    throw new Error(\"envUrl cannot be null or undefined and must be of type string.\");\n  }\n\n  authFileUrl = authFileUrl.endsWith(\"/\") ? authFileUrl.slice(0, -1) : authFileUrl;\n  envUrl = envUrl.endsWith(\"/\") ? envUrl.slice(0, -1) : envUrl;\n  return authFileUrl.toLowerCase() === envUrl.toLowerCase();\n}\n/**\n * Before using this method please install az cli from https://github.com/Azure/azure-cli/releases. Then execute `az ad sp create-for-rbac --sdk-auth > ${yourFilename.json}`.\n * If you want to create the sp for a different cloud/environment then please execute:\n * 1. az cloud list\n * 2. az cloud set –n <name of the environment>\n * 3. az ad sp create-for-rbac --sdk-auth > auth.json // create sp with secret\n *  **OR**\n * 3. az ad sp create-for-rbac --create-cert --sdk-auth > auth.json // create sp with certificate\n * If the service principal is already created then login with service principal info:\n * 4. az login --service-principal -u <clientId> -p <clientSecret> -t <tenantId>\n * 5. az account show --sdk-auth > auth.json\n *\n * Authenticates using the service principal information provided in the auth file. This method will set\n * the subscriptionId from the auth file to the user provided environment variable in the options\n * parameter or the default \"AZURE_SUBSCRIPTION_ID\".\n *\n * @param {object} [options] - Optional parameters\n * @param {string} [options.filePath] - Absolute file path to the auth file. If not provided\n * then please set the environment variable AZURE_AUTH_LOCATION.\n * @param {string} [options.subscriptionEnvVariableName] - The subscriptionId environment variable\n * name. Default is \"AZURE_SUBSCRIPTION_ID\".\n * @param {function} [optionalCallback] The optional callback.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse that contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\n\nfunction withAuthFileWithAuthResponse(options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n    var filePath, subscriptionEnvVariableName, msg, content, credsObj, optionsForSp, envFound, envNames, i, env, environmentObj, envParams, keys, _i, key;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (!options) options = {\n              filePath: \"\"\n            };\n            filePath = options.filePath || process.env[authConstants_1.AuthConstants.AZURE_AUTH_LOCATION];\n            subscriptionEnvVariableName = options.subscriptionEnvVariableName || \"AZURE_SUBSCRIPTION_ID\";\n\n            if (filePath) {\n              _context4.next = 6;\n              break;\n            }\n\n            msg = \"Either provide an absolute file path to the auth file or set/export the environment variable - \".concat(authConstants_1.AuthConstants.AZURE_AUTH_LOCATION, \".\");\n            return _context4.abrupt(\"return\", Promise.reject(new Error(msg)));\n\n          case 6:\n            credsObj = {};\n            optionsForSp = {};\n            _context4.prev = 8;\n            content = fs_1.readFileSync(filePath, {\n              encoding: \"utf8\"\n            });\n            credsObj = JSON.parse(content);\n            validateAuthFileContent(credsObj, filePath);\n            _context4.next = 17;\n            break;\n\n          case 14:\n            _context4.prev = 14;\n            _context4.t0 = _context4[\"catch\"](8);\n            return _context4.abrupt(\"return\", Promise.reject(_context4.t0));\n\n          case 17:\n            if (!credsObj.managementEndpointUrl) {\n              credsObj.managementEndpointUrl = credsObj.resourceManagerEndpointUrl;\n            } // setting the subscriptionId from auth file to the environment variable\n\n\n            process.env[subscriptionEnvVariableName] = credsObj.subscriptionId; // get the AzureEnvironment or create a new AzureEnvironment based on the info provided in the auth file\n\n            envFound = {\n              name: \"\"\n            };\n            envNames = Object.keys(ms_rest_azure_env_1.Environment);\n            i = 0;\n\n          case 22:\n            if (!(i < envNames.length)) {\n              _context4.next = 31;\n              break;\n            }\n\n            env = envNames[i];\n            environmentObj = ms_rest_azure_env_1.Environment[env];\n\n            if (!(environmentObj && environmentObj.managementEndpointUrl && foundManagementEndpointUrl(credsObj.managementEndpointUrl, environmentObj.managementEndpointUrl))) {\n              _context4.next = 28;\n              break;\n            }\n\n            envFound.name = environmentObj.name;\n            return _context4.abrupt(\"break\", 31);\n\n          case 28:\n            i++;\n            _context4.next = 22;\n            break;\n\n          case 31:\n            if (envFound.name) {\n              optionsForSp.environment = ms_rest_azure_env_1.Environment[envFound.name];\n            } else {\n              // create a new environment with provided info.\n              envParams = {\n                // try to find a logical name or set the filepath as the env name.\n                name: credsObj.managementEndpointUrl.match(/.*management\\.core\\.(.*)\\..*/i)[1] || filePath\n              };\n              keys = Object.keys(credsObj);\n\n              for (_i = 0; _i < keys.length; _i++) {\n                key = keys[_i];\n\n                if (key.match(/^(clientId|clientSecret|clientCertificate|subscriptionId|tenantId)$/ig) === null) {\n                  if (key === \"activeDirectoryEndpointUrl\" && !key.endsWith(\"/\")) {\n                    envParams[key] = credsObj[key] + \"/\";\n                  } else {\n                    envParams[key] = credsObj[key];\n                  }\n                }\n              }\n\n              if (!envParams.activeDirectoryResourceId) {\n                envParams.activeDirectoryResourceId = credsObj.managementEndpointUrl;\n              }\n\n              if (!envParams.portalUrl) {\n                envParams.portalUrl = \"https://portal.azure.com\";\n              }\n\n              optionsForSp.environment = ms_rest_azure_env_1.Environment.add(envParams);\n            }\n\n            if (!credsObj.clientSecret) {\n              _context4.next = 34;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", withServicePrincipalSecretWithAuthResponse(credsObj.clientId, credsObj.clientSecret, credsObj.tenantId, optionsForSp));\n\n          case 34:\n            return _context4.abrupt(\"return\", withServicePrincipalCertificateWithAuthResponse(credsObj.clientId, credsObj.clientCertificate, credsObj.tenantId, optionsForSp));\n\n          case 35:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[8, 14]]);\n  }));\n}\n\nexports.withAuthFileWithAuthResponse = withAuthFileWithAuthResponse;\n/**\n * Provides a url and code that needs to be copy and pasted in a browser and authenticated over there. If successful, the user will get a\n * DeviceTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\n *\n * @param {object} [options] Object representing optional parameters.\n *\n * @param {string} [options.clientId] The active directory application client id.\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n *\n * @param {string} [options.tokenAudience] The audience for which the token is requested. Valid value is \"graph\".If tokenAudience is provided\n * then domain should also be provided its value should not be the default \"common\" tenant. It must be a string (preferrably in a guid format).\n *\n * @param {string} [options.domain] The domain or tenant id containing this application. Default value is \"common\".\n *\n * @param {Environment} [options.environment] The azure environment to authenticate with. Default environment is \"Public Azure\".\n *\n * @param {object} [options.tokenCache] The token cache. Default value is the MemoryCache object from adal.\n *\n * @param {object} [options.language] The language code specifying how the message should be localized to. Default value \"en-us\".\n *\n * @param {object|function} [options.userCodeResponseLogger] A logger that logs the user code response message required for interactive login. When\n * this option is specified the usercode response message will not be logged to console.\n *\n * @param {function} [optionalCallback] The optional callback.\n *\n * @returns {Promise<AuthResponse>} A Promise that resolves to AuthResponse that contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\nfunction withInteractiveWithAuthResponse(options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n    var interactiveOptions, authorityUrl, authContext, userCodeResponse, creds, tryAcquireToken, getUserCode;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            tryAcquireToken = function _tryAcquireToken(interactiveOptions, resolve, reject) {\n              authContext.acquireUserCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, interactiveOptions.language, function (err, userCodeRes) {\n                if (err) {\n                  if (err.error === \"authorization_pending\") {\n                    setTimeout(function () {\n                      tryAcquireToken(interactiveOptions, resolve, reject);\n                    }, 1000);\n                  } else {\n                    return reject(err);\n                  }\n                }\n\n                userCodeResponse = userCodeRes;\n\n                if (interactiveOptions.userCodeResponseLogger) {\n                  interactiveOptions.userCodeResponseLogger(userCodeResponse.message);\n                } else {\n                  console.log(userCodeResponse.message);\n                }\n\n                return resolve(userCodeResponse);\n              });\n            };\n\n            if (!options) {\n              options = {};\n            }\n\n            if (!options) {\n              options = {};\n            }\n\n            if (!options.environment) {\n              options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n            }\n\n            if (!options.domain) {\n              options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\n            }\n\n            if (!options.clientId) {\n              options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\n            }\n\n            if (!options.tokenCache) {\n              options.tokenCache = new adal.MemoryCache();\n            }\n\n            if (!options.language) {\n              options.language = authConstants_1.AuthConstants.DEFAULT_LANGUAGE;\n            }\n\n            if (!options.tokenAudience) {\n              options.tokenAudience = options.environment.activeDirectoryResourceId;\n            }\n\n            interactiveOptions = {};\n            interactiveOptions.tokenAudience = options.tokenAudience;\n            interactiveOptions.environment = options.environment;\n            interactiveOptions.domain = options.domain;\n            interactiveOptions.clientId = options.clientId;\n            interactiveOptions.tokenCache = options.tokenCache;\n            interactiveOptions.language = options.language;\n            interactiveOptions.userCodeResponseLogger = options.userCodeResponseLogger;\n            authorityUrl = interactiveOptions.environment.activeDirectoryEndpointUrl + interactiveOptions.domain;\n            authContext = new adal.AuthenticationContext(authorityUrl, interactiveOptions.environment.validateAuthority, interactiveOptions.tokenCache);\n            interactiveOptions.context = authContext;\n            getUserCode = new Promise(function (resolve, reject) {\n              return tryAcquireToken(interactiveOptions, resolve, reject);\n            });\n            return _context5.abrupt(\"return\", getUserCode.then(function () {\n              return new Promise(function (resolve, reject) {\n                return authContext.acquireTokenWithDeviceCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, userCodeResponse, function (error, tokenResponse) {\n                  if (error) {\n                    return reject(error);\n                  }\n\n                  interactiveOptions.userName = tokenResponse.userId;\n                  interactiveOptions.authorizationScheme = tokenResponse.tokenType;\n\n                  try {\n                    creds = new deviceTokenCredentials_1.DeviceTokenCredentials(interactiveOptions.clientId, interactiveOptions.domain, interactiveOptions.userName, interactiveOptions.tokenAudience, interactiveOptions.environment, interactiveOptions.tokenCache);\n                  } catch (err) {\n                    return reject(err);\n                  }\n\n                  return resolve(creds);\n                });\n              });\n            }).then(function (creds) {\n              return subscriptionUtils_1.buildTenantList(creds);\n            }).then(function (tenants) {\n              return _getSubscriptions(creds, tenants, interactiveOptions.tokenAudience);\n            }).then(function (subscriptions) {\n              return Promise.resolve({\n                credentials: creds,\n                subscriptions: subscriptions\n              });\n            }));\n\n          case 22:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n}\n\nexports.withInteractiveWithAuthResponse = withInteractiveWithAuthResponse;\n\nfunction withAuthFile(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return withAuthFileWithAuthResponse(options).then(function (authRes) {\n      return Promise.resolve(authRes.credentials);\n    }).catch(function (err) {\n      return Promise.reject(err);\n    });\n  } else {\n    msRest.promiseToCallback(withAuthFileWithAuthResponse(options))(function (err, authRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withAuthFile = withAuthFile;\n\nfunction interactive(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return withInteractiveWithAuthResponse(options).then(function (authRes) {\n      return Promise.resolve(authRes.credentials);\n    }).catch(function (err) {\n      return Promise.reject(err);\n    });\n  } else {\n    msRest.promiseToCallback(withInteractiveWithAuthResponse(options))(function (err, authRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.interactive = interactive;\n\nfunction withServicePrincipalSecret(clientId, secret, domain, options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options).then(function (authRes) {\n      return Promise.resolve(authRes.credentials);\n    }).catch(function (err) {\n      return Promise.reject(err);\n    });\n  } else {\n    msRest.promiseToCallback(withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options))(function (err, authRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withServicePrincipalSecret = withServicePrincipalSecret;\n\nfunction withServicePrincipalCertificate(clientId, certificateStringOrFilePath, domain, options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options).then(function (authRes) {\n      return Promise.resolve(authRes.credentials);\n    }).catch(function (err) {\n      return Promise.reject(err);\n    });\n  } else {\n    msRest.promiseToCallback(withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options))(function (err, authRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withServicePrincipalCertificate = withServicePrincipalCertificate;\n\nfunction withUsernamePassword(username, password, options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return withUsernamePasswordWithAuthResponse(username, password, options).then(function (authRes) {\n      return Promise.resolve(authRes.credentials);\n    }).catch(function (err) {\n      return Promise.reject(err);\n    });\n  } else {\n    msRest.promiseToCallback(withUsernamePasswordWithAuthResponse(username, password, options))(function (err, authRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withUsernamePassword = withUsernamePassword;\n/**\n * We only need to get the subscription list if the tokenAudience is for a management client.\n */\n\nfunction _getSubscriptions(creds, tenants, tokenAudience) {\n  if (tokenAudience && !managementPlaneTokenAudiences.some(function (item) {\n    return item === tokenAudience.toLowerCase();\n  })) {\n    return Promise.resolve([]);\n  }\n\n  return subscriptionUtils_1.getSubscriptionsFromTenants(creds, tenants);\n}\n/**\n * Initializes MSITokenCredentials class and calls getToken and returns a token response.\n *\n * @param {string} domain - required. The tenant id.\n * @param {object} options - Optional parameters\n * @param {string} [options.port] - port on which the MSI service is running on the host VM. Default port is 50342\n * @param {string} [options.resource] - The resource uri or token audience for which the token is needed. Default - \"https://management.azure.com/\"\n * @param {string} [options.aadEndpoint] - The add endpoint for authentication. default - \"https://login.microsoftonline.com\"\n * @param {any} callback - the callback function.\n */\n\n\nfunction _withMSI(options) {\n  if (!options) {\n    options = {};\n  }\n\n  return new Promise(function (resolve, reject) {\n    var creds = new msiVmTokenCredentials_1.MSIVmTokenCredentials(options);\n    creds.getToken().then(function (_tokenResponse) {\n      // We ignore the token response, it's put in the cache.\n      return resolve(creds);\n    }).catch(function (error) {\n      reject(error);\n    });\n  });\n}\n\nfunction loginWithVmMSI(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return _withMSI(options);\n  } else {\n    msRest.promiseToCallback(_withMSI(options))(function (err, tokenRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, tokenRes);\n    });\n  }\n}\n\nexports.loginWithVmMSI = loginWithVmMSI;\n/**\n * Private method\n */\n\nfunction _withAppServiceMSI(options) {\n  if (!options) {\n    options = {};\n  }\n\n  return new Promise(function (resolve, reject) {\n    var creds = new msiAppServiceTokenCredentials_1.MSIAppServiceTokenCredentials(options);\n    creds.getToken().then(function (_tokenResponse) {\n      // We ignore the token response, it's put in the cache.\n      return resolve(creds);\n    }).catch(function (error) {\n      reject(error);\n    });\n  });\n}\n\nfunction loginWithAppServiceMSI(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return _withAppServiceMSI(options);\n  } else {\n    msRest.promiseToCallback(_withAppServiceMSI(options))(function (err, tokenRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, tokenRes);\n    });\n  }\n}\n\nexports.loginWithAppServiceMSI = loginWithAppServiceMSI;\n/**\n * Executes the azure cli command and returns the result. It will be `undefined` if the command did\n * not return anything or a `JSON object` if the command did return something.\n * @param cmd The az cli command to execute.\n */\n\nfunction execAz(cmd) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            return _context6.abrupt(\"return\", new Promise(function (resolve, reject) {\n              child_process_1.exec(\"az \".concat(cmd, \" --out json\"), {\n                encoding: \"utf8\"\n              }, function (error, stdout) {\n                if (error) {\n                  return reject(error);\n                }\n\n                if (stdout) {\n                  try {\n                    return resolve(JSON.parse(stdout));\n                  } catch (err) {\n                    var msg = \"An error occured while parsing the output \\\"\".concat(stdout, \"\\\", of \") + \"the cmd \\\"\".concat(cmd, \"\\\": \").concat(err.stack, \".\");\n                    return reject(new Error(msg));\n                  }\n                }\n\n                return resolve();\n              });\n            }));\n\n          case 1:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n}\n\nexports.execAz = execAz;","map":null,"metadata":{},"sourceType":"script"}