{"ast":null,"code":"/*\r\n * @copyright\r\n * Copyright Â© Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\n'use strict';\n\nvar constants = require('./constants');\n\nvar CacheDriver = require('./cache-driver');\n\nvar Logger = require('./log').Logger;\n\nvar Mex = require('./mex');\n\nvar OAuth2Client = require('./oauth2client');\n\nvar SelfSignedJwt = require('./self-signed-jwt');\n\nvar UserRealm = require('./user-realm');\n\nvar WSTrustRequest = require('./wstrust-request');\n\nvar OAuth2Parameters = constants.OAuth2.Parameters;\nvar TokenResponseFields = constants.TokenResponseFields;\nvar OAuth2GrantType = constants.OAuth2.GrantType;\nvar OAuth2Scope = constants.OAuth2.Scope;\nvar Saml = constants.Saml;\nvar AccountType = constants.UserRealm.AccountType;\nvar WSTrustVersion = constants.WSTrustVersion;\nvar DeviceCodeResponseParameters = constants.UserCodeResponseFields;\n/**\r\n * Constructs a new TokenRequest object.\r\n * @constructor\r\n * @private\r\n * @param {object} callContext Contains any context information that applies to the request.\r\n * @param {AuthenticationContext} authenticationContext\r\n * @param {string} resource\r\n * @param {string} clientId\r\n * @param {string} redirectUri\r\n */\n\nfunction TokenRequest(callContext, authenticationContext, clientId, resource, redirectUri) {\n  this._log = new Logger('TokenRequest', callContext._logContext);\n  this._callContext = callContext;\n  this._authenticationContext = authenticationContext;\n  this._resource = resource;\n  this._clientId = clientId;\n  this._redirectUri = redirectUri; // This should be set at the beginning of getToken\n  // functions that have a userId.\n\n  this._userId = null;\n  this._userRealm = null;\n  this._pollingClient = {};\n}\n\nTokenRequest.prototype._createUserRealmRequest = function (username) {\n  return new UserRealm(this._callContext, username, this._authenticationContext.authority);\n};\n\nTokenRequest.prototype._createMex = function (mexEndpoint) {\n  return new Mex(this._callContext, mexEndpoint);\n};\n\nTokenRequest.prototype._createWSTrustRequest = function (wstrustEndpoint, appliesTo, wstrustEndpointVersion) {\n  return new WSTrustRequest(this._callContext, wstrustEndpoint, appliesTo, wstrustEndpointVersion);\n};\n\nTokenRequest.prototype._createOAuth2Client = function () {\n  return new OAuth2Client(this._callContext, this._authenticationContext._authority);\n};\n\nTokenRequest.prototype._createSelfSignedJwt = function () {\n  return new SelfSignedJwt(this._callContext, this._authenticationContext._authority, this._clientId);\n};\n\nTokenRequest.prototype._oauthGetToken = function (oauthParameters, callback) {\n  var client = this._createOAuth2Client();\n\n  client.getToken(oauthParameters, callback);\n};\n\nTokenRequest.prototype._oauthGetTokenByPolling = function (oauthParameters, refresh_interval, expires_in, callback) {\n  var client = this._createOAuth2Client();\n\n  client.getTokenWithPolling(oauthParameters, refresh_interval, expires_in, callback);\n  this._pollingClient = client;\n};\n\nTokenRequest.prototype._createCacheDriver = function () {\n  return new CacheDriver(this._callContext, this._authenticationContext.authority, this._resource, this._clientId, this._authenticationContext.cache, this._getTokenWithTokenResponse.bind(this));\n};\n/**\r\n * Used by the cache driver to refresh tokens.\r\n * @param  {TokenResponse}   entry    A token response to refresh.\r\n * @param  {string}   resource The resource for which to get the token.\r\n * @param  {AcquireTokenCallback} callback\r\n */\n\n\nTokenRequest.prototype._getTokenWithTokenResponse = function (entry, resource, callback) {\n  this._log.verbose('Called to refresh a token from the cache.');\n\n  var refreshToken = entry[TokenResponseFields.REFRESH_TOKEN];\n\n  this._getTokenWithRefreshToken(refreshToken, resource, null, callback);\n};\n\nTokenRequest.prototype._createCacheQuery = function () {\n  var query = {\n    clientId: this._clientId\n  };\n\n  if (this._userId) {\n    query.userId = this._userId;\n  } else {\n    this._log.verbose('No userId passed for cache query.');\n  }\n\n  return query;\n};\n\nTokenRequest.prototype._getTokenWithCacheWrapper = function (callback, getTokenFunc) {\n  var self = this;\n  this._cacheDriver = this._createCacheDriver();\n\n  var cacheQuery = this._createCacheQuery();\n\n  this._cacheDriver.find(cacheQuery, function (err, token) {\n    if (err) {\n      self._log.warn('Attempt to look for token in cahce resulted in Error');\n\n      self._log.warn('Attempt to look for token in cache resulted in Error: ' + err.stack, true);\n    }\n\n    if (!token) {\n      self._log.verbose('No appropriate cached token found.');\n\n      getTokenFunc.call(self, function (err, tokenResponse) {\n        if (err) {\n          self._log.verbose('getTokenFunc returned with err');\n\n          callback(err, tokenResponse);\n          return;\n        }\n\n        self._log.verbose('Successfully retrieved token from authority');\n\n        self._cacheDriver.add(tokenResponse, function () {\n          callback(null, tokenResponse);\n        });\n      });\n    } else {\n      self._log.info('Returning cached token.');\n\n      callback(err, token);\n    }\n  });\n};\n/**\r\n * Store token into cache.\r\n * @param {object} tokenResponse Token response to be added into the cache.\r\n */\n\n\nTokenRequest.prototype._addTokenIntoCache = function (tokenResponse, callback) {\n  this._cacheDriver = this._createCacheDriver();\n\n  this._log.verbose('Storing retrieved token into cache');\n\n  this._cacheDriver.add(tokenResponse, function (err) {\n    callback(err, tokenResponse);\n  });\n};\n/**\r\n * Adds an OAuth parameter to the paramters object if the parameter is\r\n * not null or undefined.\r\n * @private\r\n * @param {object} parameters  OAuth parameters object.\r\n * @param {string} key         A member of the OAuth2Parameters constants.\r\n * @param {object} value\r\n */\n\n\nfunction _addParameterIfAvailable(parameters, key, value) {\n  if (value) {\n    parameters[key] = value;\n  }\n}\n/**\r\n * Creates a set of basic, common, OAuthParameters based on values that the TokenRequest\r\n * was created with.\r\n * @private\r\n * @param  {string} grantType  A member of the OAuth2GrantType constants.\r\n * @return {object}\r\n */\n\n\nTokenRequest.prototype._createOAuthParameters = function (grantType) {\n  var oauthParameters = {};\n  oauthParameters[OAuth2Parameters.GRANT_TYPE] = grantType;\n\n  if (OAuth2GrantType.AUTHORIZATION_CODE !== grantType && OAuth2GrantType.CLIENT_CREDENTIALS !== grantType && OAuth2GrantType.DEVICE_CODE != grantType) {\n    oauthParameters[OAuth2Parameters.SCOPE] = OAuth2Scope.OPENID;\n  }\n\n  _addParameterIfAvailable(oauthParameters, OAuth2Parameters.CLIENT_ID, this._clientId);\n\n  _addParameterIfAvailable(oauthParameters, OAuth2Parameters.RESOURCE, this._resource);\n\n  _addParameterIfAvailable(oauthParameters, OAuth2Parameters.REDIRECT_URI, this._redirectUri);\n\n  return oauthParameters;\n};\n/**\r\n * Get's a token from AAD using a username and password\r\n * @private\r\n * @param  {string}   username\r\n * @param  {string}   password\r\n * @param  {AcquireTokenCallback} callback\r\n */\n\n\nTokenRequest.prototype._getTokenUsernamePasswordManaged = function (username, password, callback) {\n  this._log.verbose('Acquiring token with username password for managed user');\n\n  var oauthParameters = this._createOAuthParameters(OAuth2GrantType.PASSWORD);\n\n  oauthParameters[OAuth2Parameters.PASSWORD] = password;\n  oauthParameters[OAuth2Parameters.USERNAME] = username;\n\n  this._oauthGetToken(oauthParameters, callback);\n};\n/**\r\n * Determines the OAuth SAML grant type to use based on the passed in TokenType\r\n * that was returned from a RSTR.\r\n * @param  {string} wstrustResponse RSTR token type.\r\n * @return {string}                 An OAuth grant type.\r\n */\n\n\nTokenRequest.prototype._getSamlGrantType = function (wstrustResponse) {\n  var tokenType = wstrustResponse.tokenType;\n\n  switch (tokenType) {\n    case Saml.TokenTypeV1:\n      return OAuth2GrantType.SAML1;\n\n    case Saml.TokenTypeV2:\n      return OAuth2GrantType.SAML2;\n\n    default:\n      throw this._log.createError('RSTR returned unknown token type: ' + tokenType);\n  }\n};\n/**\r\n * Performs an OAuth SAML Assertion grant type exchange.  Uses a SAML token as the credential for getting\r\n * an OAuth access token.\r\n * @param  {WSTrustResponse}   wstrustResponse A response from a WSTrustRequest\r\n * @param  {AcquireTokenCallback} callback        callback\r\n */\n\n\nTokenRequest.prototype._performWSTrustAssertionOAuthExchange = function (wstrustResponse, callback) {\n  this._log.verbose('Performing OAuth assertion grant type exchange.');\n\n  var oauthParameters;\n\n  try {\n    var grantType = this._getSamlGrantType(wstrustResponse);\n\n    var assertion = new Buffer(wstrustResponse.token).toString('base64');\n    oauthParameters = this._createOAuthParameters(grantType);\n    oauthParameters[OAuth2Parameters.ASSERTION] = assertion;\n  } catch (err) {\n    callback(err);\n    return;\n  }\n\n  this._oauthGetToken(oauthParameters, callback);\n};\n/**\r\n * Exchange a username and password for a SAML token from an ADFS instance via WSTrust.\r\n * @param  {string}   wstrustEndpoint An url of an ADFS WSTrust endpoint.\r\n * @param  {string}   wstrustEndpointVersion The version of the wstrust endpoint.\r\n * @param  {string}   username        username\r\n * @param  {string}   password        password\r\n * @param  {AcquireTokenCallback} callback        callback\r\n */\n\n\nTokenRequest.prototype._performWSTrustExchange = function (wstrustEndpoint, wstrustEndpointVersion, username, password, callback) {\n  var self = this;\n\n  var wstrust = this._createWSTrustRequest(wstrustEndpoint, 'urn:federation:MicrosoftOnline', wstrustEndpointVersion);\n\n  wstrust.acquireToken(username, password, function (rstErr, response) {\n    if (rstErr) {\n      callback(rstErr);\n      return;\n    }\n\n    if (!response.token) {\n      var rstrErr = self._log.createError('Unsucessful RSTR.\\n\\terror code: ' + response.errorCode + '\\n\\tfaultMessage: ' + response.faultMessage, true);\n\n      callback(rstrErr);\n      return;\n    }\n\n    callback(null, response);\n  });\n};\n/**\r\n * Given a username and password this method invokes a WSTrust and OAuth exchange to get an access token.\r\n * @param  {string}   wstrustEndpoint An url of an ADFS WSTrust endpoint.\r\n * @param  {string}   username        username\r\n * @param  {string}   password        password\r\n * @param  {AcquireTokenCallback} callback        callback\r\n */\n\n\nTokenRequest.prototype._performUsernamePasswordForAccessTokenExchange = function (wstrustEndpoint, wstrustEndpointVersion, username, password, callback) {\n  var self = this;\n\n  this._performWSTrustExchange(wstrustEndpoint, wstrustEndpointVersion, username, password, function (err, wstrustResponse) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    self._performWSTrustAssertionOAuthExchange(wstrustResponse, callback);\n  });\n};\n/**\r\n * Returns an Error object indicating that AAD did not return a WSTrust endpoint.\r\n * @return {Error}\r\n */\n\n\nTokenRequest.prototype._createADWSTrustEndpointError = function () {\n  return this._log.createError('AAD did not return a WSTrust endpoint.  Unable to proceed.');\n};\n/**\r\n * Gets an OAuth access token using a username and password via a federated ADFS instance.\r\n * @param  {string}   username        username\r\n * @param  {string}   password        password\r\n * @param  {AcquireTokenCallback} callback        callback\r\n */\n\n\nTokenRequest.prototype._getTokenUsernamePasswordFederated = function (username, password, callback) {\n  this._log.verbose('Acquiring token with username password for federated user');\n\n  var self = this;\n\n  if (!this._userRealm.federationMetadataUrl) {\n    this._log.warn('Unable to retrieve federationMetadataUrl from AAD.  Attempting fallback to AAD supplied endpoint.');\n\n    if (!this._userRealm.federationActiveAuthUrl) {\n      callback(this._createADWSTrustEndpointError());\n      return;\n    }\n\n    var wstrustVersion = this._parseWStrustVersionFromFederationActiveAuthUrl(this._userRealm.federationActiveAuthUrl);\n\n    this._log.verbose('Wstrust endpoint version is: ' + wstrustVersion);\n\n    this._performUsernamePasswordForAccessTokenExchange(this._userRealm.federationActiveAuthUrl, wstrustVersion, username, password, callback);\n\n    return;\n  } else {\n    var mexEndpoint = this._userRealm.federationMetadataUrl;\n\n    this._log.verbose('Attempting mex');\n\n    this._log.verbose('Attempting mex at: ' + mexEndpoint, true);\n\n    var mex = this._createMex(mexEndpoint);\n\n    mex.discover(function (mexErr) {\n      var wstrustEndpoint;\n      wstrustVersion = WSTrustVersion.UNDEFINED;\n\n      if (mexErr) {\n        self._log.warn('MEX exchange failed.  Attempting fallback to AAD supplied endpoint.');\n\n        wstrustEndpoint = self._userRealm.federationActiveAuthUrl;\n        wstrustVersion = self._parseWStrustVersionFromFederationActiveAuthUrl(self._userRealm.federationActiveAuthUrl);\n\n        if (!wstrustEndpoint) {\n          callback(self._createADWSTrustEndpointError());\n          return;\n        }\n      } else {\n        wstrustEndpoint = mex.usernamePasswordPolicy.url;\n        wstrustVersion = mex.usernamePasswordPolicy.version;\n      }\n\n      self._performUsernamePasswordForAccessTokenExchange(wstrustEndpoint, wstrustVersion, username, password, callback);\n\n      return;\n    });\n  }\n};\n/**\r\n * Gets wstrust endpoint version from the federation active auth url.\r\n * @private\r\n * @param  {string}   federationActiveAuthUrl  federationActiveAuthUrl\r\n * @return {object}   The wstrust endpoint version.\r\n */\n\n\nTokenRequest.prototype._parseWStrustVersionFromFederationActiveAuthUrl = function (federationActiveAuthUrl) {\n  var wstrust2005Regex = /[/trust]?[2005][/usernamemixed]?/;\n  var wstrust13Regex = /[/trust]?[13][/usernamemixed]?/;\n\n  if (wstrust2005Regex.exec(federationActiveAuthUrl)) {\n    return WSTrustVersion.WSTRUST2005;\n  } else if (wstrust13Regex.exec(federationActiveAuthUrl)) {\n    return WSTrustVersion.WSTRUST13;\n  }\n\n  return WSTrustVersion.UNDEFINED;\n};\n/**\r\n * Decides whether the username represents a managed or a federated user and then\r\n * obtains a token using the appropriate protocol flow.\r\n * @private\r\n * @param  {string}   username\r\n * @param  {string}   password\r\n * @param  {AcquireTokenCallback} callback\r\n */\n\n\nTokenRequest.prototype.getTokenWithUsernamePassword = function (username, password, callback) {\n  this._log.info('Acquiring token with username password');\n\n  this._userId = username;\n\n  this._getTokenWithCacheWrapper(callback, function (getTokenCompleteCallback) {\n    var self = this;\n\n    if (this._authenticationContext._authority._isAdfsAuthority) {\n      this._log.info('Skipping user realm discovery for ADFS authority');\n\n      self._getTokenUsernamePasswordManaged(username, password, getTokenCompleteCallback);\n\n      return;\n    }\n\n    this._userRealm = this._createUserRealmRequest(username);\n\n    this._userRealm.discover(function (err) {\n      if (err) {\n        getTokenCompleteCallback(err);\n        return;\n      }\n\n      switch (self._userRealm.accountType) {\n        case AccountType.Managed:\n          self._getTokenUsernamePasswordManaged(username, password, getTokenCompleteCallback);\n\n          return;\n\n        case AccountType.Federated:\n          self._getTokenUsernamePasswordFederated(username, password, getTokenCompleteCallback);\n\n          return;\n\n        default:\n          getTokenCompleteCallback(self._log.createError('Server returned an unknown AccountType: ' + self._userRealm.AccountType));\n      }\n    });\n  });\n};\n/**\r\n * Obtains a token using client credentials\r\n * @private\r\n * @param  {string}   clientSecret\r\n * @param  {AcquireTokenCallback} callback\r\n */\n\n\nTokenRequest.prototype.getTokenWithClientCredentials = function (clientSecret, callback) {\n  this._log.info('Getting token with client credentials.');\n\n  this._getTokenWithCacheWrapper(callback, function (getTokenCompleteCallback) {\n    var oauthParameters = this._createOAuthParameters(OAuth2GrantType.CLIENT_CREDENTIALS);\n\n    oauthParameters[OAuth2Parameters.CLIENT_SECRET] = clientSecret;\n\n    this._oauthGetToken(oauthParameters, getTokenCompleteCallback);\n  });\n};\n/**\r\n * Obtains a token using an authorization code.\r\n * @private\r\n * @param  {string}   authorizationCode\r\n * @param  {string}   clientSecret\r\n * @param  {AcquireTokenCallback} callback\r\n */\n\n\nTokenRequest.prototype.getTokenWithAuthorizationCode = function (authorizationCode, clientSecret, callback) {\n  this._log.info('Getting token with auth code.');\n\n  var oauthParameters = this._createOAuthParameters(OAuth2GrantType.AUTHORIZATION_CODE);\n\n  oauthParameters[OAuth2Parameters.CODE] = authorizationCode;\n  oauthParameters[OAuth2Parameters.CLIENT_SECRET] = clientSecret;\n\n  this._oauthGetToken(oauthParameters, callback);\n};\n/**\r\n * Obtains a token using a refresh token.\r\n * @param  {string}   refreshToken\r\n * @param  {string}   resource\r\n * @param  {string}   [clientSecret]\r\n * @param  {AcquireTokenCallback} callback\r\n */\n\n\nTokenRequest.prototype._getTokenWithRefreshToken = function (refreshToken, resource, clientSecret, callback) {\n  this._log.info('Getting a new token from a refresh token.');\n\n  var oauthParameters = this._createOAuthParameters(OAuth2GrantType.REFRESH_TOKEN);\n\n  if (resource) {\n    oauthParameters[OAuth2Parameters.RESOURCE] = resource;\n  }\n\n  if (clientSecret) {\n    oauthParameters[OAuth2Parameters.CLIENT_SECRET] = clientSecret;\n  }\n\n  oauthParameters[OAuth2Parameters.REFRESH_TOKEN] = refreshToken;\n\n  this._oauthGetToken(oauthParameters, callback);\n};\n/**\r\n * Obtains a token using a refresh token.\r\n * @param  {string}   refreshToken\r\n * @param  {string}   [clientSecret]\r\n * @param  {AcquireTokenCallback} callback\r\n */\n\n\nTokenRequest.prototype.getTokenWithRefreshToken = function (refreshToken, clientSecret, callback) {\n  this._getTokenWithRefreshToken(refreshToken, null, clientSecret, callback);\n};\n/**\r\n * Obtains a token from the cache, refreshing it or using a MRRT if necessary.\r\n * @param {string}  [userId] The user associated with the cached token.\r\n * @param  {AcquireTokenCallback} callback\r\n */\n\n\nTokenRequest.prototype.getTokenFromCacheWithRefresh = function (userId, callback) {\n  var self = this;\n\n  this._log.info('Getting token from cache with refresh if necessary.');\n\n  this._userId = userId;\n\n  this._getTokenWithCacheWrapper(callback, function (getTokenCompleteCallback) {\n    // If this method was called then no cached entry was found.  Since\n    // this particular version of acquireToken can only retrieve tokens\n    // from the cache, return an error.\n    getTokenCompleteCallback(self._log.createError('Entry not found in cache.'));\n  });\n};\n/**\r\n * Creates a self signed jwt.\r\n * @param  {string} authorityUrl\r\n * @param  {string} certificate  A PEM encoded certificate private key.\r\n * @param  {string} thumbprint\r\n * @return {string}              A self signed JWT\r\n */\n\n\nTokenRequest.prototype._createJwt = function (authorityUrl, certificate, thumbprint) {\n  var jwt;\n\n  var ssj = this._createSelfSignedJwt();\n\n  jwt = ssj.create(certificate, thumbprint);\n\n  if (!jwt) {\n    throw this._log.createError('Failed to create JWT');\n  }\n\n  return jwt;\n};\n/**\r\n * Obtains a token via a certificate.  The certificate is used to generate a self signed\r\n * JWT token that is passed as a client_assertion.\r\n * @param  {string}                 certificate   A PEM encoded certificate private key.\r\n * @param  {string}                 thumbprint    A hex encoded thumbprint of the certificate.\r\n * @param  {AcquireTokenCallback}   callback\r\n */\n\n\nTokenRequest.prototype.getTokenWithCertificate = function (certificate, thumbprint, callback) {\n  this._log.info('Getting a token via certificate.');\n\n  var authorityUrl = this._authenticationContext._authority;\n  var jwt;\n\n  try {\n    jwt = this._createJwt(authorityUrl, certificate, thumbprint);\n  } catch (err) {\n    callback(err);\n    return;\n  }\n\n  var oauthParameters = this._createOAuthParameters(OAuth2GrantType.CLIENT_CREDENTIALS);\n\n  oauthParameters[OAuth2Parameters.CLIENT_ASSERTION_TYPE] = OAuth2GrantType.JWT_BEARER;\n  oauthParameters[OAuth2Parameters.CLIENT_ASSERTION] = jwt;\n\n  this._getTokenWithCacheWrapper(callback, function (getTokenCompleteCallback) {\n    this._oauthGetToken(oauthParameters, getTokenCompleteCallback);\n  });\n};\n\nTokenRequest.prototype.getTokenWithDeviceCode = function (userCodeInfo, callback) {\n  this._log.info('Getting a token via device code');\n\n  var self = this;\n\n  var oauthParameters = this._createOAuthParameters(OAuth2GrantType.DEVICE_CODE);\n\n  oauthParameters[OAuth2Parameters.CODE] = userCodeInfo[DeviceCodeResponseParameters.DEVICE_CODE];\n  var interval = userCodeInfo[DeviceCodeResponseParameters.INTERVAL];\n  var expires_in = userCodeInfo[DeviceCodeResponseParameters.EXPIRES_IN];\n\n  if (interval <= 0) {\n    callback(new Error('invalid refresh interval'));\n  }\n\n  this._oauthGetTokenByPolling(oauthParameters, interval, expires_in, function (err, tokenResponse) {\n    if (err) {\n      self._log.verbose('Token polling request returend with err.');\n\n      callback(err, tokenResponse);\n    } else {\n      self._addTokenIntoCache(tokenResponse, callback);\n    }\n  });\n};\n\nTokenRequest.prototype.cancelTokenRequestWithDeviceCode = function () {\n  this._pollingClient.cancelPollingRequest();\n};\n\nmodule.exports = TokenRequest;","map":null,"metadata":{},"sourceType":"script"}