{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nimport * as base64 from \"./util/base64\";\nimport * as utils from \"./util/utils\";\n\nvar Serializer =\n/** @class */\nfunction () {\n  function Serializer(modelMappers, isXML) {\n    if (modelMappers === void 0) {\n      modelMappers = {};\n    }\n\n    this.modelMappers = modelMappers;\n    this.isXML = isXML;\n  }\n\n  Serializer.prototype.validateConstraints = function (mapper, value, objectName) {\n    var failValidation = function failValidation(constraintName, constraintValue) {\n      throw new Error(\"\\\"\" + objectName + \"\\\" with value \\\"\" + value + \"\\\" should satisfy the constraint \\\"\" + constraintName + \"\\\": \" + constraintValue + \".\");\n    };\n\n    if (mapper.constraints && value != undefined) {\n      var _a = mapper.constraints,\n          ExclusiveMaximum = _a.ExclusiveMaximum,\n          ExclusiveMinimum = _a.ExclusiveMinimum,\n          InclusiveMaximum = _a.InclusiveMaximum,\n          InclusiveMinimum = _a.InclusiveMinimum,\n          MaxItems = _a.MaxItems,\n          MaxLength = _a.MaxLength,\n          MinItems = _a.MinItems,\n          MinLength = _a.MinLength,\n          MultipleOf = _a.MultipleOf,\n          Pattern = _a.Pattern,\n          UniqueItems = _a.UniqueItems;\n\n      if (ExclusiveMaximum != undefined && value >= ExclusiveMaximum) {\n        failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n      }\n\n      if (ExclusiveMinimum != undefined && value <= ExclusiveMinimum) {\n        failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n      }\n\n      if (InclusiveMaximum != undefined && value > InclusiveMaximum) {\n        failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n      }\n\n      if (InclusiveMinimum != undefined && value < InclusiveMinimum) {\n        failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n      }\n\n      if (MaxItems != undefined && value.length > MaxItems) {\n        failValidation(\"MaxItems\", MaxItems);\n      }\n\n      if (MaxLength != undefined && value.length > MaxLength) {\n        failValidation(\"MaxLength\", MaxLength);\n      }\n\n      if (MinItems != undefined && value.length < MinItems) {\n        failValidation(\"MinItems\", MinItems);\n      }\n\n      if (MinLength != undefined && value.length < MinLength) {\n        failValidation(\"MinLength\", MinLength);\n      }\n\n      if (MultipleOf != undefined && value % MultipleOf !== 0) {\n        failValidation(\"MultipleOf\", MultipleOf);\n      }\n\n      if (Pattern && value.match(Pattern) === null) {\n        failValidation(\"Pattern\", Pattern);\n      }\n\n      if (UniqueItems && value.some(function (item, i, ar) {\n        return ar.indexOf(item) !== i;\n      })) {\n        failValidation(\"UniqueItems\", UniqueItems);\n      }\n    }\n  };\n  /**\n   * Serialize the given object based on its metadata defined in the mapper\n   *\n   * @param {Mapper} mapper The mapper which defines the metadata of the serializable object\n   *\n   * @param {object|string|Array|number|boolean|Date|stream} object A valid Javascript object to be serialized\n   *\n   * @param {string} objectName Name of the serialized object\n   *\n   * @returns {object|string|Array|number|boolean|Date|stream} A valid serialized Javascript object\n   */\n\n\n  Serializer.prototype.serialize = function (mapper, object, objectName) {\n    var payload = {};\n    var mapperType = mapper.type.name;\n\n    if (!objectName) {\n      objectName = mapper.serializedName;\n    }\n\n    if (mapperType.match(/^Sequence$/ig) !== null) {\n      payload = [];\n    }\n\n    if (object == undefined && (mapper.defaultValue != undefined || mapper.isConstant)) {\n      object = mapper.defaultValue;\n    } // This table of allowed values should help explain\n    // the mapper.required and mapper.nullable properties.\n    // X means \"neither undefined or null are allowed\".\n    //           || required\n    //           || true      | false\n    //  nullable || ==========================\n    //      true || null      | undefined/null\n    //     false || X         | undefined\n    // undefined || X         | undefined/null\n\n\n    var required = mapper.required,\n        nullable = mapper.nullable;\n\n    if (required && nullable && object === undefined) {\n      throw new Error(objectName + \" cannot be undefined.\");\n    }\n\n    if (required && !nullable && object == undefined) {\n      throw new Error(objectName + \" cannot be null or undefined.\");\n    }\n\n    if (!required && nullable === false && object === null) {\n      throw new Error(objectName + \" cannot be null.\");\n    }\n\n    if (object == undefined) {\n      payload = object;\n    } else {\n      // Validate Constraints if any\n      this.validateConstraints(mapper, object, objectName);\n\n      if (mapperType.match(/^any$/ig) !== null) {\n        payload = object;\n      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/ig) !== null) {\n        payload = serializeBasicTypes(mapperType, objectName, object);\n      } else if (mapperType.match(/^Enum$/ig) !== null) {\n        var enumMapper = mapper;\n        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n      } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/ig) !== null) {\n        payload = serializeDateTypes(mapperType, object, objectName);\n      } else if (mapperType.match(/^ByteArray$/ig) !== null) {\n        payload = serializeByteArrayType(objectName, object);\n      } else if (mapperType.match(/^Base64Url$/ig) !== null) {\n        payload = serializeBase64UrlType(objectName, object);\n      } else if (mapperType.match(/^Sequence$/ig) !== null) {\n        payload = serializeSequenceType(this, mapper, object, objectName);\n      } else if (mapperType.match(/^Dictionary$/ig) !== null) {\n        payload = serializeDictionaryType(this, mapper, object, objectName);\n      } else if (mapperType.match(/^Composite$/ig) !== null) {\n        payload = serializeCompositeType(this, mapper, object, objectName);\n      }\n    }\n\n    return payload;\n  };\n  /**\n   * Deserialize the given object based on its metadata defined in the mapper\n   *\n   * @param {object} mapper The mapper which defines the metadata of the serializable object\n   *\n   * @param {object|string|Array|number|boolean|Date|stream} responseBody A valid Javascript entity to be deserialized\n   *\n   * @param {string} objectName Name of the deserialized object\n   *\n   * @returns {object|string|Array|number|boolean|Date|stream} A valid deserialized Javascript object\n   */\n\n\n  Serializer.prototype.deserialize = function (mapper, responseBody, objectName) {\n    if (responseBody == undefined) {\n      if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n        // between the list being empty versus being missing,\n        // so let's do the more user-friendly thing and return an empty list.\n        responseBody = [];\n      }\n\n      return responseBody;\n    }\n\n    var payload;\n    var mapperType = mapper.type.name;\n\n    if (!objectName) {\n      objectName = mapper.serializedName;\n    }\n\n    if (mapperType.match(/^Composite$/ig) !== null) {\n      payload = deserializeCompositeType(this, mapper, responseBody, objectName);\n    } else {\n      if (this.isXML) {\n        /**\n         * If the mapper specifies this as a non-composite type value but the responseBody contains\n         * both header (\"$\") and body (\"_\") properties, then just reduce the responseBody value to\n         * the body (\"_\") property.\n         */\n        if (responseBody[\"$\"] != undefined && responseBody[\"_\"] != undefined) {\n          responseBody = responseBody[\"_\"];\n        }\n      }\n\n      if (mapperType.match(/^Number$/ig) !== null) {\n        payload = parseFloat(responseBody);\n\n        if (isNaN(payload)) {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^Boolean$/ig) !== null) {\n        if (responseBody === \"true\") {\n          payload = true;\n        } else if (responseBody === \"false\") {\n          payload = false;\n        } else {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/ig) !== null) {\n        payload = responseBody;\n      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/ig) !== null) {\n        payload = new Date(responseBody);\n      } else if (mapperType.match(/^UnixTime$/ig) !== null) {\n        payload = unixTimeToDate(responseBody);\n      } else if (mapperType.match(/^ByteArray$/ig) !== null) {\n        payload = base64.decodeString(responseBody);\n      } else if (mapperType.match(/^Base64Url$/ig) !== null) {\n        payload = base64UrlToByteArray(responseBody);\n      } else if (mapperType.match(/^Sequence$/ig) !== null) {\n        payload = deserializeSequenceType(this, mapper, responseBody, objectName);\n      } else if (mapperType.match(/^Dictionary$/ig) !== null) {\n        payload = deserializeDictionaryType(this, mapper, responseBody, objectName);\n      }\n    }\n\n    if (mapper.isConstant) {\n      payload = mapper.defaultValue;\n    }\n\n    return payload;\n  };\n\n  return Serializer;\n}();\n\nexport { Serializer };\n\nfunction trimEnd(str, ch) {\n  var len = str.length;\n\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n\n  return str.substr(0, len);\n}\n\nfunction bufferToBase64Url(buffer) {\n  if (!buffer) {\n    return undefined;\n  }\n\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(\"Please provide an input of type Uint8Array for converting to Base64Url.\");\n  } // Uint8Array to Base64.\n\n\n  var str = base64.encodeByteArray(buffer); // Base64 to Base64Url.\n\n  return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n\nfunction base64UrlToByteArray(str) {\n  if (!str) {\n    return undefined;\n  }\n\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  } // Base64Url to Base64.\n\n\n  str = str.replace(/\\-/g, \"+\").replace(/\\_/g, \"/\"); // Base64 to Uint8Array.\n\n  return base64.decodeString(str);\n}\n\nfunction splitSerializeName(prop) {\n  var classes = [];\n  var partialclass = \"\";\n\n  if (prop) {\n    var subwords = prop.split(\".\");\n\n    for (var _i = 0, subwords_1 = subwords; _i < subwords_1.length; _i++) {\n      var item = subwords_1[_i];\n\n      if (item.charAt(item.length - 1) === \"\\\\\") {\n        partialclass += item.substr(0, item.length - 1) + \".\";\n      } else {\n        partialclass += item;\n        classes.push(partialclass);\n        partialclass = \"\";\n      }\n    }\n  }\n\n  return classes;\n}\n\nfunction dateToUnixTime(d) {\n  if (!d) {\n    return undefined;\n  }\n\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d);\n  }\n\n  return Math.floor(d.getTime() / 1000);\n}\n\nfunction unixTimeToDate(n) {\n  if (!n) {\n    return undefined;\n  }\n\n  return new Date(n * 1000);\n}\n\nfunction serializeBasicTypes(typeName, objectName, value) {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/ig) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(objectName + \" with value \" + value + \" must be of type number.\");\n      }\n    } else if (typeName.match(/^String$/ig) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(objectName + \" with value \\\"\" + value + \"\\\" must be of type string.\");\n      }\n    } else if (typeName.match(/^Uuid$/ig) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && utils.isValidUuid(value))) {\n        throw new Error(objectName + \" with value \\\"\" + value + \"\\\" must be of type string and a valid uuid.\");\n      }\n    } else if (typeName.match(/^Boolean$/ig) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(objectName + \" with value \" + value + \" must be of type boolean.\");\n      }\n    } else if (typeName.match(/^Stream$/ig) !== null) {\n      var objectType = typeof value;\n\n      if (objectType !== \"string\" && objectType !== \"function\" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !(typeof Blob === \"function\" && value instanceof Blob)) {\n        throw new Error(objectName + \" must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.\");\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction serializeEnumType(objectName, allowedValues, value) {\n  if (!allowedValues) {\n    throw new Error(\"Please provide a set of allowedValues to validate \" + objectName + \" as an Enum Type.\");\n  }\n\n  var isPresent = allowedValues.some(function (item) {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n\n    return item === value;\n  });\n\n  if (!isPresent) {\n    throw new Error(value + \" is not a valid value for \" + objectName + \". The valid values are: \" + JSON.stringify(allowedValues) + \".\");\n  }\n\n  return value;\n}\n\nfunction serializeByteArrayType(objectName, value) {\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(objectName + \" must be of type Uint8Array.\");\n    }\n\n    value = base64.encodeByteArray(value);\n  }\n\n  return value;\n}\n\nfunction serializeBase64UrlType(objectName, value) {\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(objectName + \" must be of type Uint8Array.\");\n    }\n\n    value = bufferToBase64Url(value);\n  }\n\n  return value;\n}\n\nfunction serializeDateTypes(typeName, value, objectName) {\n  if (value != undefined) {\n    if (typeName.match(/^Date$/ig) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(objectName + \" must be an instanceof Date or a string in ISO8601 format.\");\n      }\n\n      value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/ig) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(objectName + \" must be an instanceof Date or a string in ISO8601 format.\");\n      }\n\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/ig) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(objectName + \" must be an instanceof Date or a string in RFC-1123 format.\");\n      }\n\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/ig) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(objectName + \" must be an instanceof Date or a string in RFC-1123/ISO8601 format \" + \"for it to be serialized in UnixTime/Epoch format.\");\n      }\n\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/ig) !== null) {\n      if (!utils.isDuration(value)) {\n        throw new Error(objectName + \" must be a string in ISO 8601 format. Instead was \\\"\" + value + \"\\\".\");\n      }\n\n      value = value;\n    }\n  }\n\n  return value;\n}\n\nfunction serializeSequenceType(serializer, mapper, object, objectName) {\n  if (!Array.isArray(object)) {\n    throw new Error(objectName + \" must be of type Array.\");\n  }\n\n  var elementType = mapper.type.element;\n\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(\"element\\\" metadata for an Array must be defined in the \" + (\"mapper and it must of type \\\"object\\\" in \" + objectName + \".\"));\n  }\n\n  var tempArray = [];\n\n  for (var i = 0; i < object.length; i++) {\n    tempArray[i] = serializer.serialize(elementType, object[i], objectName);\n  }\n\n  return tempArray;\n}\n\nfunction serializeDictionaryType(serializer, mapper, object, objectName) {\n  if (typeof object !== \"object\") {\n    throw new Error(objectName + \" must be of type object.\");\n  }\n\n  var valueType = mapper.type.value;\n\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(\"\\\"value\\\" metadata for a Dictionary must be defined in the \" + (\"mapper and it must of type \\\"object\\\" in \" + objectName + \".\"));\n  }\n\n  var tempDictionary = {};\n\n  for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {\n    var key = _a[_i];\n    tempDictionary[key] = serializer.serialize(valueType, object[key], objectName + \".\" + key);\n  }\n\n  return tempDictionary;\n}\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer the serializer containing the entire set of mappers\n * @param mapper the composite mapper to resolve\n */\n\n\nfunction resolveModelProperties(serializer, mapper, objectName) {\n  var modelProps = mapper.type.modelProperties;\n\n  if (!modelProps) {\n    var className = mapper.type.className;\n\n    if (!className) {\n      throw new Error(\"Class name for model \\\"\" + objectName + \"\\\" is not provided in the mapper \\\"\" + JSON.stringify(mapper, undefined, 2) + \"\\\".\");\n    }\n\n    var modelMapper = serializer.modelMappers[className];\n\n    if (!modelMapper) {\n      throw new Error(\"mapper() cannot be null or undefined for model \\\"\" + className + \"\\\".\");\n    }\n\n    modelProps = modelMapper.type.modelProperties;\n\n    if (!modelProps) {\n      throw new Error(\"modelProperties cannot be null or undefined in the \" + (\"mapper \\\"\" + JSON.stringify(modelMapper) + \"\\\" of type \\\"\" + className + \"\\\" for object \\\"\" + objectName + \"\\\".\"));\n    }\n  }\n\n  return modelProps;\n}\n\nfunction serializeCompositeType(serializer, mapper, object, objectName) {\n  var _a;\n\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n\n  if (object != undefined) {\n    var payload = {};\n    var modelProps = resolveModelProperties(serializer, mapper, objectName);\n\n    for (var _i = 0, _b = Object.keys(modelProps); _i < _b.length; _i++) {\n      var key = _b[_i];\n      var propertyMapper = modelProps[key];\n\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n\n      var propName = void 0;\n      var parentObject = payload;\n\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        var paths = splitSerializeName(propertyMapper.serializedName);\n        propName = paths.pop();\n\n        for (var _c = 0, paths_1 = paths; _c < paths_1.length; _c++) {\n          var pathName = paths_1[_c];\n          var childObject = parentObject[pathName];\n\n          if (childObject == undefined && object[key] != undefined) {\n            parentObject[pathName] = {};\n          }\n\n          parentObject = parentObject[pathName];\n        }\n      }\n\n      if (parentObject != undefined) {\n        var propertyObjectName = propertyMapper.serializedName !== \"\" ? objectName + \".\" + propertyMapper.serializedName : objectName;\n        var toSerialize = object[key];\n        var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n\n        if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && toSerialize == undefined) {\n          toSerialize = mapper.serializedName;\n        }\n\n        var serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName);\n\n        if (serializedValue !== undefined && propName != undefined) {\n          if (propertyMapper.xmlIsAttribute) {\n            // $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject.$ = parentObject.$ || {};\n            parentObject.$[propName] = serializedValue;\n          } else if (propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = (_a = {}, _a[propertyMapper.xmlElementName] = serializedValue, _a);\n          } else {\n            parentObject[propName] = serializedValue;\n          }\n        }\n      }\n    }\n\n    var additionalPropertiesMapper = mapper.type.additionalProperties;\n\n    if (additionalPropertiesMapper) {\n      var propNames = Object.keys(modelProps);\n\n      var _loop_1 = function _loop_1(clientPropName) {\n        var isAdditionalProperty = propNames.every(function (pn) {\n          return pn !== clientPropName;\n        });\n\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '[\"' + clientPropName + '\"]');\n        }\n      };\n\n      for (var clientPropName in object) {\n        _loop_1(clientPropName);\n      }\n    }\n\n    return payload;\n  }\n\n  return object;\n}\n\nfunction isSpecialXmlProperty(propertyName) {\n  return [\"$\", \"_\"].includes(propertyName);\n}\n\nfunction deserializeCompositeType(serializer, mapper, responseBody, objectName) {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n\n  var modelProps = resolveModelProperties(serializer, mapper, objectName);\n  var instance = {};\n  var handledPropertyNames = [];\n\n  for (var _i = 0, _a = Object.keys(modelProps); _i < _a.length; _i++) {\n    var key = _a[_i];\n    var propertyMapper = modelProps[key];\n    var paths = splitSerializeName(modelProps[key].serializedName);\n    handledPropertyNames.push(paths[0]);\n    var serializedName = propertyMapper.serializedName,\n        xmlName = propertyMapper.xmlName,\n        xmlElementName = propertyMapper.xmlElementName;\n    var propertyObjectName = objectName;\n\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n\n    var headerCollectionPrefix = propertyMapper.headerCollectionPrefix;\n\n    if (headerCollectionPrefix) {\n      var dictionary = {};\n\n      for (var _b = 0, _c = Object.keys(responseBody); _b < _c.length; _b++) {\n        var headerKey = _c[_b];\n\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName);\n        }\n\n        handledPropertyNames.push(headerKey);\n      }\n\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody.$) {\n        instance[key] = serializer.deserialize(propertyMapper, responseBody.$[xmlName], propertyObjectName);\n      } else {\n        var propertyName = xmlElementName || xmlName || serializedName;\n        var unwrappedProperty = responseBody[propertyName];\n\n        if (propertyMapper.xmlIsWrapped) {\n          unwrappedProperty = responseBody[xmlName];\n          unwrappedProperty = unwrappedProperty && unwrappedProperty[xmlElementName];\n          var isEmptyWrappedList = unwrappedProperty === undefined;\n\n          if (isEmptyWrappedList) {\n            unwrappedProperty = [];\n          }\n        }\n\n        instance[key] = serializer.deserialize(propertyMapper, unwrappedProperty, propertyObjectName);\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      var propertyInstance = void 0;\n      var res = responseBody; // traversing the object step by step.\n\n      for (var _d = 0, paths_2 = paths; _d < paths_2.length; _d++) {\n        var item = paths_2[_d];\n        if (!res) break;\n        res = res[item];\n      }\n\n      propertyInstance = res;\n      var polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n\n      if (polymorphicDiscriminator && propertyMapper.serializedName === polymorphicDiscriminator.serializedName && propertyInstance == undefined) {\n        propertyInstance = mapper.serializedName;\n      }\n\n      var serializedValue = void 0; // paging\n\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        instance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName);\n      } else if (propertyInstance !== undefined) {\n        serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName);\n        instance[key] = serializedValue;\n      }\n    }\n  }\n\n  var additionalPropertiesMapper = mapper.type.additionalProperties;\n\n  if (additionalPropertiesMapper) {\n    var isAdditionalProperty = function isAdditionalProperty(responsePropName) {\n      for (var clientPropName in modelProps) {\n        var paths = splitSerializeName(modelProps[clientPropName].serializedName);\n\n        if (paths[0] === responsePropName) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    for (var responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '[\"' + responsePropName + '\"]');\n      }\n    }\n  } else if (responseBody) {\n    for (var _e = 0, _f = Object.keys(responseBody); _e < _f.length; _e++) {\n      var key = _f[_e];\n\n      if (instance[key] === undefined && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key)) {\n        instance[key] = responseBody[key];\n      }\n    }\n  }\n\n  return instance;\n}\n\nfunction deserializeDictionaryType(serializer, mapper, responseBody, objectName) {\n  /*jshint validthis: true */\n  var value = mapper.type.value;\n\n  if (!value || typeof value !== \"object\") {\n    throw new Error(\"\\\"value\\\" metadata for a Dictionary must be defined in the \" + (\"mapper and it must of type \\\"object\\\" in \" + objectName));\n  }\n\n  if (responseBody) {\n    var tempDictionary = {};\n\n    for (var _i = 0, _a = Object.keys(responseBody); _i < _a.length; _i++) {\n      var key = _a[_i];\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName);\n    }\n\n    return tempDictionary;\n  }\n\n  return responseBody;\n}\n\nfunction deserializeSequenceType(serializer, mapper, responseBody, objectName) {\n  /*jshint validthis: true */\n  var element = mapper.type.element;\n\n  if (!element || typeof element !== \"object\") {\n    throw new Error(\"element\\\" metadata for an Array must be defined in the \" + (\"mapper and it must of type \\\"object\\\" in \" + objectName));\n  }\n\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    }\n\n    var tempArray = [];\n\n    for (var i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(element, responseBody[i], objectName + \"[\" + i + \"]\");\n    }\n\n    return tempArray;\n  }\n\n  return responseBody;\n}\n\nfunction getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {\n  var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n\n  if (polymorphicDiscriminator) {\n    var discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n\n    if (discriminatorName != undefined) {\n      var discriminatorValue = object[discriminatorName];\n\n      if (discriminatorValue != undefined) {\n        var typeName = mapper.type.uberParent || mapper.type.className;\n        var indexDiscriminator = discriminatorValue === typeName ? discriminatorValue : typeName + \".\" + discriminatorValue;\n        var polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];\n\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n\n  return mapper;\n}\n\nfunction getPolymorphicDiscriminatorRecursively(serializer, mapper) {\n  return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);\n}\n\nfunction getPolymorphicDiscriminatorSafely(serializer, typeName) {\n  return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;\n} // TODO: why is this here?\n\n\nexport function serializeObject(toSerialize) {\n  if (toSerialize == undefined) return undefined;\n\n  if (toSerialize instanceof Uint8Array) {\n    toSerialize = base64.encodeByteArray(toSerialize);\n    return toSerialize;\n  } else if (toSerialize instanceof Date) {\n    return toSerialize.toISOString();\n  } else if (Array.isArray(toSerialize)) {\n    var array = [];\n\n    for (var i = 0; i < toSerialize.length; i++) {\n      array.push(serializeObject(toSerialize[i]));\n    }\n\n    return array;\n  } else if (typeof toSerialize === \"object\") {\n    var dictionary = {};\n\n    for (var property in toSerialize) {\n      dictionary[property] = serializeObject(toSerialize[property]);\n    }\n\n    return dictionary;\n  }\n\n  return toSerialize;\n}\n/**\n * Utility function to create a K:V from a list of strings\n */\n\nfunction strEnum(o) {\n  var result = {};\n\n  for (var _i = 0, o_1 = o; _i < o_1.length; _i++) {\n    var key = o_1[_i];\n    result[key] = key;\n  }\n\n  return result;\n}\n\nexport var MapperType = strEnum([\"Base64Url\", \"Boolean\", \"ByteArray\", \"Composite\", \"Date\", \"DateTime\", \"DateTimeRfc1123\", \"Dictionary\", \"Enum\", \"Number\", \"Object\", \"Sequence\", \"String\", \"Stream\", \"TimeSpan\", \"UnixTime\"]);","map":null,"metadata":{},"sourceType":"module"}