{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safer-buffer').Buffer; // == UTF32-LE/BE codec. ==========================================================\n\n\nexports._utf32 = Utf32Codec;\n\nfunction Utf32Codec(codecOptions, iconv) {\n  this.iconv = iconv;\n  this.bomAware = true;\n  this.isLE = codecOptions.isLE;\n}\n\nexports.utf32le = {\n  type: '_utf32',\n  isLE: true\n};\nexports.utf32be = {\n  type: '_utf32',\n  isLE: false\n}; // Aliases\n\nexports.ucs4le = 'utf32le';\nexports.ucs4be = 'utf32be';\nUtf32Codec.prototype.encoder = Utf32Encoder;\nUtf32Codec.prototype.decoder = Utf32Decoder; // -- Encoding\n\nfunction Utf32Encoder(options, codec) {\n  this.isLE = codec.isLE;\n  this.highSurrogate = 0;\n}\n\nUtf32Encoder.prototype.write = function (str) {\n  var src = Buffer.from(str, 'ucs2');\n  var dst = Buffer.alloc(src.length * 2);\n  var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;\n  var offset = 0;\n\n  for (var i = 0; i < src.length; i += 2) {\n    var code = src.readUInt16LE(i);\n    var isHighSurrogate = 0xD800 <= code && code < 0xDC00;\n    var isLowSurrogate = 0xDC00 <= code && code < 0xE000;\n\n    if (this.highSurrogate) {\n      if (isHighSurrogate || !isLowSurrogate) {\n        // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low\n        // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character\n        // (technically wrong, but expected by some applications, like Windows file names).\n        write32.call(dst, this.highSurrogate, offset);\n        offset += 4;\n      } else {\n        // Create 32-bit value from high and low surrogates;\n        var codepoint = (this.highSurrogate - 0xD800 << 10 | code - 0xDC00) + 0x10000;\n        write32.call(dst, codepoint, offset);\n        offset += 4;\n        this.highSurrogate = 0;\n        continue;\n      }\n    }\n\n    if (isHighSurrogate) this.highSurrogate = code;else {\n      // Even if the current character is a low surrogate, with no previous high surrogate, we'll\n      // encode it as a semi-invalid stand-alone character for the same reasons expressed above for\n      // unpaired high surrogates.\n      write32.call(dst, code, offset);\n      offset += 4;\n      this.highSurrogate = 0;\n    }\n  }\n\n  if (offset < dst.length) dst = dst.slice(0, offset);\n  return dst;\n};\n\nUtf32Encoder.prototype.end = function () {\n  // Treat any leftover high surrogate as a semi-valid independent character.\n  if (!this.highSurrogate) return;\n  var buf = Buffer.alloc(4);\n  if (this.isLE) buf.writeUInt32LE(this.highSurrogate, 0);else buf.writeUInt32BE(this.highSurrogate, 0);\n  this.highSurrogate = 0;\n  return buf;\n}; // -- Decoding\n\n\nfunction Utf32Decoder(options, codec) {\n  this.isLE = codec.isLE;\n  this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);\n  this.overflow = null;\n}\n\nUtf32Decoder.prototype.write = function (src) {\n  if (src.length === 0) return '';\n  if (this.overflow) src = Buffer.concat([this.overflow, src]);\n  var goodLength = src.length - src.length % 4;\n\n  if (src.length !== goodLength) {\n    this.overflow = src.slice(goodLength);\n    src = src.slice(0, goodLength);\n  } else this.overflow = null;\n\n  var dst = Buffer.alloc(goodLength);\n  var offset = 0;\n\n  for (var i = 0; i < goodLength; i += 4) {\n    var codepoint = this.isLE ? src.readUInt32LE(i) : src.readUInt32BE(i);\n\n    if (codepoint < 0x10000) {\n      // Simple 16-bit character\n      dst.writeUInt16LE(codepoint, offset);\n      offset += 2;\n    } else {\n      if (codepoint > 0x10FFFF) {\n        // Not a valid Unicode codepoint\n        dst.writeUInt16LE(this.badChar, offset);\n        offset += 2;\n      } else {\n        // Create high and low surrogates.\n        codepoint -= 0x10000;\n        var high = 0xD800 | codepoint >> 10;\n        var low = 0xDC00 + (codepoint & 0x3FF);\n        dst.writeUInt16LE(high, offset);\n        offset += 2;\n        dst.writeUInt16LE(low, offset);\n        offset += 2;\n      }\n    }\n  }\n\n  return dst.slice(0, offset).toString('ucs2');\n};\n\nUtf32Decoder.prototype.end = function () {\n  this.overflow = null;\n}; // == UTF-32 Auto codec =============================================================\n// Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.\n// Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32\n// Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});\n// Encoder prepends BOM (which can be overridden with (addBOM: false}).\n\n\nexports.utf32 = Utf32AutoCodec;\nexports.ucs4 = Utf32AutoCodec;\n\nfunction Utf32AutoCodec(options, iconv) {\n  this.iconv = iconv;\n}\n\nUtf32AutoCodec.prototype.encoder = Utf32AutoEncoder;\nUtf32AutoCodec.prototype.decoder = Utf32AutoDecoder; // -- Encoding\n\nfunction Utf32AutoEncoder(options, codec) {\n  options = options || {};\n  if (options.addBOM === undefined) options.addBOM = true;\n  this.encoder = codec.iconv.getEncoder(options.defaultEncoding || 'utf-32le', options);\n}\n\nUtf32AutoEncoder.prototype.write = function (str) {\n  return this.encoder.write(str);\n};\n\nUtf32AutoEncoder.prototype.end = function () {\n  return this.encoder.end();\n}; // -- Decoding\n\n\nfunction Utf32AutoDecoder(options, codec) {\n  this.decoder = null;\n  this.initialBytes = [];\n  this.initialBytesLen = 0;\n  this.options = options || {};\n  this.iconv = codec.iconv;\n}\n\nUtf32AutoDecoder.prototype.write = function (buf) {\n  if (!this.decoder) {\n    // Codec is not chosen yet. Accumulate initial bytes.\n    this.initialBytes.push(buf);\n    this.initialBytesLen += buf.length;\n    if (this.initialBytesLen < 32) // We need more bytes to use space heuristic (see below)\n      return ''; // We have enough bytes -> detect endianness.\n\n    var buf2 = Buffer.concat(this.initialBytes),\n        encoding = detectEncoding(buf2, this.options.defaultEncoding);\n    this.decoder = this.iconv.getDecoder(encoding, this.options);\n    this.initialBytes.length = this.initialBytesLen = 0;\n  }\n\n  return this.decoder.write(buf);\n};\n\nUtf32AutoDecoder.prototype.end = function () {\n  if (!this.decoder) {\n    var buf = Buffer.concat(this.initialBytes),\n        encoding = detectEncoding(buf, this.options.defaultEncoding);\n    this.decoder = this.iconv.getDecoder(encoding, this.options);\n    var res = this.decoder.write(buf),\n        trail = this.decoder.end();\n    return trail ? res + trail : res;\n  }\n\n  return this.decoder.end();\n};\n\nfunction detectEncoding(buf, defaultEncoding) {\n  var enc = defaultEncoding || 'utf-32le';\n\n  if (buf.length >= 4) {\n    // Check BOM.\n    if (buf.readUInt32BE(0) === 0xFEFF) // UTF-32LE BOM\n      enc = 'utf-32be';else if (buf.readUInt32LE(0) === 0xFEFF) // UTF-32LE BOM\n      enc = 'utf-32le';else {\n      // No BOM found. Try to deduce encoding from initial content.\n      // Using the wrong endian-ism for UTF-32 will very often result in codepoints that are beyond\n      // the valid Unicode limit of 0x10FFFF. That will be used as the primary determinant.\n      //\n      // Further, we can suppose the content is mostly plain ASCII chars (U+00**).\n      // So, we count ASCII as if it was LE or BE, and decide from that.\n      var invalidLE = 0,\n          invalidBE = 0;\n\n      var asciiCharsLE = 0,\n          asciiCharsBE = 0,\n          // Counts of chars in both positions\n      _len = Math.min(buf.length - buf.length % 4, 128); // Len is always even.\n\n\n      for (var i = 0; i < _len; i += 4) {\n        var b0 = buf[i],\n            b1 = buf[i + 1],\n            b2 = buf[i + 2],\n            b3 = buf[i + 3];\n        if (b0 !== 0 || b1 > 0x10) ++invalidBE;\n        if (b3 !== 0 || b2 > 0x10) ++invalidLE;\n        if (b0 === 0 && b1 === 0 && b2 === 0 && b3 !== 0) asciiCharsBE++;\n        if (b0 !== 0 && b1 === 0 && b2 === 0 && b3 === 0) asciiCharsLE++;\n      }\n\n      if (invalidBE < invalidLE) enc = 'utf-32be';else if (invalidLE < invalidBE) enc = 'utf-32le';\n      if (asciiCharsBE > asciiCharsLE) enc = 'utf-32be';else if (asciiCharsBE < asciiCharsLE) enc = 'utf-32le';\n    }\n  }\n\n  return enc;\n}","map":null,"metadata":{},"sourceType":"script"}