{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _metadataParser = require(\"./metadata-parser\");\n\nvar _dataType = require(\"./data-type\");\n\nvar _iconvLite = _interopRequireDefault(require(\"iconv-lite\"));\n\nvar _sprintfJs = require(\"sprintf-js\");\n\nvar _guidParser = require(\"./guid-parser\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar NULL = (1 << 16) - 1;\nvar MAX = (1 << 16) - 1;\nvar THREE_AND_A_THIRD = 3 + 1 / 3;\nvar MONEY_DIVISOR = 10000;\nvar PLP_NULL = Buffer.from([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);\nvar UNKNOWN_PLP_LEN = Buffer.from([0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);\nvar DEFAULT_ENCODING = 'utf8';\n\nfunction readTinyInt(parser, callback) {\n  parser.readUInt8(callback);\n}\n\nfunction readSmallInt(parser, callback) {\n  parser.readInt16LE(callback);\n}\n\nfunction readInt(parser, callback) {\n  parser.readInt32LE(callback);\n}\n\nfunction readBigInt(parser, callback) {\n  parser.readBigInt64LE(function (value) {\n    callback(value.toString());\n  });\n}\n\nfunction readReal(parser, callback) {\n  parser.readFloatLE(callback);\n}\n\nfunction readFloat(parser, callback) {\n  parser.readDoubleLE(callback);\n}\n\nfunction readSmallMoney(parser, callback) {\n  parser.readInt32LE(function (value) {\n    callback(value / MONEY_DIVISOR);\n  });\n}\n\nfunction readMoney(parser, callback) {\n  parser.readInt32LE(function (high) {\n    parser.readUInt32LE(function (low) {\n      callback((low + 0x100000000 * high) / MONEY_DIVISOR);\n    });\n  });\n}\n\nfunction readBit(parser, callback) {\n  parser.readUInt8(function (value) {\n    callback(!!value);\n  });\n}\n\nfunction valueParse(parser, metadata, options, callback) {\n  var type = metadata.type;\n\n  switch (type.name) {\n    case 'Null':\n      return callback(null);\n\n    case 'TinyInt':\n      return readTinyInt(parser, callback);\n\n    case 'SmallInt':\n      return readSmallInt(parser, callback);\n\n    case 'Int':\n      return readInt(parser, callback);\n\n    case 'BigInt':\n      return readBigInt(parser, callback);\n\n    case 'IntN':\n      return parser.readUInt8(function (dataLength) {\n        switch (dataLength) {\n          case 0:\n            return callback(null);\n\n          case 1:\n            return readTinyInt(parser, callback);\n\n          case 2:\n            return readSmallInt(parser, callback);\n\n          case 4:\n            return readInt(parser, callback);\n\n          case 8:\n            return readBigInt(parser, callback);\n\n          default:\n            return parser.emit('error', new Error('Unsupported dataLength ' + dataLength + ' for IntN'));\n        }\n      });\n\n    case 'Real':\n      return readReal(parser, callback);\n\n    case 'Float':\n      return readFloat(parser, callback);\n\n    case 'FloatN':\n      return parser.readUInt8(function (dataLength) {\n        switch (dataLength) {\n          case 0:\n            return callback(null);\n\n          case 4:\n            return readReal(parser, callback);\n\n          case 8:\n            return readFloat(parser, callback);\n\n          default:\n            return parser.emit('error', new Error('Unsupported dataLength ' + dataLength + ' for FloatN'));\n        }\n      });\n\n    case 'SmallMoney':\n      return readSmallMoney(parser, callback);\n\n    case 'Money':\n      return readMoney(parser, callback);\n\n    case 'MoneyN':\n      return parser.readUInt8(function (dataLength) {\n        switch (dataLength) {\n          case 0:\n            return callback(null);\n\n          case 4:\n            return readSmallMoney(parser, callback);\n\n          case 8:\n            return readMoney(parser, callback);\n\n          default:\n            return parser.emit('error', new Error('Unsupported dataLength ' + dataLength + ' for MoneyN'));\n        }\n      });\n\n    case 'Bit':\n      return readBit(parser, callback);\n\n    case 'BitN':\n      return parser.readUInt8(function (dataLength) {\n        switch (dataLength) {\n          case 0:\n            return callback(null);\n\n          case 1:\n            return readBit(parser, callback);\n\n          default:\n            return parser.emit('error', new Error('Unsupported dataLength ' + dataLength + ' for BitN'));\n        }\n      });\n\n    case 'VarChar':\n    case 'Char':\n      var codepage = metadata.collation.codepage;\n\n      if (metadata.dataLength === MAX) {\n        return readMaxChars(parser, codepage, callback);\n      } else {\n        return parser.readUInt16LE(function (dataLength) {\n          if (dataLength === NULL) {\n            return callback(null);\n          }\n\n          readChars(parser, dataLength, codepage, callback);\n        });\n      }\n\n    case 'NVarChar':\n    case 'NChar':\n      if (metadata.dataLength === MAX) {\n        return readMaxNChars(parser, callback);\n      } else {\n        return parser.readUInt16LE(function (dataLength) {\n          if (dataLength === NULL) {\n            return callback(null);\n          }\n\n          readNChars(parser, dataLength, callback);\n        });\n      }\n\n    case 'VarBinary':\n    case 'Binary':\n      if (metadata.dataLength === MAX) {\n        return readMaxBinary(parser, callback);\n      } else {\n        return parser.readUInt16LE(function (dataLength) {\n          if (dataLength === NULL) {\n            return callback(null);\n          }\n\n          readBinary(parser, dataLength, callback);\n        });\n      }\n\n    case 'Text':\n      return parser.readUInt8(function (textPointerLength) {\n        if (textPointerLength === 0) {\n          return callback(null);\n        }\n\n        parser.readBuffer(textPointerLength, function (_textPointer) {\n          parser.readBuffer(8, function (_timestamp) {\n            parser.readUInt32LE(function (dataLength) {\n              readChars(parser, dataLength, metadata.collation.codepage, callback);\n            });\n          });\n        });\n      });\n\n    case 'NText':\n      return parser.readUInt8(function (textPointerLength) {\n        if (textPointerLength === 0) {\n          return callback(null);\n        }\n\n        parser.readBuffer(textPointerLength, function (_textPointer) {\n          parser.readBuffer(8, function (_timestamp) {\n            parser.readUInt32LE(function (dataLength) {\n              readNChars(parser, dataLength, callback);\n            });\n          });\n        });\n      });\n\n    case 'Image':\n      return parser.readUInt8(function (textPointerLength) {\n        if (textPointerLength === 0) {\n          return callback(null);\n        }\n\n        parser.readBuffer(textPointerLength, function (_textPointer) {\n          parser.readBuffer(8, function (_timestamp) {\n            parser.readUInt32LE(function (dataLength) {\n              readBinary(parser, dataLength, callback);\n            });\n          });\n        });\n      });\n\n    case 'Xml':\n      return readMaxNChars(parser, callback);\n\n    case 'SmallDateTime':\n      return readSmallDateTime(parser, options.useUTC, callback);\n\n    case 'DateTime':\n      return readDateTime(parser, options.useUTC, callback);\n\n    case 'DateTimeN':\n      return parser.readUInt8(function (dataLength) {\n        switch (dataLength) {\n          case 0:\n            return callback(null);\n\n          case 4:\n            return readSmallDateTime(parser, options.useUTC, callback);\n\n          case 8:\n            return readDateTime(parser, options.useUTC, callback);\n\n          default:\n            return parser.emit('error', new Error('Unsupported dataLength ' + dataLength + ' for DateTimeN'));\n        }\n      });\n\n    case 'Time':\n      return parser.readUInt8(function (dataLength) {\n        if (dataLength === 0) {\n          return callback(null);\n        } else {\n          return readTime(parser, dataLength, metadata.scale, options.useUTC, callback);\n        }\n      });\n\n    case 'Date':\n      return parser.readUInt8(function (dataLength) {\n        if (dataLength === 0) {\n          return callback(null);\n        } else {\n          return readDate(parser, options.useUTC, callback);\n        }\n      });\n\n    case 'DateTime2':\n      return parser.readUInt8(function (dataLength) {\n        if (dataLength === 0) {\n          return callback(null);\n        } else {\n          return readDateTime2(parser, dataLength, metadata.scale, options.useUTC, callback);\n        }\n      });\n\n    case 'DateTimeOffset':\n      return parser.readUInt8(function (dataLength) {\n        if (dataLength === 0) {\n          return callback(null);\n        } else {\n          return readDateTimeOffset(parser, dataLength, metadata.scale, callback);\n        }\n      });\n\n    case 'NumericN':\n    case 'DecimalN':\n      return parser.readUInt8(function (dataLength) {\n        if (dataLength === 0) {\n          return callback(null);\n        } else {\n          return readNumeric(parser, dataLength, metadata.precision, metadata.scale, callback);\n        }\n      });\n\n    case 'UniqueIdentifier':\n      return parser.readUInt8(function (dataLength) {\n        switch (dataLength) {\n          case 0:\n            return callback(null);\n\n          case 0x10:\n            return readUniqueIdentifier(parser, options, callback);\n\n          default:\n            return parser.emit('error', new Error((0, _sprintfJs.sprintf)('Unsupported guid size %d', dataLength - 1)));\n        }\n      });\n\n    case 'UDT':\n      return readMaxBinary(parser, callback);\n\n    case 'Variant':\n      return parser.readUInt32LE(function (dataLength) {\n        if (dataLength === 0) {\n          return callback(null);\n        }\n\n        readVariant(parser, options, dataLength, callback);\n      });\n\n    default:\n      parser.emit('error', new Error((0, _sprintfJs.sprintf)('Unrecognised type %s', type.name)));\n  }\n}\n\nfunction readUniqueIdentifier(parser, options, callback) {\n  parser.readBuffer(0x10, function (data) {\n    callback(options.lowerCaseGuids ? (0, _guidParser.bufferToLowerCaseGuid)(data) : (0, _guidParser.bufferToUpperCaseGuid)(data));\n  });\n}\n\nfunction readNumeric(parser, dataLength, _precision, scale, callback) {\n  parser.readUInt8(function (sign) {\n    sign = sign === 1 ? 1 : -1;\n    var readValue;\n\n    if (dataLength === 5) {\n      readValue = parser.readUInt32LE;\n    } else if (dataLength === 9) {\n      readValue = parser.readUNumeric64LE;\n    } else if (dataLength === 13) {\n      readValue = parser.readUNumeric96LE;\n    } else if (dataLength === 17) {\n      readValue = parser.readUNumeric128LE;\n    } else {\n      return parser.emit('error', new Error((0, _sprintfJs.sprintf)('Unsupported numeric dataLength %d', dataLength)));\n    }\n\n    readValue.call(parser, function (value) {\n      callback(value * sign / Math.pow(10, scale));\n    });\n  });\n}\n\nfunction readVariant(parser, options, dataLength, callback) {\n  return parser.readUInt8(function (baseType) {\n    var type = _dataType.TYPE[baseType];\n    return parser.readUInt8(function (propBytes) {\n      dataLength = dataLength - propBytes - 2;\n\n      switch (type.name) {\n        case 'UniqueIdentifier':\n          return readUniqueIdentifier(parser, options, callback);\n\n        case 'Bit':\n          return readBit(parser, callback);\n\n        case 'TinyInt':\n          return readTinyInt(parser, callback);\n\n        case 'SmallInt':\n          return readSmallInt(parser, callback);\n\n        case 'Int':\n          return readInt(parser, callback);\n\n        case 'BigInt':\n          return readBigInt(parser, callback);\n\n        case 'SmallDateTime':\n          return readSmallDateTime(parser, options.useUTC, callback);\n\n        case 'DateTime':\n          return readDateTime(parser, options.useUTC, callback);\n\n        case 'Real':\n          return readReal(parser, callback);\n\n        case 'Float':\n          return readFloat(parser, callback);\n\n        case 'SmallMoney':\n          return readSmallMoney(parser, callback);\n\n        case 'Money':\n          return readMoney(parser, callback);\n\n        case 'Date':\n          return readDate(parser, options.useUTC, callback);\n\n        case 'Time':\n          return parser.readUInt8(function (scale) {\n            return readTime(parser, dataLength, scale, options.useUTC, callback);\n          });\n\n        case 'DateTime2':\n          return parser.readUInt8(function (scale) {\n            return readDateTime2(parser, dataLength, scale, options.useUTC, callback);\n          });\n\n        case 'DateTimeOffset':\n          return parser.readUInt8(function (scale) {\n            return readDateTimeOffset(parser, dataLength, scale, callback);\n          });\n\n        case 'VarBinary':\n        case 'Binary':\n          return parser.readUInt16LE(function (_maxLength) {\n            readBinary(parser, dataLength, callback);\n          });\n\n        case 'NumericN':\n        case 'DecimalN':\n          return parser.readUInt8(function (precision) {\n            parser.readUInt8(function (scale) {\n              readNumeric(parser, dataLength, precision, scale, callback);\n            });\n          });\n\n        case 'VarChar':\n        case 'Char':\n          return parser.readUInt16LE(function (_maxLength) {\n            (0, _metadataParser.readCollation)(parser, function (collation) {\n              readChars(parser, dataLength, collation.codepage, callback);\n            });\n          });\n\n        case 'NVarChar':\n        case 'NChar':\n          return parser.readUInt16LE(function (_maxLength) {\n            (0, _metadataParser.readCollation)(parser, function (_collation) {\n              readNChars(parser, dataLength, callback);\n            });\n          });\n\n        default:\n          throw new Error('Invalid type!');\n      }\n    });\n  });\n}\n\nfunction readBinary(parser, dataLength, callback) {\n  return parser.readBuffer(dataLength, callback);\n}\n\nfunction readChars(parser, dataLength, codepage, callback) {\n  if (codepage == null) {\n    codepage = DEFAULT_ENCODING;\n  }\n\n  return parser.readBuffer(dataLength, function (data) {\n    callback(_iconvLite.default.decode(data, codepage));\n  });\n}\n\nfunction readNChars(parser, dataLength, callback) {\n  parser.readBuffer(dataLength, function (data) {\n    callback(data.toString('ucs2'));\n  });\n}\n\nfunction readMaxBinary(parser, callback) {\n  return readMax(parser, callback);\n}\n\nfunction readMaxChars(parser, codepage, callback) {\n  if (codepage == null) {\n    codepage = DEFAULT_ENCODING;\n  }\n\n  readMax(parser, function (data) {\n    if (data) {\n      callback(_iconvLite.default.decode(data, codepage));\n    } else {\n      callback(null);\n    }\n  });\n}\n\nfunction readMaxNChars(parser, callback) {\n  readMax(parser, function (data) {\n    if (data) {\n      callback(data.toString('ucs2'));\n    } else {\n      callback(null);\n    }\n  });\n}\n\nfunction readMax(parser, callback) {\n  parser.readBuffer(8, function (type) {\n    if (type.equals(PLP_NULL)) {\n      return callback(null);\n    } else if (type.equals(UNKNOWN_PLP_LEN)) {\n      return readMaxUnknownLength(parser, callback);\n    } else {\n      var low = type.readUInt32LE(0);\n      var high = type.readUInt32LE(4);\n\n      if (high >= 2 << 53 - 32) {\n        console.warn('Read UInt64LE > 53 bits : high=' + high + ', low=' + low);\n      }\n\n      var expectedLength = low + 0x100000000 * high;\n      return readMaxKnownLength(parser, expectedLength, callback);\n    }\n  });\n}\n\nfunction readMaxKnownLength(parser, totalLength, callback) {\n  var data = Buffer.alloc(totalLength, 0);\n  var offset = 0;\n\n  function next(done) {\n    parser.readUInt32LE(function (chunkLength) {\n      if (!chunkLength) {\n        return done();\n      }\n\n      parser.readBuffer(chunkLength, function (chunk) {\n        chunk.copy(data, offset);\n        offset += chunkLength;\n        next(done);\n      });\n    });\n  }\n\n  next(function () {\n    if (offset !== totalLength) {\n      parser.emit('error', new Error('Partially Length-prefixed Bytes unmatched lengths : expected ' + totalLength + ', but got ' + offset + ' bytes'));\n    }\n\n    callback(data);\n  });\n}\n\nfunction readMaxUnknownLength(parser, callback) {\n  var chunks = [];\n  var length = 0;\n\n  function next(done) {\n    parser.readUInt32LE(function (chunkLength) {\n      if (!chunkLength) {\n        return done();\n      }\n\n      parser.readBuffer(chunkLength, function (chunk) {\n        chunks.push(chunk);\n        length += chunkLength;\n        next(done);\n      });\n    });\n  }\n\n  next(function () {\n    callback(Buffer.concat(chunks, length));\n  });\n}\n\nfunction readSmallDateTime(parser, useUTC, callback) {\n  parser.readUInt16LE(function (days) {\n    parser.readUInt16LE(function (minutes) {\n      var value;\n\n      if (useUTC) {\n        value = new Date(Date.UTC(1900, 0, 1 + days, 0, minutes));\n      } else {\n        value = new Date(1900, 0, 1 + days, 0, minutes);\n      }\n\n      callback(value);\n    });\n  });\n}\n\nfunction readDateTime(parser, useUTC, callback) {\n  parser.readInt32LE(function (days) {\n    parser.readUInt32LE(function (threeHundredthsOfSecond) {\n      var milliseconds = Math.round(threeHundredthsOfSecond * THREE_AND_A_THIRD);\n      var value;\n\n      if (useUTC) {\n        value = new Date(Date.UTC(1900, 0, 1 + days, 0, 0, 0, milliseconds));\n      } else {\n        value = new Date(1900, 0, 1 + days, 0, 0, 0, milliseconds);\n      }\n\n      callback(value);\n    });\n  });\n}\n\nfunction readTime(parser, dataLength, scale, useUTC, callback) {\n  var readValue;\n\n  switch (dataLength) {\n    case 3:\n      readValue = parser.readUInt24LE;\n      break;\n\n    case 4:\n      readValue = parser.readUInt32LE;\n      break;\n\n    case 5:\n      readValue = parser.readUInt40LE;\n  }\n\n  readValue.call(parser, function (value) {\n    if (scale < 7) {\n      for (var i = scale; i < 7; i++) {\n        value *= 10;\n      }\n    }\n\n    var date;\n\n    if (useUTC) {\n      date = new Date(Date.UTC(1970, 0, 1, 0, 0, 0, value / 10000));\n    } else {\n      date = new Date(1970, 0, 1, 0, 0, 0, value / 10000);\n    }\n\n    Object.defineProperty(date, 'nanosecondsDelta', {\n      enumerable: false,\n      value: value % 10000 / Math.pow(10, 7)\n    });\n    callback(date);\n  });\n}\n\nfunction readDate(parser, useUTC, callback) {\n  parser.readUInt24LE(function (days) {\n    if (useUTC) {\n      callback(new Date(Date.UTC(2000, 0, days - 730118)));\n    } else {\n      callback(new Date(2000, 0, days - 730118));\n    }\n  });\n}\n\nfunction readDateTime2(parser, dataLength, scale, useUTC, callback) {\n  readTime(parser, dataLength - 3, scale, useUTC, function (time) {\n    // TODO: 'input' is 'time', but TypeScript cannot find \"time.nanosecondsDelta\";\n    parser.readUInt24LE(function (days) {\n      var date;\n\n      if (useUTC) {\n        date = new Date(Date.UTC(2000, 0, days - 730118, 0, 0, 0, +time));\n      } else {\n        date = new Date(2000, 0, days - 730118, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());\n      }\n\n      Object.defineProperty(date, 'nanosecondsDelta', {\n        enumerable: false,\n        value: time.nanosecondsDelta\n      });\n      callback(date);\n    });\n  });\n}\n\nfunction readDateTimeOffset(parser, dataLength, scale, callback) {\n  readTime(parser, dataLength - 5, scale, true, function (time) {\n    parser.readUInt24LE(function (days) {\n      // offset\n      parser.readInt16LE(function () {\n        var date = new Date(Date.UTC(2000, 0, days - 730118, 0, 0, 0, +time));\n        Object.defineProperty(date, 'nanosecondsDelta', {\n          enumerable: false,\n          value: time.nanosecondsDelta\n        });\n        callback(date);\n      });\n    });\n  });\n}\n\nvar _default = valueParse;\nexports.default = _default;\nmodule.exports = valueParse;","map":null,"metadata":{},"sourceType":"script"}