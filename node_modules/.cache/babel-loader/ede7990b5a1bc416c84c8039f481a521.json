{"ast":null,"code":"/*\r\n * @copyright\r\n * Copyright Â© Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\n'use strict';\n\nvar _ = require('underscore');\n\nvar select = require('xpath.js');\n\nvar XMLSerializer = require('xmldom').XMLSerializer;\n\nvar constants = require('./constants');\n/**\r\n * @namespace XmlUtil\r\n * @private\r\n */\n\n\nvar XPATH_PATH_TEMPLATE = '*[local-name() = \\'LOCAL_NAME\\' and namespace-uri() = \\'NAMESPACE\\']';\n/**\r\n* The xpath implementation being used does not have a way of matching expanded namespace.\r\n* This method takes an xpath query and expands all of the namespaces involved.  It then\r\n* re-writes the query in to a longer form that directory matches the correct namespaces.\r\n* @private\r\n* @static\r\n* @memberOf XmlUtil\r\n* @param {string} xpath   The expath query string to expand.\r\n* @returns {string} An expanded xpath query.\r\n*/\n\nfunction expandQNames(xpath) {\n  var namespaces = constants.XmlNamespaces;\n  var pathParts = xpath.split('/');\n\n  for (var i = 0; i < pathParts.length; i++) {\n    if (pathParts[i].indexOf(':') !== -1) {\n      var QNameParts = pathParts[i].split(':');\n\n      if (QNameParts.length !== 2) {\n        throw new Error('Unable to parse XPath string : ' + xpath + ' : with QName : ' + pathParts[i]);\n      }\n\n      var expandedPath = XPATH_PATH_TEMPLATE.replace('LOCAL_NAME', QNameParts[1]);\n      expandedPath = expandedPath.replace('NAMESPACE', namespaces[QNameParts[0]]);\n      pathParts[i] = expandedPath;\n    }\n  }\n\n  return pathParts.join('/');\n}\n\nvar exports = {\n  /**\r\n   * Performs an xpath select that does appropriate namespace matching since the imported\r\n   * xpath module does not properly handle namespaces.\r\n   * @static\r\n   * @memberOf XmlUtil\r\n   * @param  {object} dom     A dom object created by the xmldom module\r\n   * @param  {string} xpath   An xpath expression\r\n   * @return {array}          An array of matching dom nodes.\r\n   */\n  xpathSelect: function xpathSelect(dom, xpath) {\n    return select(dom, expandQNames(xpath));\n  },\n\n  /**\r\n   * Given a dom node serializes all immediate children that are xml elements.\r\n   * @static\r\n   * @memberOf XmlUtil\r\n   * @param  {object} node  An xml dom node.\r\n   * @return {string}       Serialized xml.\r\n   */\n  serializeNodeChildren: function serializeNodeChildren(node) {\n    var doc = '';\n    var sibling = node.firstChild;\n    var serializer = new XMLSerializer();\n\n    while (sibling) {\n      if (this.isElementNode(sibling)) {\n        doc += serializer.serializeToString(sibling);\n      }\n\n      sibling = sibling.nextSibling;\n    }\n\n    return doc !== '' ? doc : null;\n  },\n\n  /**\r\n   * Detects whether the passed in dom node represents an xml element.\r\n   * @static\r\n   * @memberOf XmlUtil\r\n   * @param  {object}  node   An xml dom node.\r\n   * @return {Boolean}        true if the node represents an element.\r\n   */\n  isElementNode: function isElementNode(node) {\n    return _.has(node, 'tagName');\n  },\n\n  /**\r\n   * Given an xmldom node this function returns any text data contained within.\r\n   * @static\r\n   * @memberOf XmlUtil\r\n   * @param  {object} node  An xmldom node from which the data should be extracted.\r\n   * @return {string}       Any data found within the element or null if none is found.\r\n   */\n  findElementText: function findElementText(node) {\n    var sibling = node.firstChild;\n\n    while (sibling && !sibling.data) {\n      sibling = sibling.nextSibling;\n    }\n\n    return sibling.data ? sibling.data : null;\n  }\n};\nmodule.exports = exports;","map":null,"metadata":{},"sourceType":"script"}