{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar debug = require('debug')('mssql:base');\n\nvar tarn = require('tarn');\n\nvar _require2 = require('../utils'),\n    IDS = _require2.IDS;\n\nvar ConnectionString = require('../connectionstring');\n\nvar ConnectionError = require('../error/connection-error');\n\nvar shared = require('../shared');\n/**\n * Class ConnectionPool.\n *\n * Internally, each `Connection` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool.\n *\n * @property {Boolean} connected If true, connection is established.\n * @property {Boolean} connecting If true, connection is being established.\n *\n * @fires ConnectionPool#connect\n * @fires ConnectionPool#close\n */\n\n\nvar ConnectionPool = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(ConnectionPool, _EventEmitter);\n\n  /**\n   * Create new Connection.\n   *\n   * @param {Object|String} config Connection configuration object or connection string.\n   * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred.\n   */\n  function ConnectionPool(config, callback) {\n    var _this;\n\n    _classCallCheck(this, ConnectionPool);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ConnectionPool).call(this));\n    IDS.add(_assertThisInitialized(_assertThisInitialized(_this)), 'ConnectionPool');\n    debug('pool(%d): created', IDS.get(_assertThisInitialized(_assertThisInitialized(_this))));\n    _this._connectStack = [];\n    _this._closeStack = [];\n    _this._connected = false;\n    _this._connecting = false;\n    _this._healthy = false;\n\n    if (typeof config === 'string') {\n      try {\n        _this.config = ConnectionString.resolve(config, shared.driver.name);\n      } catch (ex) {\n        if (typeof callback === 'function') {\n          return _possibleConstructorReturn(_this, setImmediate(callback, ex));\n        }\n\n        throw ex;\n      }\n    } else {\n      _this.config = Object.assign({}, config);\n    } // set defaults\n\n\n    _this.config.port = _this.config.port || 1433;\n    _this.config.options = _this.config.options || {};\n    _this.config.stream = _this.config.stream || false;\n    _this.config.parseJSON = _this.config.parseJSON || false;\n    _this.config.arrayRowMode = _this.config.arrayRowMode || false;\n\n    if (/^(.*)\\\\(.*)$/.exec(_this.config.server)) {\n      _this.config.server = RegExp.$1;\n      _this.config.options.instanceName = RegExp.$2;\n    }\n\n    if (typeof callback === 'function') {\n      _this.connect(callback);\n    }\n\n    return _this;\n  }\n\n  _createClass(ConnectionPool, [{\n    key: \"acquire\",\n\n    /**\n     * Acquire connection from this connection pool.\n     *\n     * @param {ConnectionPool|Transaction|PreparedStatement} requester Requester.\n     * @param {acquireCallback} [callback] A callback which is called after connection has been acquired, or an error has occurred. If omited, method returns Promise.\n     * @return {ConnectionPool|Promise}\n     */\n    value: function acquire(requester, callback) {\n      var _this2 = this;\n\n      var acquirePromise = shared.Promise.resolve(this._acquire().promise).catch(function (err) {\n        _this2.emit('error', err);\n\n        throw err;\n      });\n\n      if (typeof callback === 'function') {\n        acquirePromise.then(function (connection) {\n          return callback(null, connection, _this2.config);\n        }).catch(callback);\n        return this;\n      }\n\n      return acquirePromise;\n    }\n  }, {\n    key: \"_acquire\",\n    value: function _acquire() {\n      if (!this.pool) {\n        return shared.Promise.reject(new ConnectionError('Connection not yet open.', 'ENOTOPEN'));\n      } else if (this.pool.destroyed) {\n        return shared.Promise.reject(new ConnectionError('Connection is closing', 'ENOTOPEN'));\n      }\n\n      return this.pool.acquire();\n    }\n    /**\n     * Release connection back to the pool.\n     *\n     * @param {Connection} connection Previously acquired connection.\n     * @return {ConnectionPool}\n     */\n\n  }, {\n    key: \"release\",\n    value: function release(connection) {\n      debug('connection(%d): released', IDS.get(connection));\n\n      if (this.pool) {\n        this.pool.release(connection);\n      }\n\n      return this;\n    }\n    /**\n     * Creates a new connection pool with one active connection. This one initial connection serves as a probe to find out whether the configuration is valid.\n     *\n     * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.\n     * @return {ConnectionPool|Promise}\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect(callback) {\n      var _this3 = this;\n\n      if (typeof callback === 'function') {\n        this._connect(callback);\n\n        return this;\n      }\n\n      return new shared.Promise(function (resolve, reject) {\n        return _this3._connect(function (err) {\n          if (err) return reject(err);\n          resolve(_this3);\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {basicCallback} callback\n     */\n\n  }, {\n    key: \"_connect\",\n    value: function _connect(callback) {\n      var _this4 = this;\n\n      if (this._connected) {\n        debug('pool(%d): already connected, executing connect callback immediately', IDS.get(this));\n        return setImmediate(callback, null, this);\n      }\n\n      this._connectStack.push(callback);\n\n      if (this._connecting) {\n        return;\n      }\n\n      this._connecting = true;\n      debug('pool(%d): connecting', IDS.get(this)); // create one test connection to check if everything is ok\n\n      this._poolCreate().then(function (connection) {\n        debug('pool(%d): connected', IDS.get(_this4));\n        _this4._healthy = true;\n        return _this4._poolDestroy(connection).then(function () {\n          // prepare pool\n          _this4.pool = new tarn.Pool(Object.assign({\n            create: function create() {\n              return _this4._poolCreate().then(function (connection) {\n                _this4._healthy = true;\n                return connection;\n              }).catch(function (err) {\n                if (_this4.pool.numUsed() + _this4.pool.numFree() <= 0) {\n                  _this4._healthy = false;\n                }\n\n                throw err;\n              });\n            },\n            validate: _this4._poolValidate.bind(_this4),\n            destroy: _this4._poolDestroy.bind(_this4),\n            max: 10,\n            min: 0,\n            idleTimeoutMillis: 30000,\n            propagateCreateError: true\n          }, _this4.config.pool));\n          var self = _this4;\n          Object.defineProperties(_this4.pool, {\n            size: {\n              get: function get() {\n                var message = 'the `size` property on pool is deprecated, access it directly on the `ConnectionPool`';\n                self.emit('debug', message);\n                process.emitWarning(message);\n                return self.size;\n              }\n            },\n            available: {\n              get: function get() {\n                var message = 'the `available` property on pool is deprecated, access it directly on the `ConnectionPool`';\n                self.emit('debug', message);\n                process.emitWarning(message);\n                return self.available;\n              }\n            },\n            pending: {\n              get: function get() {\n                var message = 'the `pending` property on pool is deprecate, access it directly on the `ConnectionPool`';\n                self.emit('debug', message);\n                process.emitWarning(message);\n                return self.pending;\n              }\n            },\n            borrowed: {\n              get: function get() {\n                var message = 'the `borrowed` property on pool is deprecated, access it directly on the `ConnectionPool`';\n                self.emit('debug', message);\n                process.emitWarning(message);\n                return self.borrowed;\n              }\n            }\n          });\n          _this4._connecting = false;\n          _this4._connected = true;\n        });\n      }).then(function () {\n        _this4._connectStack.forEach(function (cb) {\n          setImmediate(cb, null, _this4);\n        });\n      }).catch(function (err) {\n        _this4._connecting = false;\n\n        _this4._connectStack.forEach(function (cb) {\n          setImmediate(cb, err);\n        });\n      }).then(function () {\n        _this4._connectStack = [];\n      });\n    }\n  }, {\n    key: \"close\",\n\n    /**\n     * Close all active connections in the pool.\n     *\n     * @param {basicCallback} [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.\n     * @return {ConnectionPool|Promise}\n     */\n    value: function close(callback) {\n      var _this5 = this;\n\n      if (typeof callback === 'function') {\n        this._close(callback);\n\n        return this;\n      }\n\n      return new shared.Promise(function (resolve, reject) {\n        _this5._close(function (err) {\n          if (err) return reject(err);\n          resolve(_this5);\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {basicCallback} callback\n     */\n\n  }, {\n    key: \"_close\",\n    value: function _close(callback) {\n      var _this6 = this;\n\n      // we don't allow pools in a connecting state to be closed because it means there are far too many\n      // edge cases to deal with\n      if (this._connecting) {\n        debug('pool(%d): close called while connecting', IDS.get(this));\n        setImmediate(callback, new ConnectionError('Cannot close a pool while it is connecting'));\n      }\n\n      if (!this.pool) {\n        debug('pool(%d): already closed, executing close callback immediately', IDS.get(this));\n        return setImmediate(callback, null);\n      }\n\n      this._closeStack.push(callback);\n\n      if (this.pool.destroyed) return;\n      this._connecting = this._connected = this._healthy = false;\n      this.pool.destroy().then(function () {\n        debug('pool(%d): pool closed, removing pool reference and executing close callbacks', IDS.get(_this6));\n        _this6.pool = null;\n\n        _this6._closeStack.forEach(function (cb) {\n          setImmediate(cb, null);\n        });\n      }).catch(function (err) {\n        _this6.pool = null;\n\n        _this6._closeStack.forEach(function (cb) {\n          setImmediate(cb, err);\n        });\n      }).then(function () {\n        _this6._closeStack = [];\n      });\n    }\n    /**\n     * Returns new request using this connection.\n     *\n     * @return {Request}\n     */\n\n  }, {\n    key: \"request\",\n    value: function request() {\n      return new shared.driver.Request(this);\n    }\n    /**\n     * Returns new transaction using this connection.\n     *\n     * @return {Transaction}\n     */\n\n  }, {\n    key: \"transaction\",\n    value: function transaction() {\n      return new shared.driver.Transaction(this);\n    }\n    /**\n     * Creates a new query using this connection from a tagged template string.\n     *\n     * @variation 1\n     * @param {Array} strings Array of string literals.\n     * @param {...*} keys Values.\n     * @return {Request}\n     */\n\n    /**\n     * Execute the SQL command.\n     *\n     * @variation 2\n     * @param {String} command T-SQL command to be executed.\n     * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {Request|Promise}\n     */\n\n  }, {\n    key: \"query\",\n    value: function query() {\n      if (typeof arguments[0] === 'string') {\n        return new shared.driver.Request(this).query(arguments[0], arguments[1]);\n      }\n\n      var values = Array.prototype.slice.call(arguments);\n      var strings = values.shift();\n      return new shared.driver.Request(this)._template(strings, values, 'query');\n    }\n    /**\n     * Creates a new batch using this connection from a tagged template string.\n     *\n     * @variation 1\n     * @param {Array} strings Array of string literals.\n     * @param {...*} keys Values.\n     * @return {Request}\n     */\n\n    /**\n     * Execute the SQL command.\n     *\n     * @variation 2\n     * @param {String} command T-SQL command to be executed.\n     * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {Request|Promise}\n     */\n\n  }, {\n    key: \"batch\",\n    value: function batch() {\n      if (typeof arguments[0] === 'string') {\n        return new shared.driver.Request(this).batch(arguments[0], arguments[1]);\n      }\n\n      var values = Array.prototype.slice.call(arguments);\n      var strings = values.shift();\n      return new shared.driver.Request(this)._template(strings, values, 'batch');\n    }\n  }, {\n    key: \"connected\",\n    get: function get() {\n      return this._connected;\n    }\n  }, {\n    key: \"connecting\",\n    get: function get() {\n      return this._connecting;\n    }\n  }, {\n    key: \"healthy\",\n    get: function get() {\n      return this._healthy;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.pool.numFree() + this.pool.numUsed() + this.pool.numPendingCreates();\n    }\n  }, {\n    key: \"available\",\n    get: function get() {\n      return this.pool.numFree();\n    }\n  }, {\n    key: \"pending\",\n    get: function get() {\n      return this.pool.numPendingAcquires();\n    }\n  }, {\n    key: \"borrowed\",\n    get: function get() {\n      return this.pool.numUsed();\n    }\n  }]);\n\n  return ConnectionPool;\n}(EventEmitter);\n\nmodule.exports = ConnectionPool;","map":null,"metadata":{},"sourceType":"script"}