{"ast":null,"code":"/*\r\n * @copyright\r\n * Copyright Â© Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\n'use strict';\n\nvar _ = require('underscore');\n\nvar crypto = require('crypto');\n\nrequire('date-utils'); // Adds a number of convenience methods to the builtin Date object.\n\n\nvar Logger = require('./log').Logger;\n\nvar constants = require('./constants');\n\nvar cacheConstants = constants.Cache;\nvar TokenResponseFields = constants.TokenResponseFields; // TODO: remove this.\n// There is a PM requirement that developers be able to look in to the cache and manipulate the cache based on\n// the parameters (authority, resource, clientId, userId), in any combination.  They must be able find, add, and remove\n// tokens based on those parameters.  Any default cache that the API supplies must allow for this query pattern.\n// This has the following implications:\n//  The developer must not be required to calculate any special fields, such as hashes or unique keys.\n//\n//  The default cache implementation can not include optimizations that break the previous requirement.\n//  This means that we can only do complete scans of the data and equality can only be calculated based on\n//  equality of all of the individual fields.\n//\n//  The cache interface can not make any assumption about the query efficency of the cache nor can\n//  it help in optimizing those queries.\n//\n//  There is no simple sorting optimization, rather a series of indexes, and index intersection would\n//  be necessary.\n//\n//  If for some reason the developer tries to update the cache with a new entry that may be a refresh\n//  token, they will not know that they need to update all of the refresh tokens or they may get strange\n//  behavior.\n//\n//  Related to the above, there is no definition of a coherent cache.  And if there was there would be\n//  no way for our API to enforce it.  What about duplicates?\n//\n// there be a single cache entry per (authority, resource, clientId)\n// tuple, with no special tokens (i.e. MRRT tokens)\n// Required cache operations\n//\n// Constants\n\nvar METADATA_CLIENTID = '_clientId';\nvar METADATA_AUTHORITY = '_authority';\n\nfunction nop(placeHolder, callback) {\n  callback();\n}\n/*\r\n * This is a place holder cache that does nothing.\r\n */\n\n\nvar nopCache = {\n  add: nop,\n  addMany: nop,\n  remove: nop,\n  removeMany: nop,\n  find: nop\n};\n\nfunction createTokenHash(token) {\n  var hashAlg = crypto.createHash(cacheConstants.HASH_ALGORITHM);\n  hashAlg.update(token, 'utf8');\n  return hashAlg.digest('base64');\n}\n\nfunction createTokenIdMessage(entry) {\n  var accessTokenHash = createTokenHash(entry[TokenResponseFields.ACCESS_TOKEN]);\n  var message = 'AccessTokenId: ' + accessTokenHash;\n\n  if (entry[TokenResponseFields.REFRESH_TOKEN]) {\n    var refreshTokenHash = createTokenHash(entry[TokenResponseFields.REFRESH_TOKEN]);\n    message += ', RefreshTokenId: ' + refreshTokenHash;\n  }\n\n  return message;\n}\n/**\r\n * This is the callback that is passed to all acquireToken variants below.\r\n * @callback RefreshEntryFunction\r\n * @memberOf CacheDriver\r\n * @param {object}  tokenResponse    A token response to refresh.\r\n * @param {string}  [resource]       The resource for which to obtain the token if it is different from the original token.\r\n * @param {AcquireTokenCallback} callback   Called on completion with an error or a new entry to add to the cache.\r\n */\n\n/**\r\n * Constructs a new CacheDriver object.\r\n * @constructor\r\n * @private\r\n * @param {object} callContext Contains any context information that applies to the request.\r\n * @param {string} authority\r\n * @param {TokenCache} [cache]     A token cache to use.  If none is passed then the CacheDriver instance\r\n *                                 will not cache.\r\n * @param {RefreshEntryFunction} refreshFunction\r\n */\n\n\nfunction CacheDriver(callContext, authority, resource, clientId, cache, refreshFunction) {\n  this._callContext = callContext;\n  this._log = new Logger('CacheDriver', callContext._logContext);\n  this._authority = authority;\n  this._resource = resource;\n  this._clientId = clientId;\n  this._cache = cache || nopCache;\n  this._refreshFunction = refreshFunction;\n}\n/**\r\n * This is the callback that is passed to all acquireToken variants below.\r\n * @callback QueryCallback\r\n * @memberOf CacheDriver\r\n * @param {Error}  [error]           If the request fails this parameter will contain an Error object.\r\n * @param {Array} [response]   On a succesful request returns an array of matched entries.\r\n */\n\n/**\r\n * The cache driver query function.  Ensures that all queries are authority specific.\r\n * @param  {object}   query    A query object.  Can contain a clientId or userId or both.\r\n * @param  {QueryCallback} callback\r\n */\n\n\nCacheDriver.prototype._find = function (query, callback) {\n  this._cache.find(query, callback);\n};\n/**\r\n * Queries for all entries that might satisfy a request for a cached token.\r\n * @param  {object}   query    A query object.  Can contain a clientId or userId or both.\r\n * @param  {QueryCallback} callback\r\n */\n\n\nCacheDriver.prototype._getPotentialEntries = function (query, callback) {\n  var self = this;\n  var potentialEntriesQuery = {};\n\n  if (query.clientId) {\n    potentialEntriesQuery[METADATA_CLIENTID] = query.clientId;\n  }\n\n  if (query.userId) {\n    potentialEntriesQuery[TokenResponseFields.USER_ID] = query.userId;\n  }\n\n  this._log.verbose('Looking for potential cache entries:');\n\n  this._log.verbose(JSON.stringify(potentialEntriesQuery), true);\n\n  this._find(potentialEntriesQuery, function (err, entries) {\n    self._log.verbose('Found ' + entries.length + ' potential entries.');\n\n    callback(err, entries);\n    return;\n  });\n};\n/**\r\n * Finds all multi resource refresh tokens in the cache.\r\n * Refresh token is bound to userId, clientId. \r\n * @param  {QueryCallback} callback\r\n */\n\n\nCacheDriver.prototype._findMRRTTokensForUser = function (user, callback) {\n  this._find({\n    isMRRT: true,\n    userId: user,\n    _clientId: this._clientId\n  }, callback);\n};\n/**\r\n * This is the callback that is passed to all acquireToken variants below.\r\n * @callback SingleEntryCallback\r\n * @memberOf CacheDriver\r\n * @param {Error}  [error]           If the request fails this parameter will contain an Error object.\r\n * @param {object} [response]   On a succesful request returns a single cache entry.\r\n */\n\n/**\r\n * Finds a single entry that matches the query.  If multiple entries are found that satisfy the query\r\n * then an error will be returned.\r\n * @param {object}  query A query object.\r\n * @param {SingleEntryCallback} callback\r\n */\n\n\nCacheDriver.prototype._loadSingleEntryFromCache = function (query, callback) {\n  var self = this;\n\n  this._getPotentialEntries(query, function (err, potentialEntries) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    var returnVal;\n    var isResourceTenantSpecific;\n\n    if (potentialEntries && 0 < potentialEntries.length) {\n      var resourceTenantSpecificEntries = _.where(potentialEntries, {\n        resource: self._resource,\n        _authority: self._authority\n      });\n\n      if (!resourceTenantSpecificEntries || 0 === resourceTenantSpecificEntries.length) {\n        self._log.verbose('No resource specific cache entries found.'); // There are no resource specific entries.  Find an MRRT token.\n\n\n        var mrrtTokens = _.where(potentialEntries, {\n          isMRRT: true\n        });\n\n        if (mrrtTokens && mrrtTokens.length > 0) {\n          self._log.verbose('Found an MRRT token.');\n\n          returnVal = mrrtTokens[0];\n        } else {\n          self._log.verbose('No MRRT tokens found.');\n        }\n      } else if (resourceTenantSpecificEntries.length === 1) {\n        self._log.verbose('Resource specific token found.');\n\n        returnVal = resourceTenantSpecificEntries[0];\n        isResourceTenantSpecific = true;\n      } else {\n        callback(self._log.createError('More than one token matches the criteria.  The result is ambiguous.'));\n        return;\n      }\n    }\n\n    if (returnVal) {\n      self._log.verbose('Returning token from cache lookup');\n\n      self._log.verbose('Returning token from cache lookup, ' + createTokenIdMessage(returnVal), true);\n    }\n\n    callback(null, returnVal, isResourceTenantSpecific);\n  });\n};\n/**\r\n * The response from a token refresh request never contains an id_token and therefore no\r\n * userInfo can be created from the response.  This function creates a new cache entry\r\n * combining the id_token based info and cache metadata from the cache entry that was refreshed with the\r\n * new tokens in the refresh response.\r\n * @param  {object} entry           A cache entry corresponding to the resfreshResponse.\r\n * @param  {object} refreshResponse The response from a token refresh request for the entry parameter.\r\n * @return {object}                 A new cache entry.\r\n */\n\n\nCacheDriver.prototype._createEntryFromRefresh = function (entry, refreshResponse) {\n  var newEntry = _.clone(entry);\n\n  newEntry = _.extend(newEntry, refreshResponse);\n\n  if (entry.isMRRT && this._authority !== entry[METADATA_AUTHORITY]) {\n    newEntry[METADATA_AUTHORITY] = this._authority;\n  }\n\n  this._log.verbose('Created new cache entry from refresh response.');\n\n  return newEntry;\n};\n\nCacheDriver.prototype._replaceEntry = function (entryToReplace, newEntry, callback) {\n  var self = this;\n  this.remove(entryToReplace, function (err) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    self.add(newEntry, callback);\n  });\n};\n/**\r\n * Given an expired cache entry refreshes it and updates the cache.\r\n * @param  {object}   entry              A cache entry with an MRRT to refresh for another resource.\r\n * @param  {SingleEntryCallback} callback\r\n */\n\n\nCacheDriver.prototype._refreshExpiredEntry = function (entry, callback) {\n  var self = this;\n\n  this._refreshFunction(entry, null, function (err, tokenResponse) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    var newEntry = self._createEntryFromRefresh(entry, tokenResponse);\n\n    self._replaceEntry(entry, newEntry, function (err) {\n      if (err) {\n        self._log.error('error refreshing expired token', err, true);\n      } else {\n        self._log.info('Returning token refreshed after expiry.');\n      }\n\n      callback(err, newEntry);\n    });\n  });\n};\n/**\r\n * Given a cache entry with an MRRT will acquire a new token for a new resource via the MRRT, and cache it.\r\n * @param  {object}   entry              A cache entry with an MRRT to refresh for another resource.\r\n * @param  {SingleEntryCallback} callback\r\n */\n\n\nCacheDriver.prototype._acquireNewTokenFromMrrt = function (entry, callback) {\n  var self = this;\n\n  this._refreshFunction(entry, this._resource, function (err, tokenResponse) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    var newEntry = self._createEntryFromRefresh(entry, tokenResponse);\n\n    self.add(newEntry, function (err) {\n      if (err) {\n        self._log.error('error refreshing mrrt', err, true);\n      } else {\n        self._log.info('Returning token derived from mrrt refresh.');\n      }\n\n      callback(err, newEntry);\n    });\n  });\n};\n/**\r\n * Given a token this function will refresh it if it is either expired, or an MRRT.\r\n * @param  {object}   entry              A cache entry to refresh if necessary.\r\n * @param  {Boolean}  isResourceSpecific Indicates whether this token is appropriate for the resource for which\r\n *                                       it was requested or whether it is possibly an MRRT token for which\r\n *                                       a resource specific access token should be acquired.\r\n * @param  {SingleEntryCallback} callback\r\n */\n\n\nCacheDriver.prototype._refreshEntryIfNecessary = function (entry, isResourceSpecific, callback) {\n  var expiryDate = entry[TokenResponseFields.EXPIRES_ON]; // Add some buffer in to the time comparison to account for clock skew or latency.\n\n  var nowPlusBuffer = new Date().addMinutes(constants.Misc.CLOCK_BUFFER);\n\n  if (isResourceSpecific && nowPlusBuffer.isAfter(expiryDate)) {\n    this._log.info('Cached token is expired.  Refreshing: ' + expiryDate);\n\n    this._refreshExpiredEntry(entry, callback);\n\n    return;\n  } else if (!isResourceSpecific && entry.isMRRT) {\n    this._log.info('Acquiring new access token from MRRT token.');\n\n    this._acquireNewTokenFromMrrt(entry, callback);\n\n    return;\n  } else {\n    callback(null, entry);\n  }\n};\n/**\r\n * Finds a single entry in the cache that matches the query or fails if more than one match is found.\r\n * @param  {object}   query    A query object\r\n * @param  {SingleEntryCallback} callback\r\n */\n\n\nCacheDriver.prototype.find = function (query, callback) {\n  var self = this;\n  query = query || {};\n\n  this._log.verbose('finding using query');\n\n  this._log.verbose('finding with query:' + JSON.stringify(query), true);\n\n  this._loadSingleEntryFromCache(query, function (err, entry, isResourceTenantSpecific) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (!entry) {\n      callback();\n      return;\n    }\n\n    self._refreshEntryIfNecessary(entry, isResourceTenantSpecific, function (err, newEntry) {\n      callback(err, newEntry);\n      return;\n    });\n  });\n};\n/**\r\n * Removes a single entry from the cache.\r\n * @param  {object}   entry    The entry to remove.\r\n * @param  {Function} callback Called on completion.  The first parameter may contain an error.\r\n */\n\n\nCacheDriver.prototype.remove = function (entry, callback) {\n  this._log.verbose('Removing entry.');\n\n  return this._cache.remove([entry], function (err) {\n    callback(err);\n    return;\n  });\n};\n/**\r\n * Removes a collection of entries from the cache in a single batch operation.\r\n * @param  {Array}   entries  An array of cache entries to remove.\r\n * @param  {Function} callback This function is called when the operation is complete.  Any error is provided as the\r\n *                             first parameter.\r\n */\n\n\nCacheDriver.prototype._removeMany = function (entries, callback) {\n  this._log.verbose('Remove many: ' + entries.length);\n\n  this._cache.remove(entries, function (err) {\n    callback(err);\n    return;\n  });\n};\n/**\r\n * Adds a collection of entries to the cache in a single batch operation.\r\n * @param {Array}   entries  An array of entries to add to the cache.\r\n * @param  {Function} callback This function is called when the operation is complete.  Any error is provided as the\r\n *                             first parameter.\r\n */\n\n\nCacheDriver.prototype._addMany = function (entries, callback) {\n  this._log.verbose('Add many: ' + entries.length);\n\n  this._cache.add(entries, function (err) {\n    callback(err);\n    return;\n  });\n};\n/*\r\n * Tests whether the passed entry is a multi resource refresh token.\r\n * Somewhat mysteriously the presense of a resource field in a returned\r\n * token response indicates that the response is an MRRT.\r\n * @param  {object}  entry\r\n * @return {Boolean}       true if the entry is an MRRT.\r\n */\n\n\nfunction isMRRT(entry) {\n  return entry.resource ? true : false;\n}\n/**\r\n * Given an cache entry this function finds all of the MRRT tokens already in the cache\r\n * and updates them with the refresh_token of the passed in entry.\r\n * @param  {object}   entry    The entry from which to get an updated refresh_token\r\n * @param  {Function} callback Called back on completion.  The first parameter may contain an error.\r\n */\n\n\nCacheDriver.prototype._updateRefreshTokens = function (entry, callback) {\n  var self = this;\n\n  if (isMRRT(entry)) {\n    this._findMRRTTokensForUser(entry.userId, function (err, mrrtTokens) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      if (!mrrtTokens || 0 === mrrtTokens.length) {\n        callback();\n        return;\n      }\n\n      self._log.verbose('Updating ' + mrrtTokens.length + ' cached refresh tokens.');\n\n      self._removeMany(mrrtTokens, function (err) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        for (var i = 0; i < mrrtTokens.length; i++) {\n          mrrtTokens[i][TokenResponseFields.REFRESH_TOKEN] = entry[TokenResponseFields.REFRESH_TOKEN];\n        }\n\n        self._addMany(mrrtTokens, function (err) {\n          callback(err);\n          return;\n        });\n      });\n    });\n  } else {\n    callback();\n    return;\n  }\n};\n/**\r\n * Checks to see if the entry has cache metadata already.  If it does\r\n * then it probably came from a refresh operation and the metadata\r\n * was copied from the originating entry.\r\n * @param  {object} entry The entry to check\r\n * @return {bool}         Returns true if the entry has already been augmented\r\n *                        with cache metadata.\r\n */\n\n\nCacheDriver.prototype._entryHasMetadata = function (entry) {\n  return _.has(entry, METADATA_CLIENTID) && _.has(entry, METADATA_AUTHORITY);\n};\n\nCacheDriver.prototype._augmentEntryWithCacheMetadata = function (entry) {\n  if (this._entryHasMetadata(entry)) {\n    return;\n  }\n\n  if (isMRRT(entry)) {\n    this._log.verbose('Added entry is MRRT');\n\n    entry.isMRRT = true;\n  } else {\n    entry.resource = this._resource;\n  }\n\n  entry[METADATA_CLIENTID] = this._clientId;\n  entry[METADATA_AUTHORITY] = this._authority;\n};\n/**\r\n * Adds a single entry to the cache.\r\n * @param {object}   entry    The entry to add.\r\n * @param {string}   clientId The id of this client app.\r\n * @param {string}   resource The id of the resource for which the cached token was obtained.\r\n * @param {Function} callback Called back on completion.  The first parameter may contain an error.\r\n */\n\n\nCacheDriver.prototype.add = function (entry, callback) {\n  var self = this;\n\n  this._log.verbose('Adding entry');\n\n  this._log.verbose('Adding entry, ' + createTokenIdMessage(entry));\n\n  this._augmentEntryWithCacheMetadata(entry);\n\n  this._updateRefreshTokens(entry, function (err) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    self._cache.add([entry], function (err) {\n      callback(err);\n      return;\n    });\n  });\n};\n\nmodule.exports = CacheDriver;","map":null,"metadata":{},"sourceType":"script"}