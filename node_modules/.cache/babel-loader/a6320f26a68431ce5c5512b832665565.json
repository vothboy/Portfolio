{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nimport { __assign, __spreadArrays } from \"tslib\";\nimport { isTokenCredential } from \"@azure/core-auth\";\nimport { DefaultHttpClient } from \"./defaultHttpClient\";\nimport { getPathStringFromParameter, getPathStringFromParameterPath } from \"./operationParameter\";\nimport { isStreamOperation } from \"./operationSpec\";\nimport { deserializationPolicy } from \"./policies/deserializationPolicy\";\nimport { exponentialRetryPolicy } from \"./policies/exponentialRetryPolicy\";\nimport { generateClientRequestIdPolicy } from \"./policies/generateClientRequestIdPolicy\";\nimport { userAgentPolicy, getDefaultUserAgentHeaderName, getDefaultUserAgentValue } from \"./policies/userAgentPolicy\";\nimport { redirectPolicy } from \"./policies/redirectPolicy\";\nimport { RequestPolicyOptions } from \"./policies/requestPolicy\";\nimport { rpRegistrationPolicy } from \"./policies/rpRegistrationPolicy\";\nimport { signingPolicy } from \"./policies/signingPolicy\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { QueryCollectionFormat } from \"./queryCollectionFormat\";\nimport { MapperType } from \"./serializer\";\nimport { URLBuilder } from \"./url\";\nimport * as utils from \"./util/utils\";\nimport { stringifyXML } from \"./util/xml\";\nimport { WebResource } from \"./webResource\";\nimport { agentPolicy } from \"./policies/agentPolicy\";\nimport { proxyPolicy, getDefaultProxySettings } from \"./policies/proxyPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { AzureIdentityCredentialAdapter } from \"./credentials/azureIdentityTokenCredentialAdapter\";\n/**\n * @class\n * Initializes a new instance of the ServiceClient.\n */\n\nvar ServiceClient =\n/** @class */\nfunction () {\n  /**\n   * The ServiceClient constructor\n   * @constructor\n   * @param {ServiceClientCredentials} [credentials] The credentials object used for authentication.\n   * @param {ServiceClientOptions} [options] The service client options that govern the behavior of the client.\n   */\n  function ServiceClient(credentials, options) {\n    if (!options) {\n      options = {};\n    }\n\n    var serviceClientCredentials;\n\n    if (isTokenCredential(credentials)) {\n      serviceClientCredentials = new AzureIdentityCredentialAdapter(credentials);\n    } else {\n      serviceClientCredentials = credentials;\n    }\n\n    if (serviceClientCredentials && !serviceClientCredentials.signRequest) {\n      throw new Error(\"credentials argument needs to implement signRequest method\");\n    }\n\n    this._withCredentials = options.withCredentials || false;\n    this._httpClient = options.httpClient || new DefaultHttpClient();\n    this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);\n    var requestPolicyFactories;\n\n    if (Array.isArray(options.requestPolicyFactories)) {\n      requestPolicyFactories = options.requestPolicyFactories;\n    } else {\n      requestPolicyFactories = createDefaultRequestPolicyFactories(serviceClientCredentials, options);\n\n      if (options.requestPolicyFactories) {\n        var newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);\n\n        if (newRequestPolicyFactories) {\n          requestPolicyFactories = newRequestPolicyFactories;\n        }\n      }\n    }\n\n    this._requestPolicyFactories = requestPolicyFactories;\n  }\n  /**\n   * Send the provided httpRequest.\n   */\n\n\n  ServiceClient.prototype.sendRequest = function (options) {\n    if (options === null || options === undefined || typeof options !== \"object\") {\n      throw new Error(\"options cannot be null or undefined and it must be of type object.\");\n    }\n\n    var httpRequest;\n\n    try {\n      if (options instanceof WebResource) {\n        options.validateRequestProperties();\n        httpRequest = options;\n      } else {\n        httpRequest = new WebResource();\n        httpRequest = httpRequest.prepare(options);\n      }\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    var httpPipeline = this._httpClient;\n\n    if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) {\n      for (var i = this._requestPolicyFactories.length - 1; i >= 0; --i) {\n        httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);\n      }\n    }\n\n    return httpPipeline.sendRequest(httpRequest);\n  };\n  /**\n   * Send an HTTP request that is populated using the provided OperationSpec.\n   * @param {OperationArguments} operationArguments The arguments that the HTTP request's templated values will be populated from.\n   * @param {OperationSpec} operationSpec The OperationSpec to use to populate the httpRequest.\n   * @param {ServiceCallback} callback The callback to call when the response is received.\n   */\n\n\n  ServiceClient.prototype.sendOperationRequest = function (operationArguments, operationSpec, callback) {\n    if (typeof operationArguments.options === \"function\") {\n      callback = operationArguments.options;\n      operationArguments.options = undefined;\n    }\n\n    var httpRequest = new WebResource();\n    var result;\n\n    try {\n      var baseUri = operationSpec.baseUrl || this.baseUri;\n\n      if (!baseUri) {\n        throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.\");\n      }\n\n      httpRequest.method = operationSpec.httpMethod;\n      httpRequest.operationSpec = operationSpec;\n      var requestUrl = URLBuilder.parse(baseUri);\n\n      if (operationSpec.path) {\n        requestUrl.appendPath(operationSpec.path);\n      }\n\n      if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) {\n        for (var _i = 0, _a = operationSpec.urlParameters; _i < _a.length; _i++) {\n          var urlParameter = _a[_i];\n          var urlParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, urlParameter, operationSpec.serializer);\n          urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, getPathStringFromParameter(urlParameter));\n\n          if (!urlParameter.skipEncoding) {\n            urlParameterValue = encodeURIComponent(urlParameterValue);\n          }\n\n          requestUrl.replaceAll(\"{\" + (urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)) + \"}\", urlParameterValue);\n        }\n      }\n\n      if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) {\n        for (var _b = 0, _c = operationSpec.queryParameters; _b < _c.length; _b++) {\n          var queryParameter = _c[_b];\n          var queryParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, queryParameter, operationSpec.serializer);\n\n          if (queryParameterValue != undefined) {\n            queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));\n\n            if (queryParameter.collectionFormat != undefined) {\n              if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {\n                if (queryParameterValue.length === 0) {\n                  queryParameterValue = \"\";\n                } else {\n                  for (var index in queryParameterValue) {\n                    var item = queryParameterValue[index];\n                    queryParameterValue[index] = item == undefined ? \"\" : item.toString();\n                  }\n                }\n              } else {\n                queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);\n              }\n            }\n\n            if (!queryParameter.skipEncoding) {\n              if (Array.isArray(queryParameterValue)) {\n                for (var index in queryParameterValue) {\n                  queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);\n                }\n              } else {\n                queryParameterValue = encodeURIComponent(queryParameterValue);\n              }\n            }\n\n            requestUrl.setQueryParameter(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n          }\n        }\n      }\n\n      httpRequest.url = requestUrl.toString();\n      var contentType = operationSpec.contentType || this.requestContentType;\n\n      if (contentType) {\n        httpRequest.headers.set(\"Content-Type\", contentType);\n      }\n\n      if (operationSpec.headerParameters) {\n        for (var _d = 0, _e = operationSpec.headerParameters; _d < _e.length; _d++) {\n          var headerParameter = _e[_d];\n          var headerValue = getOperationArgumentValueFromParameter(this, operationArguments, headerParameter, operationSpec.serializer);\n\n          if (headerValue != undefined) {\n            headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));\n            var headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;\n\n            if (headerCollectionPrefix) {\n              for (var _f = 0, _g = Object.keys(headerValue); _f < _g.length; _f++) {\n                var key = _g[_f];\n                httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);\n              }\n            } else {\n              httpRequest.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n            }\n          }\n        }\n      }\n\n      var options = operationArguments.options;\n\n      if (options) {\n        if (options.customHeaders) {\n          for (var customHeaderName in options.customHeaders) {\n            httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);\n          }\n        }\n\n        if (options.abortSignal) {\n          httpRequest.abortSignal = options.abortSignal;\n        }\n\n        if (options.timeout) {\n          httpRequest.timeout = options.timeout;\n        }\n\n        if (options.onUploadProgress) {\n          httpRequest.onUploadProgress = options.onUploadProgress;\n        }\n\n        if (options.onDownloadProgress) {\n          httpRequest.onDownloadProgress = options.onDownloadProgress;\n        }\n      }\n\n      httpRequest.withCredentials = this._withCredentials;\n      serializeRequestBody(this, httpRequest, operationArguments, operationSpec);\n\n      if (httpRequest.streamResponseBody == undefined) {\n        httpRequest.streamResponseBody = isStreamOperation(operationSpec);\n      }\n\n      result = this.sendRequest(httpRequest).then(function (res) {\n        return flattenResponse(res, operationSpec.responses[res.status]);\n      });\n    } catch (error) {\n      result = Promise.reject(error);\n    }\n\n    var cb = callback;\n\n    if (cb) {\n      result // tslint:disable-next-line:no-null-keyword\n      .then(function (res) {\n        return cb(null, res._response.parsedBody, res._response.request, res._response);\n      }).catch(function (err) {\n        return cb(err);\n      });\n    }\n\n    return result;\n  };\n\n  return ServiceClient;\n}();\n\nexport { ServiceClient };\nexport function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {\n  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n    httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);\n    var bodyMapper = operationSpec.requestBody.mapper;\n    var required = bodyMapper.required,\n        xmlName = bodyMapper.xmlName,\n        xmlElementName = bodyMapper.xmlElementName,\n        serializedName = bodyMapper.serializedName;\n    var typeName = bodyMapper.type.name;\n\n    try {\n      if (httpRequest.body != undefined || required) {\n        var requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n        httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString);\n        var isStream = typeName === MapperType.Stream;\n\n        if (operationSpec.isXML) {\n          if (typeName === MapperType.Sequence) {\n            httpRequest.body = stringifyXML(utils.prepareXMLRootList(httpRequest.body, xmlElementName || xmlName || serializedName), {\n              rootName: xmlName || serializedName\n            });\n          } else if (!isStream) {\n            httpRequest.body = stringifyXML(httpRequest.body, {\n              rootName: xmlName || serializedName\n            });\n          }\n        } else if (!isStream) {\n          httpRequest.body = JSON.stringify(httpRequest.body);\n        }\n      }\n    } catch (error) {\n      throw new Error(\"Error \\\"\" + error.message + \"\\\" occurred in serializing the payload - \" + JSON.stringify(serializedName, undefined, \"  \") + \".\");\n    }\n  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n    httpRequest.formData = {};\n\n    for (var _i = 0, _a = operationSpec.formDataParameters; _i < _a.length; _i++) {\n      var formDataParameter = _a[_i];\n      var formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);\n\n      if (formDataParameterValue != undefined) {\n        var formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n        httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter));\n      }\n    }\n  }\n}\n\nfunction isRequestPolicyFactory(instance) {\n  return typeof instance.create === \"function\";\n}\n\nfunction getValueOrFunctionResult(value, defaultValueCreator) {\n  var result;\n\n  if (typeof value === \"string\") {\n    result = value;\n  } else {\n    result = defaultValueCreator();\n\n    if (typeof value === \"function\") {\n      result = value(result);\n    }\n  }\n\n  return result;\n}\n\nfunction createDefaultRequestPolicyFactories(credentials, options) {\n  var factories = [];\n\n  if (options.generateClientRequestIdHeader) {\n    factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));\n  }\n\n  if (credentials) {\n    if (isRequestPolicyFactory(credentials)) {\n      factories.push(credentials);\n    } else {\n      factories.push(signingPolicy(credentials));\n    }\n  }\n\n  var userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, getDefaultUserAgentHeaderName);\n  var userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, getDefaultUserAgentValue);\n\n  if (userAgentHeaderName && userAgentHeaderValue) {\n    factories.push(userAgentPolicy({\n      key: userAgentHeaderName,\n      value: userAgentHeaderValue\n    }));\n  }\n\n  factories.push(redirectPolicy());\n  factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));\n\n  if (!options.noRetryPolicy) {\n    factories.push(exponentialRetryPolicy());\n    factories.push(systemErrorRetryPolicy());\n    factories.push(throttlingRetryPolicy());\n  }\n\n  factories.push(deserializationPolicy(options.deserializationContentTypes));\n  var proxySettings = options.proxySettings || getDefaultProxySettings();\n\n  if (proxySettings) {\n    factories.push(proxyPolicy(proxySettings));\n  }\n\n  if (options.agentSettings) {\n    factories.push(agentPolicy(options.agentSettings));\n  }\n\n  return factories;\n}\n/**\n * Get the property parent for the property at the provided path when starting with the provided\n * parent object.\n */\n\n\nexport function getPropertyParent(parent, propertyPath) {\n  if (parent && propertyPath) {\n    var propertyPathLength = propertyPath.length;\n\n    for (var i = 0; i < propertyPathLength - 1; ++i) {\n      var propertyName = propertyPath[i];\n\n      if (!parent[propertyName]) {\n        parent[propertyName] = {};\n      }\n\n      parent = parent[propertyName];\n    }\n  }\n\n  return parent;\n}\n\nfunction getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer) {\n  return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer);\n}\n\nexport function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer) {\n  var value;\n\n  if (typeof parameterPath === \"string\") {\n    parameterPath = [parameterPath];\n  }\n\n  if (Array.isArray(parameterPath)) {\n    if (parameterPath.length > 0) {\n      if (parameterMapper.isConstant) {\n        value = parameterMapper.defaultValue;\n      } else {\n        var propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);\n\n        if (!propertySearchResult.propertyFound) {\n          propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);\n        }\n\n        var useDefaultValue = false;\n\n        if (!propertySearchResult.propertyFound) {\n          useDefaultValue = parameterMapper.required || parameterPath[0] === \"options\" && parameterPath.length === 2;\n        }\n\n        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n      } // Serialize just for validation purposes.\n\n\n      var parameterPathString = getPathStringFromParameterPath(parameterPath, parameterMapper);\n      serializer.serialize(parameterMapper, value, parameterPathString);\n    }\n  } else {\n    if (parameterMapper.required) {\n      value = {};\n    }\n\n    for (var propertyName in parameterPath) {\n      var propertyMapper = parameterMapper.type.modelProperties[propertyName];\n      var propertyPath = parameterPath[propertyName];\n      var propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer); // Serialize just for validation purposes.\n\n      var propertyPathString = getPathStringFromParameterPath(propertyPath, propertyMapper);\n      serializer.serialize(propertyMapper, propertyValue, propertyPathString);\n\n      if (propertyValue !== undefined) {\n        if (!value) {\n          value = {};\n        }\n\n        value[propertyName] = propertyValue;\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction getPropertyFromParameterPath(parent, parameterPath) {\n  var result = {\n    propertyFound: false\n  };\n  var i = 0;\n\n  for (; i < parameterPath.length; ++i) {\n    var parameterPathPart = parameterPath[i]; // Make sure to check inherited properties too, so don't use hasOwnProperty().\n\n    if (parent != undefined && parameterPathPart in parent) {\n      parent = parent[parameterPathPart];\n    } else {\n      break;\n    }\n  }\n\n  if (i === parameterPath.length) {\n    result.propertyValue = parent;\n    result.propertyFound = true;\n  }\n\n  return result;\n}\n\nexport function flattenResponse(_response, responseSpec) {\n  var parsedHeaders = _response.parsedHeaders;\n  var bodyMapper = responseSpec && responseSpec.bodyMapper;\n\n  var addOperationResponse = function addOperationResponse(obj) {\n    return Object.defineProperty(obj, \"_response\", {\n      value: _response\n    });\n  };\n\n  if (bodyMapper) {\n    var typeName = bodyMapper.type.name;\n\n    if (typeName === \"Stream\") {\n      return addOperationResponse(__assign(__assign({}, parsedHeaders), {\n        blobBody: _response.blobBody,\n        readableStreamBody: _response.readableStreamBody\n      }));\n    }\n\n    var modelProperties_1 = typeName === \"Composite\" && bodyMapper.type.modelProperties || {};\n    var isPageableResponse = Object.keys(modelProperties_1).some(function (k) {\n      return modelProperties_1[k].serializedName === \"\";\n    });\n\n    if (typeName === \"Sequence\" || isPageableResponse) {\n      // We're expecting a sequence(array) make sure that the response body is in the\n      // correct format, if not make it an empty array []\n      var parsedBody = Array.isArray(_response.parsedBody) ? _response.parsedBody : [];\n\n      var arrayResponse = __spreadArrays(parsedBody);\n\n      for (var _i = 0, _a = Object.keys(modelProperties_1); _i < _a.length; _i++) {\n        var key = _a[_i];\n\n        if (modelProperties_1[key].serializedName) {\n          arrayResponse[key] = _response.parsedBody[key];\n        }\n      }\n\n      if (parsedHeaders) {\n        for (var _b = 0, _c = Object.keys(parsedHeaders); _b < _c.length; _b++) {\n          var key = _c[_b];\n          arrayResponse[key] = parsedHeaders[key];\n        }\n      }\n\n      addOperationResponse(arrayResponse);\n      return arrayResponse;\n    }\n\n    if (typeName === \"Composite\" || typeName === \"Dictionary\") {\n      return addOperationResponse(__assign(__assign({}, parsedHeaders), _response.parsedBody));\n    }\n  }\n\n  if (bodyMapper || _response.request.method === \"HEAD\") {\n    // primitive body types and HEAD booleans\n    return addOperationResponse(__assign(__assign({}, parsedHeaders), {\n      body: _response.parsedBody\n    }));\n  }\n\n  return addOperationResponse(__assign(__assign({}, parsedHeaders), _response.parsedBody));\n}","map":null,"metadata":{},"sourceType":"module"}