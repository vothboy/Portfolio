{"ast":null,"code":"/*\r\n * xpath.js\r\n *\r\n * An XPath 1.0 library for JavaScript.\r\n *\r\n * Cameron McCormack <cam (at) mcc.id.au>\r\n *\r\n *\r\n * Revision 20: April 26, 2011\r\n *   Fixed a typo resulting in FIRST_ORDERED_NODE_TYPE results being wrong,\r\n *   thanks to <shi_a009 (at) hotmail.com>.\r\n *\r\n * Revision 19: November 29, 2005\r\n *   Nodesets now store their nodes in a height balanced tree, increasing\r\n *   performance for the common case of selecting nodes in document order,\r\n *   thanks to Sébastien Cramatte <contact (at) zeninteractif.com>.\r\n *   AVL tree code adapted from Raimund Neumann <rnova (at) gmx.net>.\r\n *\r\n * Revision 18: October 27, 2005\r\n *   DOM 3 XPath support.  Caveats:\r\n *     - namespace prefixes aren't resolved in XPathEvaluator.createExpression,\r\n *       but in XPathExpression.evaluate.\r\n *     - XPathResult.invalidIteratorState is not implemented.\r\n *\r\n * Revision 17: October 25, 2005\r\n *   Some core XPath function fixes and a patch to avoid crashing certain\r\n *   versions of MSXML in PathExpr.prototype.getOwnerElement, thanks to\r\n *   Sébastien Cramatte <contact (at) zeninteractif.com>.\r\n *\r\n * Revision 16: September 22, 2005\r\n *   Workarounds for some IE 5.5 deficiencies.\r\n *   Fixed problem with prefix node tests on attribute nodes.\r\n *\r\n * Revision 15: May 21, 2005\r\n *   Fixed problem with QName node tests on elements with an xmlns=\"...\".\r\n *\r\n * Revision 14: May 19, 2005\r\n *   Fixed QName node tests on attribute node regression.\r\n *\r\n * Revision 13: May 3, 2005\r\n *   Node tests are case insensitive now if working in an HTML DOM.\r\n *\r\n * Revision 12: April 26, 2005\r\n *   Updated licence.  Slight code changes to enable use of Dean\r\n *   Edwards' script compression, http://dean.edwards.name/packer/ .\r\n *\r\n * Revision 11: April 23, 2005\r\n *   Fixed bug with 'and' and 'or' operators, fix thanks to\r\n *   Sandy McArthur <sandy (at) mcarthur.org>.\r\n *\r\n * Revision 10: April 15, 2005\r\n *   Added support for a virtual root node, supposedly helpful for\r\n *   implementing XForms.  Fixed problem with QName node tests and\r\n *   the parent axis.\r\n *\r\n * Revision 9: March 17, 2005\r\n *   Namespace resolver tweaked so using the document node as the context\r\n *   for namespace lookups is equivalent to using the document element.\r\n *\r\n * Revision 8: February 13, 2005\r\n *   Handle implicit declaration of 'xmlns' namespace prefix.\r\n *   Fixed bug when comparing nodesets.\r\n *   Instance data can now be associated with a FunctionResolver, and\r\n *     workaround for MSXML not supporting 'localName' and 'getElementById',\r\n *     thanks to Grant Gongaware.\r\n *   Fix a few problems when the context node is the root node.\r\n *   \r\n * Revision 7: February 11, 2005\r\n *   Default namespace resolver fix from Grant Gongaware\r\n *   <grant (at) gongaware.com>.\r\n *\r\n * Revision 6: February 10, 2005\r\n *   Fixed bug in 'number' function.\r\n *\r\n * Revision 5: February 9, 2005\r\n *   Fixed bug where text nodes not getting converted to string values.\r\n *\r\n * Revision 4: January 21, 2005\r\n *   Bug in 'name' function, fix thanks to Bill Edney.\r\n *   Fixed incorrect processing of namespace nodes.\r\n *   Fixed NamespaceResolver to resolve 'xml' namespace.\r\n *   Implemented union '|' operator.\r\n *\r\n * Revision 3: January 14, 2005\r\n *   Fixed bug with nodeset comparisons, bug lexing < and >.\r\n *\r\n * Revision 2: October 26, 2004\r\n *   QName node test namespace handling fixed.  Few other bug fixes.\r\n *   \r\n * Revision 1: August 13, 2004\r\n *   Bug fixes from William J. Edney <bedney (at) technicalpursuit.com>.\r\n *   Added minimal licence.\r\n *\r\n * Initial version: June 14, 2004\r\n */\n// XPathParser ///////////////////////////////////////////////////////////////\nXPathParser.prototype = new Object();\nXPathParser.prototype.constructor = XPathParser;\nXPathParser.superclass = Object.prototype;\n\nfunction XPathParser() {\n  this.init();\n}\n\nXPathParser.prototype.init = function () {\n  this.reduceActions = [];\n\n  this.reduceActions[3] = function (rhs) {\n    return new OrOperation(rhs[0], rhs[2]);\n  };\n\n  this.reduceActions[5] = function (rhs) {\n    return new AndOperation(rhs[0], rhs[2]);\n  };\n\n  this.reduceActions[7] = function (rhs) {\n    return new EqualsOperation(rhs[0], rhs[2]);\n  };\n\n  this.reduceActions[8] = function (rhs) {\n    return new NotEqualOperation(rhs[0], rhs[2]);\n  };\n\n  this.reduceActions[10] = function (rhs) {\n    return new LessThanOperation(rhs[0], rhs[2]);\n  };\n\n  this.reduceActions[11] = function (rhs) {\n    return new GreaterThanOperation(rhs[0], rhs[2]);\n  };\n\n  this.reduceActions[12] = function (rhs) {\n    return new LessThanOrEqualOperation(rhs[0], rhs[2]);\n  };\n\n  this.reduceActions[13] = function (rhs) {\n    return new GreaterThanOrEqualOperation(rhs[0], rhs[2]);\n  };\n\n  this.reduceActions[15] = function (rhs) {\n    return new PlusOperation(rhs[0], rhs[2]);\n  };\n\n  this.reduceActions[16] = function (rhs) {\n    return new MinusOperation(rhs[0], rhs[2]);\n  };\n\n  this.reduceActions[18] = function (rhs) {\n    return new MultiplyOperation(rhs[0], rhs[2]);\n  };\n\n  this.reduceActions[19] = function (rhs) {\n    return new DivOperation(rhs[0], rhs[2]);\n  };\n\n  this.reduceActions[20] = function (rhs) {\n    return new ModOperation(rhs[0], rhs[2]);\n  };\n\n  this.reduceActions[22] = function (rhs) {\n    return new UnaryMinusOperation(rhs[1]);\n  };\n\n  this.reduceActions[24] = function (rhs) {\n    return new BarOperation(rhs[0], rhs[2]);\n  };\n\n  this.reduceActions[25] = function (rhs) {\n    return new PathExpr(undefined, undefined, rhs[0]);\n  };\n\n  this.reduceActions[27] = function (rhs) {\n    rhs[0].locationPath = rhs[2];\n    return rhs[0];\n  };\n\n  this.reduceActions[28] = function (rhs) {\n    rhs[0].locationPath = rhs[2];\n    rhs[0].locationPath.steps.unshift(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));\n    return rhs[0];\n  };\n\n  this.reduceActions[29] = function (rhs) {\n    return new PathExpr(rhs[0], [], undefined);\n  };\n\n  this.reduceActions[30] = function (rhs) {\n    if (Utilities.instance_of(rhs[0], PathExpr)) {\n      if (rhs[0].filterPredicates == undefined) {\n        rhs[0].filterPredicates = [];\n      }\n\n      rhs[0].filterPredicates.push(rhs[1]);\n      return rhs[0];\n    } else {\n      return new PathExpr(rhs[0], [rhs[1]], undefined);\n    }\n  };\n\n  this.reduceActions[32] = function (rhs) {\n    return rhs[1];\n  };\n\n  this.reduceActions[33] = function (rhs) {\n    return new XString(rhs[0]);\n  };\n\n  this.reduceActions[34] = function (rhs) {\n    return new XNumber(rhs[0]);\n  };\n\n  this.reduceActions[36] = function (rhs) {\n    return new FunctionCall(rhs[0], []);\n  };\n\n  this.reduceActions[37] = function (rhs) {\n    return new FunctionCall(rhs[0], rhs[2]);\n  };\n\n  this.reduceActions[38] = function (rhs) {\n    return [rhs[0]];\n  };\n\n  this.reduceActions[39] = function (rhs) {\n    rhs[2].unshift(rhs[0]);\n    return rhs[2];\n  };\n\n  this.reduceActions[43] = function (rhs) {\n    return new LocationPath(true, []);\n  };\n\n  this.reduceActions[44] = function (rhs) {\n    rhs[1].absolute = true;\n    return rhs[1];\n  };\n\n  this.reduceActions[46] = function (rhs) {\n    return new LocationPath(false, [rhs[0]]);\n  };\n\n  this.reduceActions[47] = function (rhs) {\n    rhs[0].steps.push(rhs[2]);\n    return rhs[0];\n  };\n\n  this.reduceActions[49] = function (rhs) {\n    return new Step(rhs[0], rhs[1], []);\n  };\n\n  this.reduceActions[50] = function (rhs) {\n    return new Step(Step.CHILD, rhs[0], []);\n  };\n\n  this.reduceActions[51] = function (rhs) {\n    return new Step(rhs[0], rhs[1], rhs[2]);\n  };\n\n  this.reduceActions[52] = function (rhs) {\n    return new Step(Step.CHILD, rhs[0], rhs[1]);\n  };\n\n  this.reduceActions[54] = function (rhs) {\n    return [rhs[0]];\n  };\n\n  this.reduceActions[55] = function (rhs) {\n    rhs[1].unshift(rhs[0]);\n    return rhs[1];\n  };\n\n  this.reduceActions[56] = function (rhs) {\n    if (rhs[0] == \"ancestor\") {\n      return Step.ANCESTOR;\n    } else if (rhs[0] == \"ancestor-or-self\") {\n      return Step.ANCESTORORSELF;\n    } else if (rhs[0] == \"attribute\") {\n      return Step.ATTRIBUTE;\n    } else if (rhs[0] == \"child\") {\n      return Step.CHILD;\n    } else if (rhs[0] == \"descendant\") {\n      return Step.DESCENDANT;\n    } else if (rhs[0] == \"descendant-or-self\") {\n      return Step.DESCENDANTORSELF;\n    } else if (rhs[0] == \"following\") {\n      return Step.FOLLOWING;\n    } else if (rhs[0] == \"following-sibling\") {\n      return Step.FOLLOWINGSIBLING;\n    } else if (rhs[0] == \"namespace\") {\n      return Step.NAMESPACE;\n    } else if (rhs[0] == \"parent\") {\n      return Step.PARENT;\n    } else if (rhs[0] == \"preceding\") {\n      return Step.PRECEDING;\n    } else if (rhs[0] == \"preceding-sibling\") {\n      return Step.PRECEDINGSIBLING;\n    } else if (rhs[0] == \"self\") {\n      return Step.SELF;\n    }\n\n    return -1;\n  };\n\n  this.reduceActions[57] = function (rhs) {\n    return Step.ATTRIBUTE;\n  };\n\n  this.reduceActions[59] = function (rhs) {\n    if (rhs[0] == \"comment\") {\n      return new NodeTest(NodeTest.COMMENT, undefined);\n    } else if (rhs[0] == \"text\") {\n      return new NodeTest(NodeTest.TEXT, undefined);\n    } else if (rhs[0] == \"processing-instruction\") {\n      return new NodeTest(NodeTest.PI, undefined);\n    } else if (rhs[0] == \"node\") {\n      return new NodeTest(NodeTest.NODE, undefined);\n    }\n\n    return new NodeTest(-1, undefined);\n  };\n\n  this.reduceActions[60] = function (rhs) {\n    return new NodeTest(NodeTest.PI, rhs[2]);\n  };\n\n  this.reduceActions[61] = function (rhs) {\n    return rhs[1];\n  };\n\n  this.reduceActions[63] = function (rhs) {\n    rhs[1].absolute = true;\n    rhs[1].steps.unshift(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));\n    return rhs[1];\n  };\n\n  this.reduceActions[64] = function (rhs) {\n    rhs[0].steps.push(new Step(Step.DESCENDANTORSELF, new NodeTest(NodeTest.NODE, undefined), []));\n    rhs[0].steps.push(rhs[2]);\n    return rhs[0];\n  };\n\n  this.reduceActions[65] = function (rhs) {\n    return new Step(Step.SELF, new NodeTest(NodeTest.NODE, undefined), []);\n  };\n\n  this.reduceActions[66] = function (rhs) {\n    return new Step(Step.PARENT, new NodeTest(NodeTest.NODE, undefined), []);\n  };\n\n  this.reduceActions[67] = function (rhs) {\n    return new VariableReference(rhs[1]);\n  };\n\n  this.reduceActions[68] = function (rhs) {\n    return new NodeTest(NodeTest.NAMETESTANY, undefined);\n  };\n\n  this.reduceActions[69] = function (rhs) {\n    var prefix = rhs[0].substring(0, rhs[0].indexOf(\":\"));\n    return new NodeTest(NodeTest.NAMETESTPREFIXANY, prefix);\n  };\n\n  this.reduceActions[70] = function (rhs) {\n    return new NodeTest(NodeTest.NAMETESTQNAME, rhs[0]);\n  };\n};\n\nXPathParser.actionTable = [\" s s        sssssssss    s ss  s  ss\", \"                 s                  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"                rrrrr               \", \" s s        sssssssss    s ss  s  ss\", \"rs  rrrrrrrr s  sssssrrrrrr  rrs rs \", \" s s        sssssssss    s ss  s  ss\", \"                            s       \", \"                            s       \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"  s                                 \", \"                            s       \", \" s           s  sssss          s  s \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"a                                   \", \"r       s                    rr  r  \", \"r      sr                    rr  r  \", \"r   s  rr            s       rr  r  \", \"r   rssrr            rss     rr  r  \", \"r   rrrrr            rrrss   rr  r  \", \"r   rrrrrsss         rrrrr   rr  r  \", \"r   rrrrrrrr         rrrrr   rr  r  \", \"r   rrrrrrrr         rrrrrs  rr  r  \", \"r   rrrrrrrr         rrrrrr  rr  r  \", \"r   rrrrrrrr         rrrrrr  rr  r  \", \"r  srrrrrrrr         rrrrrrs rr sr  \", \"r  srrrrrrrr         rrrrrrs rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r   rrrrrrrr         rrrrrr  rr  r  \", \"r   rrrrrrrr         rrrrrr  rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"                sssss               \", \"r  rrrrrrrrr         rrrrrrr rr sr  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"                             s      \", \"r  srrrrrrrr         rrrrrrs rr  r  \", \"r   rrrrrrrr         rrrrr   rr  r  \", \"              s                     \", \"                             s      \", \"                rrrrr               \", \" s s        sssssssss    s sss s  ss\", \"r  srrrrrrrr         rrrrrrs rr  r  \", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s s        sssssssss      ss  s  ss\", \" s s        sssssssss    s ss  s  ss\", \" s           s  sssss          s  s \", \" s           s  sssss          s  s \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \" s           s  sssss          s  s \", \" s           s  sssss          s  s \", \"r  rrrrrrrrr         rrrrrrr rr sr  \", \"r  rrrrrrrrr         rrrrrrr rr sr  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"                             s      \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"                             rr     \", \"                             s      \", \"                             rs     \", \"r      sr                    rr  r  \", \"r   s  rr            s       rr  r  \", \"r   rssrr            rss     rr  r  \", \"r   rssrr            rss     rr  r  \", \"r   rrrrr            rrrss   rr  r  \", \"r   rrrrr            rrrss   rr  r  \", \"r   rrrrr            rrrss   rr  r  \", \"r   rrrrr            rrrss   rr  r  \", \"r   rrrrrsss         rrrrr   rr  r  \", \"r   rrrrrsss         rrrrr   rr  r  \", \"r   rrrrrrrr         rrrrr   rr  r  \", \"r   rrrrrrrr         rrrrr   rr  r  \", \"r   rrrrrrrr         rrrrr   rr  r  \", \"r   rrrrrrrr         rrrrrr  rr  r  \", \"                                 r  \", \"                                 s  \", \"r  srrrrrrrr         rrrrrrs rr  r  \", \"r  srrrrrrrr         rrrrrrs rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr  r  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \" s s        sssssssss    s ss  s  ss\", \"r  rrrrrrrrr         rrrrrrr rr rr  \", \"                             r      \"];\nXPathParser.actionTableNumber = [\" 1 0        /.-,+*)('    & %$  #  \\\"!\", \"                 J                  \", \"a  aaaaaaaaa         aaaaaaa aa  a  \", \"                YYYYY               \", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \"K1  KKKKKKKK .  +*)('KKKKKK  KK# K\\\" \", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \"                            N       \", \"                            O       \", \"e  eeeeeeeee         eeeeeee ee ee  \", \"f  fffffffff         fffffff ff ff  \", \"d  ddddddddd         ddddddd dd dd  \", \"B  BBBBBBBBB         BBBBBBB BB BB  \", \"A  AAAAAAAAA         AAAAAAA AA AA  \", \"  P                                 \", \"                            Q       \", \" 1           .  +*)('          #  \\\" \", \"b  bbbbbbbbb         bbbbbbb bb  b  \", \"                                    \", \"!       S                    !!  !  \", \"\\\"      T\\\"                    \\\"\\\"  \\\"  \", \"$   V  $$            U       $$  $  \", \"&   &ZY&&            &XW     &&  &  \", \")   )))))            )))\\\\[   ))  )  \", \".   ....._^]         .....   ..  .  \", \"1   11111111         11111   11  1  \", \"5   55555555         55555`  55  5  \", \"7   77777777         777777  77  7  \", \"9   99999999         999999  99  9  \", \":  c::::::::         ::::::b :: a:  \", \"I  fIIIIIIII         IIIIIIe II  I  \", \"=  =========         ======= == ==  \", \"?  ?????????         ??????? ?? ??  \", \"C  CCCCCCCCC         CCCCCCC CC CC  \", \"J   JJJJJJJJ         JJJJJJ  JJ  J  \", \"M   MMMMMMMM         MMMMMM  MM  M  \", \"N  NNNNNNNNN         NNNNNNN NN  N  \", \"P  PPPPPPPPP         PPPPPPP PP  P  \", \"                +*)('               \", \"R  RRRRRRRRR         RRRRRRR RR aR  \", \"U  UUUUUUUUU         UUUUUUU UU  U  \", \"Z  ZZZZZZZZZ         ZZZZZZZ ZZ ZZ  \", \"c  ccccccccc         ccccccc cc cc  \", \"                             j      \", \"L  fLLLLLLLL         LLLLLLe LL  L  \", \"6   66666666         66666   66  6  \", \"              k                     \", \"                             l      \", \"                XXXXX               \", \" 1 0        /.-,+*)('    & %$m #  \\\"!\", \"_  f________         ______e __  _  \", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1 0        /.-,+*)('      %$  #  \\\"!\", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \" 1           .  +*)('          #  \\\" \", \" 1           .  +*)('          #  \\\" \", \">  >>>>>>>>>         >>>>>>> >> >>  \", \" 1           .  +*)('          #  \\\" \", \" 1           .  +*)('          #  \\\" \", \"Q  QQQQQQQQQ         QQQQQQQ QQ aQ  \", \"V  VVVVVVVVV         VVVVVVV VV aV  \", \"T  TTTTTTTTT         TTTTTTT TT  T  \", \"@  @@@@@@@@@         @@@@@@@ @@ @@  \", \"                             \\x87      \", \"[  [[[[[[[[[         [[[[[[[ [[ [[  \", \"D  DDDDDDDDD         DDDDDDD DD DD  \", \"                             HH     \", \"                             \\x88      \", \"                             F\\x89     \", \"#      T#                    ##  #  \", \"%   V  %%            U       %%  %  \", \"'   'ZY''            'XW     ''  '  \", \"(   (ZY((            (XW     ((  (  \", \"+   +++++            +++\\\\[   ++  +  \", \"*   *****            ***\\\\[   **  *  \", \"-   -----            ---\\\\[   --  -  \", \",   ,,,,,            ,,,\\\\[   ,,  ,  \", \"0   00000_^]         00000   00  0  \", \"/   /////_^]         /////   //  /  \", \"2   22222222         22222   22  2  \", \"3   33333333         33333   33  3  \", \"4   44444444         44444   44  4  \", \"8   88888888         888888  88  8  \", \"                                 ^  \", \"                                 \\x8a  \", \";  f;;;;;;;;         ;;;;;;e ;;  ;  \", \"<  f<<<<<<<<         <<<<<<e <<  <  \", \"O  OOOOOOOOO         OOOOOOO OO  O  \", \"`  `````````         ``````` ``  `  \", \"S  SSSSSSSSS         SSSSSSS SS  S  \", \"W  WWWWWWWWW         WWWWWWW WW  W  \", \"\\\\  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\         \\\\\\\\\\\\\\\\\\\\\\\\\\\\ \\\\\\\\ \\\\\\\\  \", \"E  EEEEEEEEE         EEEEEEE EE EE  \", \" 1 0        /.-,+*)('    & %$  #  \\\"!\", \"]  ]]]]]]]]]         ]]]]]]] ]] ]]  \", \"                             G      \"];\nXPathParser.gotoTable = [\"3456789:;<=>?@ AB  CDEFGH IJ \", \"                             \", \"                             \", \"                             \", \"L456789:;<=>?@ AB  CDEFGH IJ \", \"            M        EFGH IJ \", \"       N;<=>?@ AB  CDEFGH IJ \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"            S        EFGH IJ \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"              e              \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                        h  J \", \"              i          j   \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"o456789:;<=>?@ ABpqCDEFGH IJ \", \"                             \", \"  r6789:;<=>?@ AB  CDEFGH IJ \", \"   s789:;<=>?@ AB  CDEFGH IJ \", \"    t89:;<=>?@ AB  CDEFGH IJ \", \"    u89:;<=>?@ AB  CDEFGH IJ \", \"     v9:;<=>?@ AB  CDEFGH IJ \", \"     w9:;<=>?@ AB  CDEFGH IJ \", \"     x9:;<=>?@ AB  CDEFGH IJ \", \"     y9:;<=>?@ AB  CDEFGH IJ \", \"      z:;<=>?@ AB  CDEFGH IJ \", \"      {:;<=>?@ AB  CDEFGH IJ \", \"       |;<=>?@ AB  CDEFGH IJ \", \"       };<=>?@ AB  CDEFGH IJ \", \"       ~;<=>?@ AB  CDEFGH IJ \", \"         \\x7f=>?@ AB  CDEFGH IJ \", \"\\x80456789:;<=>?@ AB  CDEFGH IJ\\x81\", \"            \\x82        EFGH IJ \", \"            \\x83        EFGH IJ \", \"                             \", \"                     \\x84 GH IJ \", \"                     \\x85 GH IJ \", \"              i          \\x86   \", \"              i          \\x87   \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"                             \", \"o456789:;<=>?@ AB\\x8cqCDEFGH IJ \", \"                             \", \"                             \"];\nXPathParser.productions = [[1, 1, 2], [2, 1, 3], [3, 1, 4], [3, 3, 3, -9, 4], [4, 1, 5], [4, 3, 4, -8, 5], [5, 1, 6], [5, 3, 5, -22, 6], [5, 3, 5, -5, 6], [6, 1, 7], [6, 3, 6, -23, 7], [6, 3, 6, -24, 7], [6, 3, 6, -6, 7], [6, 3, 6, -7, 7], [7, 1, 8], [7, 3, 7, -25, 8], [7, 3, 7, -26, 8], [8, 1, 9], [8, 3, 8, -12, 9], [8, 3, 8, -11, 9], [8, 3, 8, -10, 9], [9, 1, 10], [9, 2, -26, 9], [10, 1, 11], [10, 3, 10, -27, 11], [11, 1, 12], [11, 1, 13], [11, 3, 13, -28, 14], [11, 3, 13, -4, 14], [13, 1, 15], [13, 2, 13, 16], [15, 1, 17], [15, 3, -29, 2, -30], [15, 1, -15], [15, 1, -16], [15, 1, 18], [18, 3, -13, -29, -30], [18, 4, -13, -29, 19, -30], [19, 1, 20], [19, 3, 20, -31, 19], [20, 1, 2], [12, 1, 14], [12, 1, 21], [21, 1, -28], [21, 2, -28, 14], [21, 1, 22], [14, 1, 23], [14, 3, 14, -28, 23], [14, 1, 24], [23, 2, 25, 26], [23, 1, 26], [23, 3, 25, 26, 27], [23, 2, 26, 27], [23, 1, 28], [27, 1, 16], [27, 2, 16, 27], [25, 2, -14, -3], [25, 1, -32], [26, 1, 29], [26, 3, -20, -29, -30], [26, 4, -21, -29, -15, -30], [16, 3, -33, 30, -34], [30, 1, 2], [22, 2, -4, 14], [24, 3, 14, -4, 23], [28, 1, -35], [28, 1, -2], [17, 2, -36, -18], [29, 1, -17], [29, 1, -19], [29, 1, -18]];\nXPathParser.DOUBLEDOT = 2;\nXPathParser.DOUBLECOLON = 3;\nXPathParser.DOUBLESLASH = 4;\nXPathParser.NOTEQUAL = 5;\nXPathParser.LESSTHANOREQUAL = 6;\nXPathParser.GREATERTHANOREQUAL = 7;\nXPathParser.AND = 8;\nXPathParser.OR = 9;\nXPathParser.MOD = 10;\nXPathParser.DIV = 11;\nXPathParser.MULTIPLYOPERATOR = 12;\nXPathParser.FUNCTIONNAME = 13;\nXPathParser.AXISNAME = 14;\nXPathParser.LITERAL = 15;\nXPathParser.NUMBER = 16;\nXPathParser.ASTERISKNAMETEST = 17;\nXPathParser.QNAME = 18;\nXPathParser.NCNAMECOLONASTERISK = 19;\nXPathParser.NODETYPE = 20;\nXPathParser.PROCESSINGINSTRUCTIONWITHLITERAL = 21;\nXPathParser.EQUALS = 22;\nXPathParser.LESSTHAN = 23;\nXPathParser.GREATERTHAN = 24;\nXPathParser.PLUS = 25;\nXPathParser.MINUS = 26;\nXPathParser.BAR = 27;\nXPathParser.SLASH = 28;\nXPathParser.LEFTPARENTHESIS = 29;\nXPathParser.RIGHTPARENTHESIS = 30;\nXPathParser.COMMA = 31;\nXPathParser.AT = 32;\nXPathParser.LEFTBRACKET = 33;\nXPathParser.RIGHTBRACKET = 34;\nXPathParser.DOT = 35;\nXPathParser.DOLLAR = 36;\n\nXPathParser.prototype.tokenize = function (s1) {\n  var types = [];\n  var values = [];\n  var s = s1 + '\\0';\n  var pos = 0;\n  var c = s.charAt(pos++);\n\n  while (1) {\n    while (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n') {\n      c = s.charAt(pos++);\n    }\n\n    if (c == '\\0' || pos >= s.length) {\n      break;\n    }\n\n    if (c == '(') {\n      types.push(XPathParser.LEFTPARENTHESIS);\n      values.push(c);\n      c = s.charAt(pos++);\n      continue;\n    }\n\n    if (c == ')') {\n      types.push(XPathParser.RIGHTPARENTHESIS);\n      values.push(c);\n      c = s.charAt(pos++);\n      continue;\n    }\n\n    if (c == '[') {\n      types.push(XPathParser.LEFTBRACKET);\n      values.push(c);\n      c = s.charAt(pos++);\n      continue;\n    }\n\n    if (c == ']') {\n      types.push(XPathParser.RIGHTBRACKET);\n      values.push(c);\n      c = s.charAt(pos++);\n      continue;\n    }\n\n    if (c == '@') {\n      types.push(XPathParser.AT);\n      values.push(c);\n      c = s.charAt(pos++);\n      continue;\n    }\n\n    if (c == ',') {\n      types.push(XPathParser.COMMA);\n      values.push(c);\n      c = s.charAt(pos++);\n      continue;\n    }\n\n    if (c == '|') {\n      types.push(XPathParser.BAR);\n      values.push(c);\n      c = s.charAt(pos++);\n      continue;\n    }\n\n    if (c == '+') {\n      types.push(XPathParser.PLUS);\n      values.push(c);\n      c = s.charAt(pos++);\n      continue;\n    }\n\n    if (c == '-') {\n      types.push(XPathParser.MINUS);\n      values.push(c);\n      c = s.charAt(pos++);\n      continue;\n    }\n\n    if (c == '=') {\n      types.push(XPathParser.EQUALS);\n      values.push(c);\n      c = s.charAt(pos++);\n      continue;\n    }\n\n    if (c == '$') {\n      types.push(XPathParser.DOLLAR);\n      values.push(c);\n      c = s.charAt(pos++);\n      continue;\n    }\n\n    if (c == '.') {\n      c = s.charAt(pos++);\n\n      if (c == '.') {\n        types.push(XPathParser.DOUBLEDOT);\n        values.push(\"..\");\n        c = s.charAt(pos++);\n        continue;\n      }\n\n      if (c >= '0' && c <= '9') {\n        var number = \".\" + c;\n        c = s.charAt(pos++);\n\n        while (c >= '0' && c <= '9') {\n          number += c;\n          c = s.charAt(pos++);\n        }\n\n        types.push(XPathParser.NUMBER);\n        values.push(number);\n        continue;\n      }\n\n      types.push(XPathParser.DOT);\n      values.push('.');\n      continue;\n    }\n\n    if (c == '\\'' || c == '\"') {\n      var delimiter = c;\n      var literal = \"\";\n\n      while ((c = s.charAt(pos++)) != delimiter) {\n        literal += c;\n      }\n\n      types.push(XPathParser.LITERAL);\n      values.push(literal);\n      c = s.charAt(pos++);\n      continue;\n    }\n\n    if (c >= '0' && c <= '9') {\n      var number = c;\n      c = s.charAt(pos++);\n\n      while (c >= '0' && c <= '9') {\n        number += c;\n        c = s.charAt(pos++);\n      }\n\n      if (c == '.') {\n        if (s.charAt(pos) >= '0' && s.charAt(pos) <= '9') {\n          number += c;\n          number += s.charAt(pos++);\n          c = s.charAt(pos++);\n\n          while (c >= '0' && c <= '9') {\n            number += c;\n            c = s.charAt(pos++);\n          }\n        }\n      }\n\n      types.push(XPathParser.NUMBER);\n      values.push(number);\n      continue;\n    }\n\n    if (c == '*') {\n      if (types.length > 0) {\n        var last = types[types.length - 1];\n\n        if (last != XPathParser.AT && last != XPathParser.DOUBLECOLON && last != XPathParser.LEFTPARENTHESIS && last != XPathParser.LEFTBRACKET && last != XPathParser.AND && last != XPathParser.OR && last != XPathParser.MOD && last != XPathParser.DIV && last != XPathParser.MULTIPLYOPERATOR && last != XPathParser.SLASH && last != XPathParser.DOUBLESLASH && last != XPathParser.BAR && last != XPathParser.PLUS && last != XPathParser.MINUS && last != XPathParser.EQUALS && last != XPathParser.NOTEQUAL && last != XPathParser.LESSTHAN && last != XPathParser.LESSTHANOREQUAL && last != XPathParser.GREATERTHAN && last != XPathParser.GREATERTHANOREQUAL) {\n          types.push(XPathParser.MULTIPLYOPERATOR);\n          values.push(c);\n          c = s.charAt(pos++);\n          continue;\n        }\n      }\n\n      types.push(XPathParser.ASTERISKNAMETEST);\n      values.push(c);\n      c = s.charAt(pos++);\n      continue;\n    }\n\n    if (c == ':') {\n      if (s.charAt(pos) == ':') {\n        types.push(XPathParser.DOUBLECOLON);\n        values.push(\"::\");\n        pos++;\n        c = s.charAt(pos++);\n        continue;\n      }\n    }\n\n    if (c == '/') {\n      c = s.charAt(pos++);\n\n      if (c == '/') {\n        types.push(XPathParser.DOUBLESLASH);\n        values.push(\"//\");\n        c = s.charAt(pos++);\n        continue;\n      }\n\n      types.push(XPathParser.SLASH);\n      values.push('/');\n      continue;\n    }\n\n    if (c == '!') {\n      if (s.charAt(pos) == '=') {\n        types.push(XPathParser.NOTEQUAL);\n        values.push(\"!=\");\n        pos++;\n        c = s.charAt(pos++);\n        continue;\n      }\n    }\n\n    if (c == '<') {\n      if (s.charAt(pos) == '=') {\n        types.push(XPathParser.LESSTHANOREQUAL);\n        values.push(\"<=\");\n        pos++;\n        c = s.charAt(pos++);\n        continue;\n      }\n\n      types.push(XPathParser.LESSTHAN);\n      values.push('<');\n      c = s.charAt(pos++);\n      continue;\n    }\n\n    if (c == '>') {\n      if (s.charAt(pos) == '=') {\n        types.push(XPathParser.GREATERTHANOREQUAL);\n        values.push(\">=\");\n        pos++;\n        c = s.charAt(pos++);\n        continue;\n      }\n\n      types.push(XPathParser.GREATERTHAN);\n      values.push('>');\n      c = s.charAt(pos++);\n      continue;\n    }\n\n    if (c == '_' || Utilities.isLetter(c.charCodeAt(0))) {\n      var name = c;\n      c = s.charAt(pos++);\n\n      while (Utilities.isNCNameChar(c.charCodeAt(0))) {\n        name += c;\n        c = s.charAt(pos++);\n      }\n\n      if (types.length > 0) {\n        var last = types[types.length - 1];\n\n        if (last != XPathParser.AT && last != XPathParser.DOUBLECOLON && last != XPathParser.LEFTPARENTHESIS && last != XPathParser.LEFTBRACKET && last != XPathParser.AND && last != XPathParser.OR && last != XPathParser.MOD && last != XPathParser.DIV && last != XPathParser.MULTIPLYOPERATOR && last != XPathParser.SLASH && last != XPathParser.DOUBLESLASH && last != XPathParser.BAR && last != XPathParser.PLUS && last != XPathParser.MINUS && last != XPathParser.EQUALS && last != XPathParser.NOTEQUAL && last != XPathParser.LESSTHAN && last != XPathParser.LESSTHANOREQUAL && last != XPathParser.GREATERTHAN && last != XPathParser.GREATERTHANOREQUAL) {\n          if (name == \"and\") {\n            types.push(XPathParser.AND);\n            values.push(name);\n            continue;\n          }\n\n          if (name == \"or\") {\n            types.push(XPathParser.OR);\n            values.push(name);\n            continue;\n          }\n\n          if (name == \"mod\") {\n            types.push(XPathParser.MOD);\n            values.push(name);\n            continue;\n          }\n\n          if (name == \"div\") {\n            types.push(XPathParser.DIV);\n            values.push(name);\n            continue;\n          }\n        }\n      }\n\n      if (c == ':') {\n        if (s.charAt(pos) == '*') {\n          types.push(XPathParser.NCNAMECOLONASTERISK);\n          values.push(name + \":*\");\n          pos++;\n          c = s.charAt(pos++);\n          continue;\n        }\n\n        if (s.charAt(pos) == '_' || Utilities.isLetter(s.charCodeAt(pos))) {\n          name += ':';\n          c = s.charAt(pos++);\n\n          while (Utilities.isNCNameChar(c.charCodeAt(0))) {\n            name += c;\n            c = s.charAt(pos++);\n          }\n\n          if (c == '(') {\n            types.push(XPathParser.FUNCTIONNAME);\n            values.push(name);\n            continue;\n          }\n\n          types.push(XPathParser.QNAME);\n          values.push(name);\n          continue;\n        }\n\n        if (s.charAt(pos) == ':') {\n          types.push(XPathParser.AXISNAME);\n          values.push(name);\n          continue;\n        }\n      }\n\n      if (c == '(') {\n        if (name == \"comment\" || name == \"text\" || name == \"node\") {\n          types.push(XPathParser.NODETYPE);\n          values.push(name);\n          continue;\n        }\n\n        if (name == \"processing-instruction\") {\n          if (s.charAt(pos) == ')') {\n            types.push(XPathParser.NODETYPE);\n          } else {\n            types.push(XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL);\n          }\n\n          values.push(name);\n          continue;\n        }\n\n        types.push(XPathParser.FUNCTIONNAME);\n        values.push(name);\n        continue;\n      }\n\n      types.push(XPathParser.QNAME);\n      values.push(name);\n      continue;\n    }\n\n    throw new Error(\"Unexpected character \" + c);\n  }\n\n  types.push(1);\n  values.push(\"[EOF]\");\n  return [types, values];\n};\n\nXPathParser.SHIFT = 's';\nXPathParser.REDUCE = 'r';\nXPathParser.ACCEPT = 'a';\n\nXPathParser.prototype.parse = function (s) {\n  var types;\n  var values;\n  var res = this.tokenize(s);\n\n  if (res == undefined) {\n    return undefined;\n  }\n\n  types = res[0];\n  values = res[1];\n  var tokenPos = 0;\n  var state = [];\n  var tokenType = [];\n  var tokenValue = [];\n  var s;\n  var a;\n  var t;\n  state.push(0);\n  tokenType.push(1);\n  tokenValue.push(\"_S\");\n  a = types[tokenPos];\n  t = values[tokenPos++];\n\n  while (1) {\n    s = state[state.length - 1];\n\n    switch (XPathParser.actionTable[s].charAt(a - 1)) {\n      case XPathParser.SHIFT:\n        tokenType.push(-a);\n        tokenValue.push(t);\n        state.push(XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32);\n        a = types[tokenPos];\n        t = values[tokenPos++];\n        break;\n\n      case XPathParser.REDUCE:\n        var num = XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][1];\n        var rhs = [];\n\n        for (var i = 0; i < num; i++) {\n          tokenType.pop();\n          rhs.unshift(tokenValue.pop());\n          state.pop();\n        }\n\n        var s_ = state[state.length - 1];\n        tokenType.push(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0]);\n\n        if (this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32] == undefined) {\n          tokenValue.push(rhs[0]);\n        } else {\n          tokenValue.push(this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32](rhs));\n        }\n\n        state.push(XPathParser.gotoTable[s_].charCodeAt(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0] - 2) - 33);\n        break;\n\n      case XPathParser.ACCEPT:\n        return new XPath(tokenValue.pop());\n\n      default:\n        throw new Error(\"XPath parse error\");\n    }\n  }\n}; // XPath /////////////////////////////////////////////////////////////////////\n\n\nXPath.prototype = new Object();\nXPath.prototype.constructor = XPath;\nXPath.superclass = Object.prototype;\n\nfunction XPath(e) {\n  this.expression = e;\n}\n\nXPath.prototype.toString = function () {\n  return this.expression.toString();\n};\n\nXPath.prototype.evaluate = function (c) {\n  c.contextNode = c.expressionContextNode;\n  c.contextSize = 1;\n  c.contextPosition = 1;\n  c.caseInsensitive = false;\n\n  if (c.contextNode != null) {\n    var doc = c.contextNode;\n\n    if (doc.nodeType != 9\n    /*Node.DOCUMENT_NODE*/\n    ) {\n        doc = doc.ownerDocument;\n      }\n\n    try {\n      c.caseInsensitive = doc.implementation.hasFeature(\"HTML\", \"2.0\");\n    } catch (e) {\n      c.caseInsensitive = true;\n    }\n  }\n\n  return this.expression.evaluate(c);\n};\n\nXPath.XML_NAMESPACE_URI = \"http://www.w3.org/XML/1998/namespace\";\nXPath.XMLNS_NAMESPACE_URI = \"http://www.w3.org/2000/xmlns/\"; // Expression ////////////////////////////////////////////////////////////////\n\nExpression.prototype = new Object();\nExpression.prototype.constructor = Expression;\nExpression.superclass = Object.prototype;\n\nfunction Expression() {}\n\nExpression.prototype.init = function () {};\n\nExpression.prototype.toString = function () {\n  return \"<Expression>\";\n};\n\nExpression.prototype.evaluate = function (c) {\n  throw new Error(\"Could not evaluate expression.\");\n}; // UnaryOperation ////////////////////////////////////////////////////////////\n\n\nUnaryOperation.prototype = new Expression();\nUnaryOperation.prototype.constructor = UnaryOperation;\nUnaryOperation.superclass = Expression.prototype;\n\nfunction UnaryOperation(rhs) {\n  if (arguments.length > 0) {\n    this.init(rhs);\n  }\n}\n\nUnaryOperation.prototype.init = function (rhs) {\n  this.rhs = rhs;\n}; // UnaryMinusOperation ///////////////////////////////////////////////////////\n\n\nUnaryMinusOperation.prototype = new UnaryOperation();\nUnaryMinusOperation.prototype.constructor = UnaryMinusOperation;\nUnaryMinusOperation.superclass = UnaryOperation.prototype;\n\nfunction UnaryMinusOperation(rhs) {\n  if (arguments.length > 0) {\n    this.init(rhs);\n  }\n}\n\nUnaryMinusOperation.prototype.init = function (rhs) {\n  UnaryMinusOperation.superclass.init.call(this, rhs);\n};\n\nUnaryMinusOperation.prototype.evaluate = function (c) {\n  return this.rhs.evaluate(c).number().negate();\n};\n\nUnaryMinusOperation.prototype.toString = function () {\n  return \"-\" + this.rhs.toString();\n}; // BinaryOperation ///////////////////////////////////////////////////////////\n\n\nBinaryOperation.prototype = new Expression();\nBinaryOperation.prototype.constructor = BinaryOperation;\nBinaryOperation.superclass = Expression.prototype;\n\nfunction BinaryOperation(lhs, rhs) {\n  if (arguments.length > 0) {\n    this.init(lhs, rhs);\n  }\n}\n\nBinaryOperation.prototype.init = function (lhs, rhs) {\n  this.lhs = lhs;\n  this.rhs = rhs;\n}; // OrOperation ///////////////////////////////////////////////////////////////\n\n\nOrOperation.prototype = new BinaryOperation();\nOrOperation.prototype.constructor = OrOperation;\nOrOperation.superclass = BinaryOperation.prototype;\n\nfunction OrOperation(lhs, rhs) {\n  if (arguments.length > 0) {\n    this.init(lhs, rhs);\n  }\n}\n\nOrOperation.prototype.init = function (lhs, rhs) {\n  OrOperation.superclass.init.call(this, lhs, rhs);\n};\n\nOrOperation.prototype.toString = function () {\n  return \"(\" + this.lhs.toString() + \" or \" + this.rhs.toString() + \")\";\n};\n\nOrOperation.prototype.evaluate = function (c) {\n  var b = this.lhs.evaluate(c).bool();\n\n  if (b.booleanValue()) {\n    return b;\n  }\n\n  return this.rhs.evaluate(c).bool();\n}; // AndOperation //////////////////////////////////////////////////////////////\n\n\nAndOperation.prototype = new BinaryOperation();\nAndOperation.prototype.constructor = AndOperation;\nAndOperation.superclass = BinaryOperation.prototype;\n\nfunction AndOperation(lhs, rhs) {\n  if (arguments.length > 0) {\n    this.init(lhs, rhs);\n  }\n}\n\nAndOperation.prototype.init = function (lhs, rhs) {\n  AndOperation.superclass.init.call(this, lhs, rhs);\n};\n\nAndOperation.prototype.toString = function () {\n  return \"(\" + this.lhs.toString() + \" and \" + this.rhs.toString() + \")\";\n};\n\nAndOperation.prototype.evaluate = function (c) {\n  var b = this.lhs.evaluate(c).bool();\n\n  if (!b.booleanValue()) {\n    return b;\n  }\n\n  return this.rhs.evaluate(c).bool();\n}; // EqualsOperation ///////////////////////////////////////////////////////////\n\n\nEqualsOperation.prototype = new BinaryOperation();\nEqualsOperation.prototype.constructor = EqualsOperation;\nEqualsOperation.superclass = BinaryOperation.prototype;\n\nfunction EqualsOperation(lhs, rhs) {\n  if (arguments.length > 0) {\n    this.init(lhs, rhs);\n  }\n}\n\nEqualsOperation.prototype.init = function (lhs, rhs) {\n  EqualsOperation.superclass.init.call(this, lhs, rhs);\n};\n\nEqualsOperation.prototype.toString = function () {\n  return \"(\" + this.lhs.toString() + \" = \" + this.rhs.toString() + \")\";\n};\n\nEqualsOperation.prototype.evaluate = function (c) {\n  return this.lhs.evaluate(c).equals(this.rhs.evaluate(c));\n}; // NotEqualOperation /////////////////////////////////////////////////////////\n\n\nNotEqualOperation.prototype = new BinaryOperation();\nNotEqualOperation.prototype.constructor = NotEqualOperation;\nNotEqualOperation.superclass = BinaryOperation.prototype;\n\nfunction NotEqualOperation(lhs, rhs) {\n  if (arguments.length > 0) {\n    this.init(lhs, rhs);\n  }\n}\n\nNotEqualOperation.prototype.init = function (lhs, rhs) {\n  NotEqualOperation.superclass.init.call(this, lhs, rhs);\n};\n\nNotEqualOperation.prototype.toString = function () {\n  return \"(\" + this.lhs.toString() + \" != \" + this.rhs.toString() + \")\";\n};\n\nNotEqualOperation.prototype.evaluate = function (c) {\n  return this.lhs.evaluate(c).notequal(this.rhs.evaluate(c));\n}; // LessThanOperation /////////////////////////////////////////////////////////\n\n\nLessThanOperation.prototype = new BinaryOperation();\nLessThanOperation.prototype.constructor = LessThanOperation;\nLessThanOperation.superclass = BinaryOperation.prototype;\n\nfunction LessThanOperation(lhs, rhs) {\n  if (arguments.length > 0) {\n    this.init(lhs, rhs);\n  }\n}\n\nLessThanOperation.prototype.init = function (lhs, rhs) {\n  LessThanOperation.superclass.init.call(this, lhs, rhs);\n};\n\nLessThanOperation.prototype.evaluate = function (c) {\n  return this.lhs.evaluate(c).lessthan(this.rhs.evaluate(c));\n};\n\nLessThanOperation.prototype.toString = function () {\n  return \"(\" + this.lhs.toString() + \" < \" + this.rhs.toString() + \")\";\n}; // GreaterThanOperation //////////////////////////////////////////////////////\n\n\nGreaterThanOperation.prototype = new BinaryOperation();\nGreaterThanOperation.prototype.constructor = GreaterThanOperation;\nGreaterThanOperation.superclass = BinaryOperation.prototype;\n\nfunction GreaterThanOperation(lhs, rhs) {\n  if (arguments.length > 0) {\n    this.init(lhs, rhs);\n  }\n}\n\nGreaterThanOperation.prototype.init = function (lhs, rhs) {\n  GreaterThanOperation.superclass.init.call(this, lhs, rhs);\n};\n\nGreaterThanOperation.prototype.evaluate = function (c) {\n  return this.lhs.evaluate(c).greaterthan(this.rhs.evaluate(c));\n};\n\nGreaterThanOperation.prototype.toString = function () {\n  return \"(\" + this.lhs.toString() + \" > \" + this.rhs.toString() + \")\";\n}; // LessThanOrEqualOperation //////////////////////////////////////////////////\n\n\nLessThanOrEqualOperation.prototype = new BinaryOperation();\nLessThanOrEqualOperation.prototype.constructor = LessThanOrEqualOperation;\nLessThanOrEqualOperation.superclass = BinaryOperation.prototype;\n\nfunction LessThanOrEqualOperation(lhs, rhs) {\n  if (arguments.length > 0) {\n    this.init(lhs, rhs);\n  }\n}\n\nLessThanOrEqualOperation.prototype.init = function (lhs, rhs) {\n  LessThanOrEqualOperation.superclass.init.call(this, lhs, rhs);\n};\n\nLessThanOrEqualOperation.prototype.evaluate = function (c) {\n  return this.lhs.evaluate(c).lessthanorequal(this.rhs.evaluate(c));\n};\n\nLessThanOrEqualOperation.prototype.toString = function () {\n  return \"(\" + this.lhs.toString() + \" <= \" + this.rhs.toString() + \")\";\n}; // GreaterThanOrEqualOperation ///////////////////////////////////////////////\n\n\nGreaterThanOrEqualOperation.prototype = new BinaryOperation();\nGreaterThanOrEqualOperation.prototype.constructor = GreaterThanOrEqualOperation;\nGreaterThanOrEqualOperation.superclass = BinaryOperation.prototype;\n\nfunction GreaterThanOrEqualOperation(lhs, rhs) {\n  if (arguments.length > 0) {\n    this.init(lhs, rhs);\n  }\n}\n\nGreaterThanOrEqualOperation.prototype.init = function (lhs, rhs) {\n  GreaterThanOrEqualOperation.superclass.init.call(this, lhs, rhs);\n};\n\nGreaterThanOrEqualOperation.prototype.evaluate = function (c) {\n  return this.lhs.evaluate(c).greaterthanorequal(this.rhs.evaluate(c));\n};\n\nGreaterThanOrEqualOperation.prototype.toString = function () {\n  return \"(\" + this.lhs.toString() + \" >= \" + this.rhs.toString() + \")\";\n}; // PlusOperation /////////////////////////////////////////////////////////////\n\n\nPlusOperation.prototype = new BinaryOperation();\nPlusOperation.prototype.constructor = PlusOperation;\nPlusOperation.superclass = BinaryOperation.prototype;\n\nfunction PlusOperation(lhs, rhs) {\n  if (arguments.length > 0) {\n    this.init(lhs, rhs);\n  }\n}\n\nPlusOperation.prototype.init = function (lhs, rhs) {\n  PlusOperation.superclass.init.call(this, lhs, rhs);\n};\n\nPlusOperation.prototype.evaluate = function (c) {\n  return this.lhs.evaluate(c).number().plus(this.rhs.evaluate(c).number());\n};\n\nPlusOperation.prototype.toString = function () {\n  return \"(\" + this.lhs.toString() + \" + \" + this.rhs.toString() + \")\";\n}; // MinusOperation ////////////////////////////////////////////////////////////\n\n\nMinusOperation.prototype = new BinaryOperation();\nMinusOperation.prototype.constructor = MinusOperation;\nMinusOperation.superclass = BinaryOperation.prototype;\n\nfunction MinusOperation(lhs, rhs) {\n  if (arguments.length > 0) {\n    this.init(lhs, rhs);\n  }\n}\n\nMinusOperation.prototype.init = function (lhs, rhs) {\n  MinusOperation.superclass.init.call(this, lhs, rhs);\n};\n\nMinusOperation.prototype.evaluate = function (c) {\n  return this.lhs.evaluate(c).number().minus(this.rhs.evaluate(c).number());\n};\n\nMinusOperation.prototype.toString = function () {\n  return \"(\" + this.lhs.toString() + \" - \" + this.rhs.toString() + \")\";\n}; // MultiplyOperation /////////////////////////////////////////////////////////\n\n\nMultiplyOperation.prototype = new BinaryOperation();\nMultiplyOperation.prototype.constructor = MultiplyOperation;\nMultiplyOperation.superclass = BinaryOperation.prototype;\n\nfunction MultiplyOperation(lhs, rhs) {\n  if (arguments.length > 0) {\n    this.init(lhs, rhs);\n  }\n}\n\nMultiplyOperation.prototype.init = function (lhs, rhs) {\n  MultiplyOperation.superclass.init.call(this, lhs, rhs);\n};\n\nMultiplyOperation.prototype.evaluate = function (c) {\n  return this.lhs.evaluate(c).number().multiply(this.rhs.evaluate(c).number());\n};\n\nMultiplyOperation.prototype.toString = function () {\n  return \"(\" + this.lhs.toString() + \" * \" + this.rhs.toString() + \")\";\n}; // DivOperation //////////////////////////////////////////////////////////////\n\n\nDivOperation.prototype = new BinaryOperation();\nDivOperation.prototype.constructor = DivOperation;\nDivOperation.superclass = BinaryOperation.prototype;\n\nfunction DivOperation(lhs, rhs) {\n  if (arguments.length > 0) {\n    this.init(lhs, rhs);\n  }\n}\n\nDivOperation.prototype.init = function (lhs, rhs) {\n  DivOperation.superclass.init.call(this, lhs, rhs);\n};\n\nDivOperation.prototype.evaluate = function (c) {\n  return this.lhs.evaluate(c).number().div(this.rhs.evaluate(c).number());\n};\n\nDivOperation.prototype.toString = function () {\n  return \"(\" + this.lhs.toString() + \" div \" + this.rhs.toString() + \")\";\n}; // ModOperation //////////////////////////////////////////////////////////////\n\n\nModOperation.prototype = new BinaryOperation();\nModOperation.prototype.constructor = ModOperation;\nModOperation.superclass = BinaryOperation.prototype;\n\nfunction ModOperation(lhs, rhs) {\n  if (arguments.length > 0) {\n    this.init(lhs, rhs);\n  }\n}\n\nModOperation.prototype.init = function (lhs, rhs) {\n  ModOperation.superclass.init.call(this, lhs, rhs);\n};\n\nModOperation.prototype.evaluate = function (c) {\n  return this.lhs.evaluate(c).number().mod(this.rhs.evaluate(c).number());\n};\n\nModOperation.prototype.toString = function () {\n  return \"(\" + this.lhs.toString() + \" mod \" + this.rhs.toString() + \")\";\n}; // BarOperation //////////////////////////////////////////////////////////////\n\n\nBarOperation.prototype = new BinaryOperation();\nBarOperation.prototype.constructor = BarOperation;\nBarOperation.superclass = BinaryOperation.prototype;\n\nfunction BarOperation(lhs, rhs) {\n  if (arguments.length > 0) {\n    this.init(lhs, rhs);\n  }\n}\n\nBarOperation.prototype.init = function (lhs, rhs) {\n  BarOperation.superclass.init.call(this, lhs, rhs);\n};\n\nBarOperation.prototype.evaluate = function (c) {\n  return this.lhs.evaluate(c).nodeset().union(this.rhs.evaluate(c).nodeset());\n};\n\nBarOperation.prototype.toString = function () {\n  return this.lhs.toString() + \" | \" + this.rhs.toString();\n}; // PathExpr //////////////////////////////////////////////////////////////////\n\n\nPathExpr.prototype = new Expression();\nPathExpr.prototype.constructor = PathExpr;\nPathExpr.superclass = Expression.prototype;\n\nfunction PathExpr(filter, filterPreds, locpath) {\n  if (arguments.length > 0) {\n    this.init(filter, filterPreds, locpath);\n  }\n}\n\nPathExpr.prototype.init = function (filter, filterPreds, locpath) {\n  PathExpr.superclass.init.call(this);\n  this.filter = filter;\n  this.filterPredicates = filterPreds;\n  this.locationPath = locpath;\n};\n\nPathExpr.prototype.evaluate = function (c) {\n  var nodes;\n  var xpc = new XPathContext();\n  xpc.variableResolver = c.variableResolver;\n  xpc.functionResolver = c.functionResolver;\n  xpc.namespaceResolver = c.namespaceResolver;\n  xpc.expressionContextNode = c.expressionContextNode;\n  xpc.virtualRoot = c.virtualRoot;\n  xpc.caseInsensitive = c.caseInsensitive;\n\n  if (this.filter == null) {\n    nodes = [c.contextNode];\n  } else {\n    var ns = this.filter.evaluate(c);\n\n    if (!Utilities.instance_of(ns, XNodeSet)) {\n      if (this.filterPredicates != null && this.filterPredicates.length > 0 || this.locationPath != null) {\n        throw new Error(\"Path expression filter must evaluate to a nodset if predicates or location path are used\");\n      }\n\n      return ns;\n    }\n\n    nodes = ns.toArray();\n\n    if (this.filterPredicates != null) {\n      // apply each of the predicates in turn\n      for (var j = 0; j < this.filterPredicates.length; j++) {\n        var pred = this.filterPredicates[j];\n        var newNodes = [];\n        xpc.contextSize = nodes.length;\n\n        for (xpc.contextPosition = 1; xpc.contextPosition <= xpc.contextSize; xpc.contextPosition++) {\n          xpc.contextNode = nodes[xpc.contextPosition - 1];\n\n          if (this.predicateMatches(pred, xpc)) {\n            newNodes.push(xpc.contextNode);\n          }\n        }\n\n        nodes = newNodes;\n      }\n    }\n  }\n\n  if (this.locationPath != null) {\n    if (this.locationPath.absolute) {\n      if (nodes[0].nodeType != 9\n      /*Node.DOCUMENT_NODE*/\n      ) {\n          if (xpc.virtualRoot != null) {\n            nodes = [xpc.virtualRoot];\n          } else {\n            if (nodes[0].ownerDocument == null) {\n              // IE 5.5 doesn't have ownerDocument?\n              var n = nodes[0];\n\n              while (n.parentNode != null) {\n                n = n.parentNode;\n              }\n\n              nodes = [n];\n            } else {\n              nodes = [nodes[0].ownerDocument];\n            }\n          }\n        } else {\n        nodes = [nodes[0]];\n      }\n    }\n\n    for (var i = 0; i < this.locationPath.steps.length; i++) {\n      var step = this.locationPath.steps[i];\n      var newNodes = [];\n      var newLocalContext = [];\n\n      for (var j = 0; j < nodes.length; j++) {\n        xpc.contextNode = nodes[j];\n\n        switch (step.axis) {\n          case Step.ANCESTOR:\n            // look at all the ancestor nodes\n            if (xpc.contextNode === xpc.virtualRoot) {\n              break;\n            }\n\n            var m;\n\n            if (xpc.contextNode.nodeType == 2\n            /*Node.ATTRIBUTE_NODE*/\n            ) {\n                m = this.getOwnerElement(xpc.contextNode);\n              } else {\n              m = xpc.contextNode.parentNode;\n            }\n\n            while (m != null) {\n              if (step.nodeTest.matches(m, xpc)) {\n                newNodes.push(m);\n              }\n\n              if (m === xpc.virtualRoot) {\n                break;\n              }\n\n              m = m.parentNode;\n            }\n\n            break;\n\n          case Step.ANCESTORORSELF:\n            // look at all the ancestor nodes and the current node\n            for (var m = xpc.contextNode; m != null; m = m.nodeType == 2\n            /*Node.ATTRIBUTE_NODE*/\n            ? this.getOwnerElement(m) : m.parentNode) {\n              if (step.nodeTest.matches(m, xpc)) {\n                newNodes.push(m);\n              }\n\n              if (m === xpc.virtualRoot) {\n                break;\n              }\n            }\n\n            break;\n\n          case Step.ATTRIBUTE:\n            // look at the attributes\n            var nnm = xpc.contextNode.attributes;\n\n            if (nnm != null) {\n              for (var k = 0; k < nnm.length; k++) {\n                var m = nnm.item(k);\n\n                if (step.nodeTest.matches(m, xpc)) {\n                  newNodes.push(m);\n                }\n              }\n            }\n\n            break;\n\n          case Step.CHILD:\n            // look at all child elements\n            var pos = 0;\n            var tmpContext = [];\n\n            for (var m = xpc.contextNode.firstChild; m != null; m = m.nextSibling) {\n              if (step.nodeTest.matches(m, xpc)) {\n                newNodes.push(m); //keep track of the element position between other matching siblings\n\n                tmpContext.push({\n                  contextPosition: ++pos\n                });\n              }\n            }\n\n            for (var k = 0; k < tmpContext.length; k++) {\n              //track size of matching siblings\n              tmpContext[k].contextSize = pos;\n              newLocalContext.push(tmpContext[k]);\n            }\n\n            break;\n\n          case Step.DESCENDANT:\n            // look at all descendant nodes\n            var st = [xpc.contextNode.firstChild];\n\n            while (st.length > 0) {\n              for (var m = st.pop(); m != null;) {\n                if (step.nodeTest.matches(m, xpc)) {\n                  newNodes.push(m);\n                }\n\n                if (m.firstChild != null) {\n                  st.push(m.nextSibling);\n                  m = m.firstChild;\n                } else {\n                  m = m.nextSibling;\n                }\n              }\n            }\n\n            break;\n\n          case Step.DESCENDANTORSELF:\n            // look at self\n            if (step.nodeTest.matches(xpc.contextNode, xpc)) {\n              newNodes.push(xpc.contextNode);\n            } // look at all descendant nodes\n\n\n            var st = [xpc.contextNode.firstChild];\n\n            while (st.length > 0) {\n              for (var m = st.pop(); m != null;) {\n                if (step.nodeTest.matches(m, xpc)) {\n                  newNodes.push(m);\n                }\n\n                if (m.firstChild != null) {\n                  st.push(m.nextSibling);\n                  m = m.firstChild;\n                } else {\n                  m = m.nextSibling;\n                }\n              }\n            }\n\n            break;\n\n          case Step.FOLLOWING:\n            if (xpc.contextNode === xpc.virtualRoot) {\n              break;\n            }\n\n            var st = [];\n\n            if (xpc.contextNode.firstChild != null) {\n              st.unshift(xpc.contextNode.firstChild);\n            } else {\n              st.unshift(xpc.contextNode.nextSibling);\n            }\n\n            for (var m = xpc.contextNode; m != null && m.nodeType != 9\n            /*Node.DOCUMENT_NODE*/\n            && m !== xpc.virtualRoot; m = m.parentNode) {\n              st.unshift(m.nextSibling);\n            }\n\n            do {\n              for (var m = st.pop(); m != null;) {\n                if (step.nodeTest.matches(m, xpc)) {\n                  newNodes.push(m);\n                }\n\n                if (m.firstChild != null) {\n                  st.push(m.nextSibling);\n                  m = m.firstChild;\n                } else {\n                  m = m.nextSibling;\n                }\n              }\n            } while (st.length > 0);\n\n            break;\n\n          case Step.FOLLOWINGSIBLING:\n            if (xpc.contextNode === xpc.virtualRoot) {\n              break;\n            }\n\n            for (var m = xpc.contextNode.nextSibling; m != null; m = m.nextSibling) {\n              if (step.nodeTest.matches(m, xpc)) {\n                newNodes.push(m);\n              }\n            }\n\n            break;\n\n          case Step.NAMESPACE:\n            var n = {};\n\n            if (xpc.contextNode.nodeType == 1\n            /*Node.ELEMENT_NODE*/\n            ) {\n                n[\"xml\"] = XPath.XML_NAMESPACE_URI;\n                n[\"xmlns\"] = XPath.XMLNS_NAMESPACE_URI;\n\n                for (var m = xpc.contextNode; m != null && m.nodeType == 1\n                /*Node.ELEMENT_NODE*/\n                ; m = m.parentNode) {\n                  for (var k = 0; k < m.attributes.length; k++) {\n                    var attr = m.attributes.item(k);\n                    var nm = String(attr.name);\n\n                    if (nm == \"xmlns\") {\n                      if (n[\"\"] == undefined) {\n                        n[\"\"] = attr.value;\n                      }\n                    } else if (nm.length > 6 && nm.substring(0, 6) == \"xmlns:\") {\n                      var pre = nm.substring(6, nm.length);\n\n                      if (n[pre] == undefined) {\n                        n[pre] = attr.value;\n                      }\n                    }\n                  }\n                }\n\n                for (var pre in n) {\n                  var nsn = new NamespaceNode(pre, n[pre], xpc.contextNode);\n\n                  if (step.nodeTest.matches(nsn, xpc)) {\n                    newNodes.push(nsn);\n                  }\n                }\n              }\n\n            break;\n\n          case Step.PARENT:\n            m = null;\n\n            if (xpc.contextNode !== xpc.virtualRoot) {\n              if (xpc.contextNode.nodeType == 2\n              /*Node.ATTRIBUTE_NODE*/\n              ) {\n                  m = this.getOwnerElement(xpc.contextNode);\n                } else {\n                m = xpc.contextNode.parentNode;\n              }\n            }\n\n            if (m != null && step.nodeTest.matches(m, xpc)) {\n              newNodes.push(m);\n            }\n\n            break;\n\n          case Step.PRECEDING:\n            var st;\n\n            if (xpc.virtualRoot != null) {\n              st = [xpc.virtualRoot];\n            } else {\n              st = xpc.contextNode.nodeType == 9\n              /*Node.DOCUMENT_NODE*/\n              ? [xpc.contextNode] : [xpc.contextNode.ownerDocument];\n            }\n\n            outer: while (st.length > 0) {\n              for (var m = st.pop(); m != null;) {\n                if (m == xpc.contextNode) {\n                  break outer;\n                }\n\n                if (step.nodeTest.matches(m, xpc)) {\n                  newNodes.unshift(m);\n                }\n\n                if (m.firstChild != null) {\n                  st.push(m.nextSibling);\n                  m = m.firstChild;\n                } else {\n                  m = m.nextSibling;\n                }\n              }\n            }\n\n            break;\n\n          case Step.PRECEDINGSIBLING:\n            if (xpc.contextNode === xpc.virtualRoot) {\n              break;\n            }\n\n            for (var m = xpc.contextNode.previousSibling; m != null; m = m.previousSibling) {\n              if (step.nodeTest.matches(m, xpc)) {\n                newNodes.push(m);\n              }\n            }\n\n            break;\n\n          case Step.SELF:\n            if (step.nodeTest.matches(xpc.contextNode, xpc)) {\n              newNodes.push(xpc.contextNode);\n            }\n\n            break;\n\n          default:\n        }\n      }\n\n      nodes = newNodes; // apply each of the predicates in turn\t\t\t\n\n      for (var j = 0; j < step.predicates.length; j++) {\n        var pred = step.predicates[j];\n        var newNodes = [];\n        xpc.contextSize = nodes.length;\n\n        for (xpc.contextPosition = 1; xpc.contextPosition <= xpc.contextSize; xpc.contextPosition++) {\n          xpc.contextNode = nodes[xpc.contextPosition - 1]; //if we keep track of the node original context then use it\n          //end goal is to always use original cotnext, now implemented just for CHILD axis\n\n          var localCtx = newLocalContext.length > 0 ? this.getLocalCtx(xpc, newLocalContext[xpc.contextPosition - 1]) : xpc;\n\n          if (this.predicateMatches(pred, localCtx)) {\n            newNodes.push(xpc.contextNode);\n          } else {}\n        }\n\n        nodes = newNodes; //console.log(nodes.length)\n      }\n    }\n  }\n\n  var ns = new XNodeSet();\n  ns.addArray(nodes);\n  return ns;\n};\n\nPathExpr.prototype.getLocalCtx = function (xpc, localCtx, length) {\n  var res = new XPathContext();\n  res.variableResolver = xpc.variableResolver;\n  res.functionResolver = xpc.functionResolver;\n  res.namespaceResolver = xpc.namespaceResolver;\n  res.expressionContextNode = xpc.expressionContextNode;\n  res.virtualRoot = xpc.virtualRoot;\n  res.caseInsensitive = xpc.caseInsensitive;\n  res.contextNode = xpc.contextNode;\n  res.contextPosition = localCtx.contextPosition;\n  res.contextSize = localCtx.contextSize;\n  return res;\n};\n\nPathExpr.prototype.predicateMatches = function (pred, c) {\n  var res = pred.evaluate(c);\n\n  if (Utilities.instance_of(res, XNumber)) {\n    var val = c.contextPosition == res.numberValue();\n    return val;\n  }\n\n  return res.booleanValue();\n};\n\nPathExpr.prototype.toString = function () {\n  if (this.filter != undefined) {\n    var s = this.filter.toString();\n\n    if (Utilities.instance_of(this.filter, XString)) {\n      s = \"'\" + s + \"'\";\n    }\n\n    if (this.filterPredicates != undefined) {\n      for (var i = 0; i < this.filterPredicates.length; i++) {\n        s = s + \"[\" + this.filterPredicates[i].toString() + \"]\";\n      }\n    }\n\n    if (this.locationPath != undefined) {\n      if (!this.locationPath.absolute) {\n        s += \"/\";\n      }\n\n      s += this.locationPath.toString();\n    }\n\n    return s;\n  }\n\n  return this.locationPath.toString();\n};\n\nPathExpr.prototype.getOwnerElement = function (n) {\n  // DOM 2 has ownerElement\n  if (n.ownerElement) {\n    return n.ownerElement;\n  } // DOM 1 Internet Explorer can use selectSingleNode (ironically)\n\n\n  try {\n    if (n.selectSingleNode) {\n      return n.selectSingleNode(\"..\");\n    }\n  } catch (e) {} // Other DOM 1 implementations must use this egregious search\n\n\n  var doc = n.nodeType == 9\n  /*Node.DOCUMENT_NODE*/\n  ? n : n.ownerDocument;\n  var elts = doc.getElementsByTagName(\"*\");\n\n  for (var i = 0; i < elts.length; i++) {\n    var elt = elts.item(i);\n    var nnm = elt.attributes;\n\n    for (var j = 0; j < nnm.length; j++) {\n      var an = nnm.item(j);\n\n      if (an === n) {\n        return elt;\n      }\n    }\n  }\n\n  return null;\n}; // LocationPath //////////////////////////////////////////////////////////////\n\n\nLocationPath.prototype = new Object();\nLocationPath.prototype.constructor = LocationPath;\nLocationPath.superclass = Object.prototype;\n\nfunction LocationPath(abs, steps) {\n  if (arguments.length > 0) {\n    this.init(abs, steps);\n  }\n}\n\nLocationPath.prototype.init = function (abs, steps) {\n  this.absolute = abs;\n  this.steps = steps;\n};\n\nLocationPath.prototype.toString = function () {\n  var s;\n\n  if (this.absolute) {\n    s = \"/\";\n  } else {\n    s = \"\";\n  }\n\n  for (var i = 0; i < this.steps.length; i++) {\n    if (i != 0) {\n      s += \"/\";\n    }\n\n    s += this.steps[i].toString();\n  }\n\n  return s;\n}; // Step //////////////////////////////////////////////////////////////////////\n\n\nStep.prototype = new Object();\nStep.prototype.constructor = Step;\nStep.superclass = Object.prototype;\n\nfunction Step(axis, nodetest, preds) {\n  if (arguments.length > 0) {\n    this.init(axis, nodetest, preds);\n  }\n}\n\nStep.prototype.init = function (axis, nodetest, preds) {\n  this.axis = axis;\n  this.nodeTest = nodetest;\n  this.predicates = preds;\n};\n\nStep.prototype.toString = function () {\n  var s;\n\n  switch (this.axis) {\n    case Step.ANCESTOR:\n      s = \"ancestor\";\n      break;\n\n    case Step.ANCESTORORSELF:\n      s = \"ancestor-or-self\";\n      break;\n\n    case Step.ATTRIBUTE:\n      s = \"attribute\";\n      break;\n\n    case Step.CHILD:\n      s = \"child\";\n      break;\n\n    case Step.DESCENDANT:\n      s = \"descendant\";\n      break;\n\n    case Step.DESCENDANTORSELF:\n      s = \"descendant-or-self\";\n      break;\n\n    case Step.FOLLOWING:\n      s = \"following\";\n      break;\n\n    case Step.FOLLOWINGSIBLING:\n      s = \"following-sibling\";\n      break;\n\n    case Step.NAMESPACE:\n      s = \"namespace\";\n      break;\n\n    case Step.PARENT:\n      s = \"parent\";\n      break;\n\n    case Step.PRECEDING:\n      s = \"preceding\";\n      break;\n\n    case Step.PRECEDINGSIBLING:\n      s = \"preceding-sibling\";\n      break;\n\n    case Step.SELF:\n      s = \"self\";\n      break;\n  }\n\n  s += \"::\";\n  s += this.nodeTest.toString();\n\n  for (var i = 0; i < this.predicates.length; i++) {\n    s += \"[\" + this.predicates[i].toString() + \"]\";\n  }\n\n  return s;\n};\n\nStep.ANCESTOR = 0;\nStep.ANCESTORORSELF = 1;\nStep.ATTRIBUTE = 2;\nStep.CHILD = 3;\nStep.DESCENDANT = 4;\nStep.DESCENDANTORSELF = 5;\nStep.FOLLOWING = 6;\nStep.FOLLOWINGSIBLING = 7;\nStep.NAMESPACE = 8;\nStep.PARENT = 9;\nStep.PRECEDING = 10;\nStep.PRECEDINGSIBLING = 11;\nStep.SELF = 12; // NodeTest //////////////////////////////////////////////////////////////////\n\nNodeTest.prototype = new Object();\nNodeTest.prototype.constructor = NodeTest;\nNodeTest.superclass = Object.prototype;\n\nfunction NodeTest(type, value) {\n  if (arguments.length > 0) {\n    this.init(type, value);\n  }\n}\n\nNodeTest.prototype.init = function (type, value) {\n  this.type = type;\n  this.value = value;\n};\n\nNodeTest.prototype.toString = function () {\n  switch (this.type) {\n    case NodeTest.NAMETESTANY:\n      return \"*\";\n\n    case NodeTest.NAMETESTPREFIXANY:\n      return this.value + \":*\";\n\n    case NodeTest.NAMETESTRESOLVEDANY:\n      return \"{\" + this.value + \"}*\";\n\n    case NodeTest.NAMETESTQNAME:\n      return this.value;\n\n    case NodeTest.NAMETESTRESOLVEDNAME:\n      return \"{\" + this.namespaceURI + \"}\" + this.value;\n\n    case NodeTest.COMMENT:\n      return \"comment()\";\n\n    case NodeTest.TEXT:\n      return \"text()\";\n\n    case NodeTest.PI:\n      if (this.value != undefined) {\n        return \"processing-instruction(\\\"\" + this.value + \"\\\")\";\n      }\n\n      return \"processing-instruction()\";\n\n    case NodeTest.NODE:\n      return \"node()\";\n  }\n\n  return \"<unknown nodetest type>\";\n};\n\nNodeTest.prototype.matches = function (n, xpc) {\n  switch (this.type) {\n    case NodeTest.NAMETESTANY:\n      if (n.nodeType == 2\n      /*Node.ATTRIBUTE_NODE*/\n      || n.nodeType == 1\n      /*Node.ELEMENT_NODE*/\n      || n.nodeType == XPathNamespace.XPATH_NAMESPACE_NODE) {\n        return true;\n      }\n\n      return false;\n\n    case NodeTest.NAMETESTPREFIXANY:\n      if (n.nodeType == 2\n      /*Node.ATTRIBUTE_NODE*/\n      || n.nodeType == 1\n      /*Node.ELEMENT_NODE*/\n      ) {\n          var ns = xpc.namespaceResolver.getNamespace(this.value, xpc.expressionContextNode);\n\n          if (ns == null) {\n            throw new Error(\"Cannot resolve QName \" + this.value);\n          }\n\n          return true;\n        }\n\n      return false;\n\n    case NodeTest.NAMETESTQNAME:\n      if (n.nodeType == 2\n      /*Node.ATTRIBUTE_NODE*/\n      || n.nodeType == 1\n      /*Node.ELEMENT_NODE*/\n      || n.nodeType == XPathNamespace.XPATH_NAMESPACE_NODE) {\n        var test = Utilities.resolveQName(this.value, xpc.namespaceResolver, xpc.expressionContextNode, false);\n\n        if (test[0] == null) {\n          throw new Error(\"Cannot resolve QName \" + this.value);\n        }\n\n        test[0] = String(test[0]);\n        test[1] = String(test[1]);\n\n        if (test[0] == \"\") {\n          test[0] = null;\n        }\n\n        var node = Utilities.resolveQName(n.nodeName, xpc.namespaceResolver, n, n.nodeType == 1\n        /*Node.ELEMENT_NODE*/\n        );\n        node[0] = String(node[0]);\n        node[1] = String(node[1]);\n\n        if (node[0] == \"\") {\n          node[0] = null;\n        }\n\n        if (xpc.caseInsensitive) {\n          return test[0] == node[0] && String(test[1]).toLowerCase() == String(node[1]).toLowerCase();\n        }\n\n        return test[0] == node[0] && test[1] == node[1];\n      }\n\n      return false;\n\n    case NodeTest.COMMENT:\n      return n.nodeType == 8\n      /*Node.COMMENT_NODE*/\n      ;\n\n    case NodeTest.TEXT:\n      return n.nodeType == 3\n      /*Node.TEXT_NODE*/\n      || n.nodeType == 4\n      /*Node.CDATA_SECTION_NODE*/\n      ;\n\n    case NodeTest.PI:\n      return n.nodeType == 7\n      /*Node.PROCESSING_INSTRUCTION_NODE*/\n      && (this.value == null || n.nodeName == this.value);\n\n    case NodeTest.NODE:\n      return n.nodeType == 9\n      /*Node.DOCUMENT_NODE*/\n      || n.nodeType == 1\n      /*Node.ELEMENT_NODE*/\n      || n.nodeType == 2\n      /*Node.ATTRIBUTE_NODE*/\n      || n.nodeType == 3\n      /*Node.TEXT_NODE*/\n      || n.nodeType == 4\n      /*Node.CDATA_SECTION_NODE*/\n      || n.nodeType == 8\n      /*Node.COMMENT_NODE*/\n      || n.nodeType == 7\n      /*Node.PROCESSING_INSTRUCTION_NODE*/\n      ;\n  }\n\n  return false;\n};\n\nNodeTest.NAMETESTANY = 0;\nNodeTest.NAMETESTPREFIXANY = 1;\nNodeTest.NAMETESTQNAME = 2;\nNodeTest.COMMENT = 3;\nNodeTest.TEXT = 4;\nNodeTest.PI = 5;\nNodeTest.NODE = 6; // VariableReference /////////////////////////////////////////////////////////\n\nVariableReference.prototype = new Expression();\nVariableReference.prototype.constructor = VariableReference;\nVariableReference.superclass = Expression.prototype;\n\nfunction VariableReference(v) {\n  if (arguments.length > 0) {\n    this.init(v);\n  }\n}\n\nVariableReference.prototype.init = function (v) {\n  this.variable = v;\n};\n\nVariableReference.prototype.toString = function () {\n  return \"$\" + this.variable;\n};\n\nVariableReference.prototype.evaluate = function (c) {\n  return c.variableResolver.getVariable(this.variable, c);\n}; // FunctionCall //////////////////////////////////////////////////////////////\n\n\nFunctionCall.prototype = new Expression();\nFunctionCall.prototype.constructor = FunctionCall;\nFunctionCall.superclass = Expression.prototype;\n\nfunction FunctionCall(fn, args) {\n  if (arguments.length > 0) {\n    this.init(fn, args);\n  }\n}\n\nFunctionCall.prototype.init = function (fn, args) {\n  this.functionName = fn;\n  this.arguments = args;\n};\n\nFunctionCall.prototype.toString = function () {\n  var s = this.functionName + \"(\";\n\n  for (var i = 0; i < this.arguments.length; i++) {\n    if (i > 0) {\n      s += \", \";\n    }\n\n    s += this.arguments[i].toString();\n  }\n\n  return s + \")\";\n};\n\nFunctionCall.prototype.evaluate = function (c) {\n  var f = c.functionResolver.getFunction(this.functionName, c);\n\n  if (f == undefined) {\n    throw new Error(\"Unknown function \" + this.functionName);\n  }\n\n  var a = [c].concat(this.arguments);\n  return f.apply(c.functionResolver.thisArg, a);\n}; // XString ///////////////////////////////////////////////////////////////////\n\n\nXString.prototype = new Expression();\nXString.prototype.constructor = XString;\nXString.superclass = Expression.prototype;\n\nfunction XString(s) {\n  if (arguments.length > 0) {\n    this.init(s);\n  }\n}\n\nXString.prototype.init = function (s) {\n  this.str = s;\n};\n\nXString.prototype.toString = function () {\n  return this.str;\n};\n\nXString.prototype.evaluate = function (c) {\n  return this;\n};\n\nXString.prototype.string = function () {\n  return this;\n};\n\nXString.prototype.number = function () {\n  return new XNumber(this.str);\n};\n\nXString.prototype.bool = function () {\n  return new XBoolean(this.str);\n};\n\nXString.prototype.nodeset = function () {\n  throw new Error(\"Cannot convert string to nodeset\");\n};\n\nXString.prototype.stringValue = function () {\n  return this.str;\n};\n\nXString.prototype.numberValue = function () {\n  return this.number().numberValue();\n};\n\nXString.prototype.booleanValue = function () {\n  return this.bool().booleanValue();\n};\n\nXString.prototype.equals = function (r) {\n  if (Utilities.instance_of(r, XBoolean)) {\n    return this.bool().equals(r);\n  }\n\n  if (Utilities.instance_of(r, XNumber)) {\n    return this.number().equals(r);\n  }\n\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithString(this, Operators.equals);\n  }\n\n  return new XBoolean(this.str == r.str);\n};\n\nXString.prototype.notequal = function (r) {\n  if (Utilities.instance_of(r, XBoolean)) {\n    return this.bool().notequal(r);\n  }\n\n  if (Utilities.instance_of(r, XNumber)) {\n    return this.number().notequal(r);\n  }\n\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithString(this, Operators.notequal);\n  }\n\n  return new XBoolean(this.str != r.str);\n};\n\nXString.prototype.lessthan = function (r) {\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithNumber(this.number(), Operators.greaterthanorequal);\n  }\n\n  return this.number().lessthan(r.number());\n};\n\nXString.prototype.greaterthan = function (r) {\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithNumber(this.number(), Operators.lessthanorequal);\n  }\n\n  return this.number().greaterthan(r.number());\n};\n\nXString.prototype.lessthanorequal = function (r) {\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithNumber(this.number(), Operators.greaterthan);\n  }\n\n  return this.number().lessthanorequal(r.number());\n};\n\nXString.prototype.greaterthanorequal = function (r) {\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithNumber(this.number(), Operators.lessthan);\n  }\n\n  return this.number().greaterthanorequal(r.number());\n}; // XNumber ///////////////////////////////////////////////////////////////////\n\n\nXNumber.prototype = new Expression();\nXNumber.prototype.constructor = XNumber;\nXNumber.superclass = Expression.prototype;\n\nfunction XNumber(n) {\n  if (arguments.length > 0) {\n    this.init(n);\n  }\n}\n\nXNumber.prototype.init = function (n) {\n  this.num = Number(n);\n};\n\nXNumber.prototype.toString = function () {\n  return this.num;\n};\n\nXNumber.prototype.evaluate = function (c) {\n  return this;\n};\n\nXNumber.prototype.string = function () {\n  return new XString(this.num);\n};\n\nXNumber.prototype.number = function () {\n  return this;\n};\n\nXNumber.prototype.bool = function () {\n  return new XBoolean(this.num);\n};\n\nXNumber.prototype.nodeset = function () {\n  throw new Error(\"Cannot convert number to nodeset\");\n};\n\nXNumber.prototype.stringValue = function () {\n  return this.string().stringValue();\n};\n\nXNumber.prototype.numberValue = function () {\n  return this.num;\n};\n\nXNumber.prototype.booleanValue = function () {\n  return this.bool().booleanValue();\n};\n\nXNumber.prototype.negate = function () {\n  return new XNumber(-this.num);\n};\n\nXNumber.prototype.equals = function (r) {\n  if (Utilities.instance_of(r, XBoolean)) {\n    return this.bool().equals(r);\n  }\n\n  if (Utilities.instance_of(r, XString)) {\n    return this.equals(r.number());\n  }\n\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithNumber(this, Operators.equals);\n  }\n\n  return new XBoolean(this.num == r.num);\n};\n\nXNumber.prototype.notequal = function (r) {\n  if (Utilities.instance_of(r, XBoolean)) {\n    return this.bool().notequal(r);\n  }\n\n  if (Utilities.instance_of(r, XString)) {\n    return this.notequal(r.number());\n  }\n\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithNumber(this, Operators.notequal);\n  }\n\n  return new XBoolean(this.num != r.num);\n};\n\nXNumber.prototype.lessthan = function (r) {\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithNumber(this, Operators.greaterthanorequal);\n  }\n\n  if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {\n    return this.lessthan(r.number());\n  }\n\n  return new XBoolean(this.num < r.num);\n};\n\nXNumber.prototype.greaterthan = function (r) {\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithNumber(this, Operators.lessthanorequal);\n  }\n\n  if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {\n    return this.greaterthan(r.number());\n  }\n\n  return new XBoolean(this.num > r.num);\n};\n\nXNumber.prototype.lessthanorequal = function (r) {\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithNumber(this, Operators.greaterthan);\n  }\n\n  if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {\n    return this.lessthanorequal(r.number());\n  }\n\n  return new XBoolean(this.num <= r.num);\n};\n\nXNumber.prototype.greaterthanorequal = function (r) {\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithNumber(this, Operators.lessthan);\n  }\n\n  if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {\n    return this.greaterthanorequal(r.number());\n  }\n\n  return new XBoolean(this.num >= r.num);\n};\n\nXNumber.prototype.plus = function (r) {\n  return new XNumber(this.num + r.num);\n};\n\nXNumber.prototype.minus = function (r) {\n  return new XNumber(this.num - r.num);\n};\n\nXNumber.prototype.multiply = function (r) {\n  return new XNumber(this.num * r.num);\n};\n\nXNumber.prototype.div = function (r) {\n  return new XNumber(this.num / r.num);\n};\n\nXNumber.prototype.mod = function (r) {\n  return new XNumber(this.num % r.num);\n}; // XBoolean //////////////////////////////////////////////////////////////////\n\n\nXBoolean.prototype = new Expression();\nXBoolean.prototype.constructor = XBoolean;\nXBoolean.superclass = Expression.prototype;\n\nfunction XBoolean(b) {\n  if (arguments.length > 0) {\n    this.init(b);\n  }\n}\n\nXBoolean.prototype.init = function (b) {\n  this.b = Boolean(b);\n};\n\nXBoolean.prototype.toString = function () {\n  return this.b.toString();\n};\n\nXBoolean.prototype.evaluate = function (c) {\n  return this;\n};\n\nXBoolean.prototype.string = function () {\n  return new XString(this.b);\n};\n\nXBoolean.prototype.number = function () {\n  return new XNumber(this.b);\n};\n\nXBoolean.prototype.bool = function () {\n  return this;\n};\n\nXBoolean.prototype.nodeset = function () {\n  throw new Error(\"Cannot convert boolean to nodeset\");\n};\n\nXBoolean.prototype.stringValue = function () {\n  return this.string().stringValue();\n};\n\nXBoolean.prototype.numberValue = function () {\n  return this.num().numberValue();\n};\n\nXBoolean.prototype.booleanValue = function () {\n  return this.b;\n};\n\nXBoolean.prototype.not = function () {\n  return new XBoolean(!this.b);\n};\n\nXBoolean.prototype.equals = function (r) {\n  if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {\n    return this.equals(r.bool());\n  }\n\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithBoolean(this, Operators.equals);\n  }\n\n  return new XBoolean(this.b == r.b);\n};\n\nXBoolean.prototype.notequal = function (r) {\n  if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {\n    return this.notequal(r.bool());\n  }\n\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithBoolean(this, Operators.notequal);\n  }\n\n  return new XBoolean(this.b != r.b);\n};\n\nXBoolean.prototype.lessthan = function (r) {\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithNumber(this.number(), Operators.greaterthanorequal);\n  }\n\n  return this.number().lessthan(r.number());\n};\n\nXBoolean.prototype.greaterthan = function (r) {\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithNumber(this.number(), Operators.lessthanorequal);\n  }\n\n  return this.number().greaterthan(r.number());\n};\n\nXBoolean.prototype.lessthanorequal = function (r) {\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithNumber(this.number(), Operators.greaterthan);\n  }\n\n  return this.number().lessthanorequal(r.number());\n};\n\nXBoolean.prototype.greaterthanorequal = function (r) {\n  if (Utilities.instance_of(r, XNodeSet)) {\n    return r.compareWithNumber(this.number(), Operators.lessthan);\n  }\n\n  return this.number().greaterthanorequal(r.number());\n}; // AVLTree ///////////////////////////////////////////////////////////////////\n\n\nAVLTree.prototype = new Object();\nAVLTree.prototype.constructor = AVLTree;\nAVLTree.superclass = Object.prototype;\n\nfunction AVLTree(n) {\n  this.init(n);\n}\n\nAVLTree.prototype.init = function (n) {\n  this.left = null;\n  this.right = null;\n  this.node = n;\n  this.depth = 1;\n};\n\nAVLTree.prototype.balance = function () {\n  var ldepth = this.left == null ? 0 : this.left.depth;\n  var rdepth = this.right == null ? 0 : this.right.depth;\n\n  if (ldepth > rdepth + 1) {\n    // LR or LL rotation\n    var lldepth = this.left.left == null ? 0 : this.left.left.depth;\n    var lrdepth = this.left.right == null ? 0 : this.left.right.depth;\n\n    if (lldepth < lrdepth) {\n      // LR rotation consists of a RR rotation of the left child\n      this.left.rotateRR(); // plus a LL rotation of this node, which happens anyway \n    }\n\n    this.rotateLL();\n  } else if (ldepth + 1 < rdepth) {\n    // RR or RL rorarion\n    var rrdepth = this.right.right == null ? 0 : this.right.right.depth;\n    var rldepth = this.right.left == null ? 0 : this.right.left.depth;\n\n    if (rldepth > rrdepth) {\n      // RR rotation consists of a LL rotation of the right child\n      this.right.rotateLL(); // plus a RR rotation of this node, which happens anyway \n    }\n\n    this.rotateRR();\n  }\n};\n\nAVLTree.prototype.rotateLL = function () {\n  // the left side is too long => rotate from the left (_not_ leftwards)\n  var nodeBefore = this.node;\n  var rightBefore = this.right;\n  this.node = this.left.node;\n  this.right = this.left;\n  this.left = this.left.left;\n  this.right.left = this.right.right;\n  this.right.right = rightBefore;\n  this.right.node = nodeBefore;\n  this.right.updateInNewLocation();\n  this.updateInNewLocation();\n};\n\nAVLTree.prototype.rotateRR = function () {\n  // the right side is too long => rotate from the right (_not_ rightwards)\n  var nodeBefore = this.node;\n  var leftBefore = this.left;\n  this.node = this.right.node;\n  this.left = this.right;\n  this.right = this.right.right;\n  this.left.right = this.left.left;\n  this.left.left = leftBefore;\n  this.left.node = nodeBefore;\n  this.left.updateInNewLocation();\n  this.updateInNewLocation();\n};\n\nAVLTree.prototype.updateInNewLocation = function () {\n  this.getDepthFromChildren();\n};\n\nAVLTree.prototype.getDepthFromChildren = function () {\n  this.depth = this.node == null ? 0 : 1;\n\n  if (this.left != null) {\n    this.depth = this.left.depth + 1;\n  }\n\n  if (this.right != null && this.depth <= this.right.depth) {\n    this.depth = this.right.depth + 1;\n  }\n};\n\nAVLTree.prototype.order = function (n1, n2) {\n  if (n1 === n2) {\n    return 0;\n  }\n\n  var d1 = 0;\n  var d2 = 0;\n\n  for (var m1 = n1; m1 != null; m1 = m1.parentNode) {\n    d1++;\n  }\n\n  for (var m2 = n2; m2 != null; m2 = m2.parentNode) {\n    d2++;\n  }\n\n  if (d1 > d2) {\n    while (d1 > d2) {\n      n1 = n1.parentNode;\n      d1--;\n    }\n\n    if (n1 == n2) {\n      return 1;\n    }\n  } else if (d2 > d1) {\n    while (d2 > d1) {\n      n2 = n2.parentNode;\n      d2--;\n    }\n\n    if (n1 == n2) {\n      return -1;\n    }\n  }\n\n  while (n1.parentNode != n2.parentNode) {\n    n1 = n1.parentNode;\n    n2 = n2.parentNode;\n  }\n\n  while (n1.previousSibling != null && n2.previousSibling != null) {\n    n1 = n1.previousSibling;\n    n2 = n2.previousSibling;\n  }\n\n  if (n1.previousSibling == null) {\n    return -1;\n  }\n\n  return 1;\n};\n\nAVLTree.prototype.add = function (n) {\n  if (n === this.node) {\n    return false;\n  }\n\n  var o = this.order(n, this.node);\n  var ret = false;\n\n  if (o == -1) {\n    if (this.left == null) {\n      this.left = new AVLTree(n);\n      ret = true;\n    } else {\n      ret = this.left.add(n);\n\n      if (ret) {\n        this.balance();\n      }\n    }\n  } else if (o == 1) {\n    if (this.right == null) {\n      this.right = new AVLTree(n);\n      ret = true;\n    } else {\n      ret = this.right.add(n);\n\n      if (ret) {\n        this.balance();\n      }\n    }\n  }\n\n  if (ret) {\n    this.getDepthFromChildren();\n  }\n\n  return ret;\n}; // XNodeSet //////////////////////////////////////////////////////////////////\n\n\nXNodeSet.prototype = new Expression();\nXNodeSet.prototype.constructor = XNodeSet;\nXNodeSet.superclass = Expression.prototype;\n\nfunction XNodeSet() {\n  this.init();\n}\n\nXNodeSet.prototype.init = function () {\n  this.tree = null;\n  this.size = 0;\n};\n\nXNodeSet.prototype.toString = function () {\n  var p = this.first();\n\n  if (p == null) {\n    return \"\";\n  }\n\n  return this.stringForNode(p);\n};\n\nXNodeSet.prototype.evaluate = function (c) {\n  return this;\n};\n\nXNodeSet.prototype.string = function () {\n  return new XString(this.toString());\n};\n\nXNodeSet.prototype.stringValue = function () {\n  return this.toString();\n};\n\nXNodeSet.prototype.number = function () {\n  return new XNumber(this.string());\n};\n\nXNodeSet.prototype.numberValue = function () {\n  return Number(this.string());\n};\n\nXNodeSet.prototype.bool = function () {\n  return new XBoolean(this.tree != null);\n};\n\nXNodeSet.prototype.booleanValue = function () {\n  return this.tree != null;\n};\n\nXNodeSet.prototype.nodeset = function () {\n  return this;\n};\n\nXNodeSet.prototype.stringForNode = function (n) {\n  if (n.nodeType == 9\n  /*Node.DOCUMENT_NODE*/\n  ) {\n      n = n.documentElement;\n    }\n\n  if (n.nodeType == 1\n  /*Node.ELEMENT_NODE*/\n  ) {\n      return this.stringForNodeRec(n);\n    }\n\n  if (n.isNamespaceNode) {\n    return n.namespace;\n  }\n\n  return n.nodeValue;\n};\n\nXNodeSet.prototype.stringForNodeRec = function (n) {\n  var s = \"\";\n\n  for (var n2 = n.firstChild; n2 != null; n2 = n2.nextSibling) {\n    if (n2.nodeType == 3\n    /*Node.TEXT_NODE*/\n    ) {\n        s += n2.nodeValue;\n      } else if (n2.nodeType == 1\n    /*Node.ELEMENT_NODE*/\n    ) {\n        s += this.stringForNodeRec(n2);\n      }\n  }\n\n  return s;\n};\n\nXNodeSet.prototype.first = function () {\n  var p = this.tree;\n\n  if (p == null) {\n    return null;\n  }\n\n  while (p.left != null) {\n    p = p.left;\n  }\n\n  return p.node;\n};\n\nXNodeSet.prototype.add = function (n) {\n  var added;\n\n  if (this.tree == null) {\n    this.tree = new AVLTree(n);\n    added = true;\n  } else {\n    added = this.tree.add(n);\n  }\n\n  if (added) {\n    this.size++;\n  }\n};\n\nXNodeSet.prototype.addArray = function (ns) {\n  for (var i = 0; i < ns.length; i++) {\n    this.add(ns[i]);\n  }\n};\n\nXNodeSet.prototype.toArray = function () {\n  var a = [];\n  this.toArrayRec(this.tree, a);\n  return a;\n};\n\nXNodeSet.prototype.toArrayRec = function (t, a) {\n  if (t != null) {\n    this.toArrayRec(t.left, a);\n    a.push(t.node);\n    this.toArrayRec(t.right, a);\n  }\n};\n\nXNodeSet.prototype.compareWithString = function (r, o) {\n  var a = this.toArray();\n\n  for (var i = 0; i < a.length; i++) {\n    var n = a[i];\n    var l = new XString(this.stringForNode(n));\n    var res = o(l, r);\n\n    if (res.booleanValue()) {\n      return res;\n    }\n  }\n\n  return new XBoolean(false);\n};\n\nXNodeSet.prototype.compareWithNumber = function (r, o) {\n  var a = this.toArray();\n\n  for (var i = 0; i < a.length; i++) {\n    var n = a[i];\n    var l = new XNumber(this.stringForNode(n));\n    var res = o(l, r);\n\n    if (res.booleanValue()) {\n      return res;\n    }\n  }\n\n  return new XBoolean(false);\n};\n\nXNodeSet.prototype.compareWithBoolean = function (r, o) {\n  return o(this.bool(), r);\n};\n\nXNodeSet.prototype.compareWithNodeSet = function (r, o) {\n  var a = this.toArray();\n\n  for (var i = 0; i < a.length; i++) {\n    var n = a[i];\n    var l = new XString(this.stringForNode(n));\n    var b = r.toArray();\n\n    for (var j = 0; j < b.length; j++) {\n      var n2 = b[j];\n      var r = new XString(this.stringForNode(n2));\n      var res = o(l, r);\n\n      if (res.booleanValue()) {\n        return res;\n      }\n    }\n  }\n\n  return new XBoolean(false);\n};\n\nXNodeSet.prototype.equals = function (r) {\n  if (Utilities.instance_of(r, XString)) {\n    return this.compareWithString(r, Operators.equals);\n  }\n\n  if (Utilities.instance_of(r, XNumber)) {\n    return this.compareWithNumber(r, Operators.equals);\n  }\n\n  if (Utilities.instance_of(r, XBoolean)) {\n    return this.compareWithBoolean(r, Operators.equals);\n  }\n\n  return this.compareWithNodeSet(r, Operators.equals);\n};\n\nXNodeSet.prototype.notequal = function (r) {\n  if (Utilities.instance_of(r, XString)) {\n    return this.compareWithString(r, Operators.notequal);\n  }\n\n  if (Utilities.instance_of(r, XNumber)) {\n    return this.compareWithNumber(r, Operators.notequal);\n  }\n\n  if (Utilities.instance_of(r, XBoolean)) {\n    return this.compareWithBoolean(r, Operators.notequal);\n  }\n\n  return this.compareWithNodeSet(r, Operators.notequal);\n};\n\nXNodeSet.prototype.lessthan = function (r) {\n  if (Utilities.instance_of(r, XString)) {\n    return this.compareWithNumber(r.number(), Operators.lessthan);\n  }\n\n  if (Utilities.instance_of(r, XNumber)) {\n    return this.compareWithNumber(r, Operators.lessthan);\n  }\n\n  if (Utilities.instance_of(r, XBoolean)) {\n    return this.compareWithBoolean(r, Operators.lessthan);\n  }\n\n  return this.compareWithNodeSet(r, Operators.lessthan);\n};\n\nXNodeSet.prototype.greaterthan = function (r) {\n  if (Utilities.instance_of(r, XString)) {\n    return this.compareWithNumber(r.number(), Operators.greaterthan);\n  }\n\n  if (Utilities.instance_of(r, XNumber)) {\n    return this.compareWithNumber(r, Operators.greaterthan);\n  }\n\n  if (Utilities.instance_of(r, XBoolean)) {\n    return this.compareWithBoolean(r, Operators.greaterthan);\n  }\n\n  return this.compareWithNodeSet(r, Operators.greaterthan);\n};\n\nXNodeSet.prototype.lessthanorequal = function (r) {\n  if (Utilities.instance_of(r, XString)) {\n    return this.compareWithNumber(r.number(), Operators.lessthanorequal);\n  }\n\n  if (Utilities.instance_of(r, XNumber)) {\n    return this.compareWithNumber(r, Operators.lessthanorequal);\n  }\n\n  if (Utilities.instance_of(r, XBoolean)) {\n    return this.compareWithBoolean(r, Operators.lessthanorequal);\n  }\n\n  return this.compareWithNodeSet(r, Operators.lessthanorequal);\n};\n\nXNodeSet.prototype.greaterthanorequal = function (r) {\n  if (Utilities.instance_of(r, XString)) {\n    return this.compareWithNumber(r.number(), Operators.greaterthanorequal);\n  }\n\n  if (Utilities.instance_of(r, XNumber)) {\n    return this.compareWithNumber(r, Operators.greaterthanorequal);\n  }\n\n  if (Utilities.instance_of(r, XBoolean)) {\n    return this.compareWithBoolean(r, Operators.greaterthanorequal);\n  }\n\n  return this.compareWithNodeSet(r, Operators.greaterthanorequal);\n};\n\nXNodeSet.prototype.union = function (r) {\n  var ns = new XNodeSet();\n  ns.tree = this.tree;\n  ns.size = this.size;\n  ns.addArray(r.toArray());\n  return ns;\n}; // XPathNamespace ////////////////////////////////////////////////////////////\n\n\nXPathNamespace.prototype = new Object();\nXPathNamespace.prototype.constructor = XPathNamespace;\nXPathNamespace.superclass = Object.prototype;\n\nfunction XPathNamespace(pre, ns, p) {\n  this.isXPathNamespace = true;\n  this.ownerDocument = p.ownerDocument;\n  this.nodeName = \"#namespace\";\n  this.prefix = pre;\n  this.localName = pre;\n  this.namespaceURI = ns;\n  this.nodeValue = ns;\n  this.ownerElement = p;\n  this.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE;\n}\n\nXPathNamespace.prototype.toString = function () {\n  return \"{ \\\"\" + this.prefix + \"\\\", \\\"\" + this.namespaceURI + \"\\\" }\";\n}; // Operators /////////////////////////////////////////////////////////////////\n\n\nvar Operators = new Object();\n\nOperators.equals = function (l, r) {\n  return l.equals(r);\n};\n\nOperators.notequal = function (l, r) {\n  return l.notequal(r);\n};\n\nOperators.lessthan = function (l, r) {\n  return l.lessthan(r);\n};\n\nOperators.greaterthan = function (l, r) {\n  return l.greaterthan(r);\n};\n\nOperators.lessthanorequal = function (l, r) {\n  return l.lessthanorequal(r);\n};\n\nOperators.greaterthanorequal = function (l, r) {\n  return l.greaterthanorequal(r);\n}; // XPathContext //////////////////////////////////////////////////////////////\n\n\nXPathContext.prototype = new Object();\nXPathContext.prototype.constructor = XPathContext;\nXPathContext.superclass = Object.prototype;\n\nfunction XPathContext(vr, nr, fr) {\n  this.variableResolver = vr != null ? vr : new VariableResolver();\n  this.namespaceResolver = nr != null ? nr : new NamespaceResolver();\n  this.functionResolver = fr != null ? fr : new FunctionResolver();\n} // VariableResolver //////////////////////////////////////////////////////////\n\n\nVariableResolver.prototype = new Object();\nVariableResolver.prototype.constructor = VariableResolver;\nVariableResolver.superclass = Object.prototype;\n\nfunction VariableResolver() {}\n\nVariableResolver.prototype.getVariable = function (vn, c) {\n  var parts = Utilities.splitQName(vn);\n\n  if (parts[0] != null) {\n    parts[0] = c.namespaceResolver.getNamespace(parts[0], c.expressionContextNode);\n\n    if (parts[0] == null) {\n      throw new Error(\"Cannot resolve QName \" + fn);\n    }\n  }\n\n  return this.getVariableWithName(parts[0], parts[1], c.expressionContextNode);\n};\n\nVariableResolver.prototype.getVariableWithName = function (ns, ln, c) {\n  return null;\n}; // FunctionResolver //////////////////////////////////////////////////////////\n\n\nFunctionResolver.prototype = new Object();\nFunctionResolver.prototype.constructor = FunctionResolver;\nFunctionResolver.superclass = Object.prototype;\n\nfunction FunctionResolver(thisArg) {\n  this.thisArg = thisArg != null ? thisArg : Functions;\n  this.functions = new Object();\n  this.addStandardFunctions();\n}\n\nFunctionResolver.prototype.addStandardFunctions = function () {\n  this.functions[\"{}last\"] = Functions.last;\n  this.functions[\"{}position\"] = Functions.position;\n  this.functions[\"{}count\"] = Functions.count;\n  this.functions[\"{}id\"] = Functions.id;\n  this.functions[\"{}local-name\"] = Functions.localName;\n  this.functions[\"{}namespace-uri\"] = Functions.namespaceURI;\n  this.functions[\"{}name\"] = Functions.name;\n  this.functions[\"{}string\"] = Functions.string;\n  this.functions[\"{}concat\"] = Functions.concat;\n  this.functions[\"{}starts-with\"] = Functions.startsWith;\n  this.functions[\"{}contains\"] = Functions.contains;\n  this.functions[\"{}substring-before\"] = Functions.substringBefore;\n  this.functions[\"{}substring-after\"] = Functions.substringAfter;\n  this.functions[\"{}substring\"] = Functions.substring;\n  this.functions[\"{}string-length\"] = Functions.stringLength;\n  this.functions[\"{}normalize-space\"] = Functions.normalizeSpace;\n  this.functions[\"{}translate\"] = Functions.translate;\n  this.functions[\"{}boolean\"] = Functions.boolean_;\n  this.functions[\"{}not\"] = Functions.not;\n  this.functions[\"{}true\"] = Functions.true_;\n  this.functions[\"{}false\"] = Functions.false_;\n  this.functions[\"{}lang\"] = Functions.lang;\n  this.functions[\"{}number\"] = Functions.number;\n  this.functions[\"{}sum\"] = Functions.sum;\n  this.functions[\"{}floor\"] = Functions.floor;\n  this.functions[\"{}ceiling\"] = Functions.ceiling;\n  this.functions[\"{}round\"] = Functions.round;\n};\n\nFunctionResolver.prototype.addFunction = function (ns, ln, f) {\n  this.functions[\"{\" + ns + \"}\" + ln] = f;\n};\n\nFunctionResolver.prototype.getFunction = function (fn, c) {\n  var parts = Utilities.resolveQName(fn, c.namespaceResolver, c.contextNode, false);\n\n  if (parts[0] == null) {\n    throw new Error(\"Cannot resolve QName \" + fn);\n  }\n\n  return this.getFunctionWithName(parts[0], parts[1], c.contextNode);\n};\n\nFunctionResolver.prototype.getFunctionWithName = function (ns, ln, c) {\n  return this.functions[\"{\" + ns + \"}\" + ln];\n}; // NamespaceResolver /////////////////////////////////////////////////////////\n\n\nNamespaceResolver.prototype = new Object();\nNamespaceResolver.prototype.constructor = NamespaceResolver;\nNamespaceResolver.superclass = Object.prototype;\n\nfunction NamespaceResolver() {}\n\nNamespaceResolver.prototype.getNamespace = function (prefix, n) {\n  if (prefix == \"xml\") {\n    return XPath.XML_NAMESPACE_URI;\n  } else if (prefix == \"xmlns\") {\n    return XPath.XMLNS_NAMESPACE_URI;\n  }\n\n  if (n.nodeType == 9\n  /*Node.DOCUMENT_NODE*/\n  ) {\n      n = n.documentElement;\n    } else if (n.nodeType == 2\n  /*Node.ATTRIBUTE_NODE*/\n  ) {\n      n = PathExpr.prototype.getOwnerElement(n);\n    } else if (n.nodeType != 1\n  /*Node.ELEMENT_NODE*/\n  ) {\n      n = n.parentNode;\n    }\n\n  while (n != null && n.nodeType == 1\n  /*Node.ELEMENT_NODE*/\n  ) {\n    var nnm = n.attributes;\n\n    for (var i = 0; i < nnm.length; i++) {\n      var a = nnm.item(i);\n      var aname = a.nodeName;\n\n      if (aname == \"xmlns\" && prefix == \"\" || aname == \"xmlns:\" + prefix) {\n        return String(a.nodeValue);\n      }\n    }\n\n    n = n.parentNode;\n  }\n\n  return null;\n}; // Functions /////////////////////////////////////////////////////////////////\n\n\nvar Functions = new Object();\n\nFunctions.last = function () {\n  var c = arguments[0];\n\n  if (arguments.length != 1) {\n    throw new Error(\"Function last expects ()\");\n  }\n\n  return new XNumber(c.contextSize);\n};\n\nFunctions.position = function () {\n  var c = arguments[0];\n\n  if (arguments.length != 1) {\n    throw new Error(\"Function position expects ()\");\n  }\n\n  return new XNumber(c.contextPosition);\n};\n\nFunctions.count = function () {\n  var c = arguments[0];\n  var ns;\n\n  if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) {\n    throw new Error(\"Function count expects (node-set)\");\n  }\n\n  return new XNumber(ns.size);\n};\n\nFunctions.id = function () {\n  var c = arguments[0];\n  var id;\n\n  if (arguments.length != 2) {\n    throw new Error(\"Function id expects (object)\");\n  }\n\n  id = arguments[1].evaluate(c);\n\n  if (Utilities.instance_of(id, XNodeSet)) {\n    id = id.toArray().join(\" \");\n  } else {\n    id = id.stringValue();\n  }\n\n  var ids = id.split(/[\\x0d\\x0a\\x09\\x20]+/);\n  var count = 0;\n  var ns = new XNodeSet();\n  var doc = c.contextNode.nodeType == 9\n  /*Node.DOCUMENT_NODE*/\n  ? c.contextNode : c.contextNode.ownerDocument;\n\n  for (var i = 0; i < ids.length; i++) {\n    var n;\n\n    if (doc.getElementById) {\n      n = doc.getElementById(ids[i]);\n    } else {\n      n = Utilities.getElementById(doc, ids[i]);\n    }\n\n    if (n != null) {\n      ns.add(n);\n      count++;\n    }\n  }\n\n  return ns;\n};\n\nFunctions.localName = function () {\n  var c = arguments[0];\n  var n;\n\n  if (arguments.length == 1) {\n    n = c.contextNode;\n  } else if (arguments.length == 2) {\n    n = arguments[1].evaluate(c).first();\n  } else {\n    throw new Error(\"Function local-name expects (node-set?)\");\n  }\n\n  if (n == null) {\n    return new XString(\"\");\n  }\n\n  return new XString(n.localName ? n.localName : n.baseName);\n};\n\nFunctions.namespaceURI = function () {\n  var c = arguments[0];\n  var n;\n\n  if (arguments.length == 1) {\n    n = c.contextNode;\n  } else if (arguments.length == 2) {\n    n = arguments[1].evaluate(c).first();\n  } else {\n    throw new Error(\"Function namespace-uri expects (node-set?)\");\n  }\n\n  if (n == null) {\n    return new XString(\"\");\n  }\n\n  return new XString(n.namespaceURI);\n};\n\nFunctions.name = function () {\n  var c = arguments[0];\n  var n;\n\n  if (arguments.length == 1) {\n    n = c.contextNode;\n  } else if (arguments.length == 2) {\n    n = arguments[1].evaluate(c).first();\n  } else {\n    throw new Error(\"Function name expects (node-set?)\");\n  }\n\n  if (n == null) {\n    return new XString(\"\");\n  }\n\n  if (n.nodeType == 1\n  /*Node.ELEMENT_NODE*/\n  || n.nodeType == 2\n  /*Node.ATTRIBUTE_NODE*/\n  ) {\n      return new XString(n.nodeName);\n    } else if (n.localName == null) {\n    return new XString(\"\");\n  } else {\n    return new XString(n.localName);\n  }\n};\n\nFunctions.string = function () {\n  var c = arguments[0];\n\n  if (arguments.length == 1) {\n    return XNodeSet.prototype.stringForNode(c.contextNode);\n  } else if (arguments.length == 2) {\n    return arguments[1].evaluate(c).string();\n  }\n\n  throw new Error(\"Function string expects (object?)\");\n};\n\nFunctions.concat = function () {\n  var c = arguments[0];\n\n  if (arguments.length < 3) {\n    throw new Error(\"Function concat expects (string, string, string*)\");\n  }\n\n  var s = \"\";\n\n  for (var i = 1; i < arguments.length; i++) {\n    s += arguments[i].evaluate(c).stringValue();\n  }\n\n  return new XString(s);\n};\n\nFunctions.startsWith = function () {\n  var c = arguments[0];\n\n  if (arguments.length != 3) {\n    throw new Error(\"Function startsWith expects (string, string)\");\n  }\n\n  var s1 = arguments[1].evaluate(c).stringValue();\n  var s2 = arguments[2].evaluate(c).stringValue();\n  return new XBoolean(s1.substring(0, s2.length) == s2);\n};\n\nFunctions.contains = function () {\n  var c = arguments[0];\n\n  if (arguments.length != 3) {\n    throw new Error(\"Function contains expects (string, string)\");\n  }\n\n  var s1 = arguments[1].evaluate(c).stringValue();\n  var s2 = arguments[2].evaluate(c).stringValue();\n  return new XBoolean(s1.indexOf(s2) != -1);\n};\n\nFunctions.substringBefore = function () {\n  var c = arguments[0];\n\n  if (arguments.length != 3) {\n    throw new Error(\"Function substring-before expects (string, string)\");\n  }\n\n  var s1 = arguments[1].evaluate(c).stringValue();\n  var s2 = arguments[2].evaluate(c).stringValue();\n  return new XString(s1.substring(0, s1.indexOf(s2)));\n};\n\nFunctions.substringAfter = function () {\n  var c = arguments[0];\n\n  if (arguments.length != 3) {\n    throw new Error(\"Function substring-after expects (string, string)\");\n  }\n\n  var s1 = arguments[1].evaluate(c).stringValue();\n  var s2 = arguments[2].evaluate(c).stringValue();\n\n  if (s2.length == 0) {\n    return new XString(s1);\n  }\n\n  var i = s1.indexOf(s2);\n\n  if (i == -1) {\n    return new XString(\"\");\n  }\n\n  return new XString(s1.substring(s1.indexOf(s2) + 1));\n};\n\nFunctions.substring = function () {\n  var c = arguments[0];\n\n  if (!(arguments.length == 3 || arguments.length == 4)) {\n    throw new Error(\"Function substring expects (string, number, number?)\");\n  }\n\n  var s = arguments[1].evaluate(c).stringValue();\n  var n1 = Math.round(arguments[2].evaluate(c).numberValue()) - 1;\n  var n2 = arguments.length == 4 ? n1 + Math.round(arguments[3].evaluate(c).numberValue()) : undefined;\n  return new XString(s.substring(n1, n2));\n};\n\nFunctions.stringLength = function () {\n  var c = arguments[0];\n  var s;\n\n  if (arguments.length == 1) {\n    s = XNodeSet.prototype.stringForNode(c.contextNode);\n  } else if (arguments.length == 2) {\n    s = arguments[1].evaluate(c).stringValue();\n  } else {\n    throw new Error(\"Function string-length expects (string?)\");\n  }\n\n  return new XNumber(s.length);\n};\n\nFunctions.normalizeSpace = function () {\n  var c = arguments[0];\n  var s;\n\n  if (arguments.length == 1) {\n    s = XNodeSet.prototype.stringForNode(c.contextNode);\n  } else if (arguments.length == 2) {\n    s = arguments[1].evaluate(c).stringValue();\n  } else {\n    throw new Error(\"Function normalize-space expects (string?)\");\n  }\n\n  var i = 0;\n  var j = s.length - 1;\n\n  while (Utilities.isSpace(s.charCodeAt(j))) {\n    j--;\n  }\n\n  var t = \"\";\n\n  while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {\n    i++;\n  }\n\n  while (i <= j) {\n    if (Utilities.isSpace(s.charCodeAt(i))) {\n      t += \" \";\n\n      while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {\n        i++;\n      }\n    } else {\n      t += s.charAt(i);\n      i++;\n    }\n  }\n\n  return new XString(t);\n};\n\nFunctions.translate = function () {\n  var c = arguments[0];\n\n  if (arguments.length != 4) {\n    throw new Error(\"Function translate expects (string, string, string)\");\n  }\n\n  var s1 = arguments[1].evaluate(c).stringValue();\n  var s2 = arguments[2].evaluate(c).stringValue();\n  var s3 = arguments[3].evaluate(c).stringValue();\n  var map = [];\n\n  for (var i = 0; i < s2.length; i++) {\n    var j = s2.charCodeAt(i);\n\n    if (map[j] == undefined) {\n      var k = i > s3.length ? \"\" : s3.charAt(i);\n      map[j] = k;\n    }\n  }\n\n  var t = \"\";\n\n  for (var i = 0; i < s1.length; i++) {\n    var c = s1.charCodeAt(i);\n    var r = map[c];\n\n    if (r == undefined) {\n      t += s1.charAt(i);\n    } else {\n      t += r;\n    }\n  }\n\n  return new XString(t);\n};\n\nFunctions.boolean_ = function () {\n  var c = arguments[0];\n\n  if (arguments.length != 2) {\n    throw new Error(\"Function boolean expects (object)\");\n  }\n\n  return arguments[1].evaluate(c).bool();\n};\n\nFunctions.not = function () {\n  var c = arguments[0];\n\n  if (arguments.length != 2) {\n    throw new Error(\"Function not expects (object)\");\n  }\n\n  return arguments[1].evaluate(c).bool().not();\n};\n\nFunctions.true_ = function () {\n  if (arguments.length != 1) {\n    throw new Error(\"Function true expects ()\");\n  }\n\n  return new XBoolean(true);\n};\n\nFunctions.false_ = function () {\n  if (arguments.length != 1) {\n    throw new Error(\"Function false expects ()\");\n  }\n\n  return new XBoolean(false);\n};\n\nFunctions.lang = function () {\n  var c = arguments[0];\n\n  if (arguments.length != 2) {\n    throw new Error(\"Function lang expects (string)\");\n  }\n\n  var lang;\n\n  for (var n = c.contextNode; n != null && n.nodeType != 9\n  /*Node.DOCUMENT_NODE*/\n  ; n = n.parentNode) {\n    var a = n.getAttributeNS(XPath.XML_NAMESPACE_URI, \"lang\");\n\n    if (a != null) {\n      lang = String(a);\n      break;\n    }\n  }\n\n  if (lang == null) {\n    return new XBoolean(false);\n  }\n\n  var s = arguments[1].evaluate(c).stringValue();\n  return new XBoolean(lang.substring(0, s.length) == s && (lang.length == s.length || lang.charAt(s.length) == '-'));\n};\n\nFunctions.number = function () {\n  var c = arguments[0];\n\n  if (!(arguments.length == 1 || arguments.length == 2)) {\n    throw new Error(\"Function number expects (object?)\");\n  }\n\n  if (arguments.length == 1) {\n    return new XNumber(XNodeSet.prototype.stringForNode(c.contextNode));\n  }\n\n  return arguments[1].evaluate(c).number();\n};\n\nFunctions.sum = function () {\n  var c = arguments[0];\n  var ns;\n\n  if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) {\n    throw new Error(\"Function sum expects (node-set)\");\n  }\n\n  ns = ns.toArray();\n  var n = 0;\n\n  for (var i = 0; i < ns.length; i++) {\n    n += new XNumber(XNodeSet.prototype.stringForNode(ns[i])).numberValue();\n  }\n\n  return new XNumber(n);\n};\n\nFunctions.floor = function () {\n  var c = arguments[0];\n\n  if (arguments.length != 2) {\n    throw new Error(\"Function floor expects (number)\");\n  }\n\n  return new XNumber(Math.floor(arguments[1].evaluate(c).numberValue()));\n};\n\nFunctions.ceiling = function () {\n  var c = arguments[0];\n\n  if (arguments.length != 2) {\n    throw new Error(\"Function ceiling expects (number)\");\n  }\n\n  return new XNumber(Math.ceil(arguments[1].evaluate(c).numberValue()));\n};\n\nFunctions.round = function () {\n  var c = arguments[0];\n\n  if (arguments.length != 2) {\n    throw new Error(\"Function round expects (number)\");\n  }\n\n  return new XNumber(Math.round(arguments[1].evaluate(c).numberValue()));\n}; // Utilities /////////////////////////////////////////////////////////////////\n\n\nvar Utilities = new Object();\n\nUtilities.splitQName = function (qn) {\n  var i = qn.indexOf(\":\");\n\n  if (i == -1) {\n    return [null, qn];\n  }\n\n  return [qn.substring(0, i), qn.substring(i + 1)];\n};\n\nUtilities.resolveQName = function (qn, nr, n, useDefault) {\n  var parts = Utilities.splitQName(qn);\n\n  if (parts[0] != null) {\n    parts[0] = nr.getNamespace(parts[0], n);\n  } else {\n    if (useDefault) {\n      parts[0] = nr.getNamespace(\"\", n);\n\n      if (parts[0] == null) {\n        parts[0] = \"\";\n      }\n    } else {\n      parts[0] = \"\";\n    }\n  }\n\n  return parts;\n};\n\nUtilities.isSpace = function (c) {\n  return c == 0x9 || c == 0xd || c == 0xa || c == 0x20;\n};\n\nUtilities.isLetter = function (c) {\n  return c >= 0x0041 && c <= 0x005A || c >= 0x0061 && c <= 0x007A || c >= 0x00C0 && c <= 0x00D6 || c >= 0x00D8 && c <= 0x00F6 || c >= 0x00F8 && c <= 0x00FF || c >= 0x0100 && c <= 0x0131 || c >= 0x0134 && c <= 0x013E || c >= 0x0141 && c <= 0x0148 || c >= 0x014A && c <= 0x017E || c >= 0x0180 && c <= 0x01C3 || c >= 0x01CD && c <= 0x01F0 || c >= 0x01F4 && c <= 0x01F5 || c >= 0x01FA && c <= 0x0217 || c >= 0x0250 && c <= 0x02A8 || c >= 0x02BB && c <= 0x02C1 || c == 0x0386 || c >= 0x0388 && c <= 0x038A || c == 0x038C || c >= 0x038E && c <= 0x03A1 || c >= 0x03A3 && c <= 0x03CE || c >= 0x03D0 && c <= 0x03D6 || c == 0x03DA || c == 0x03DC || c == 0x03DE || c == 0x03E0 || c >= 0x03E2 && c <= 0x03F3 || c >= 0x0401 && c <= 0x040C || c >= 0x040E && c <= 0x044F || c >= 0x0451 && c <= 0x045C || c >= 0x045E && c <= 0x0481 || c >= 0x0490 && c <= 0x04C4 || c >= 0x04C7 && c <= 0x04C8 || c >= 0x04CB && c <= 0x04CC || c >= 0x04D0 && c <= 0x04EB || c >= 0x04EE && c <= 0x04F5 || c >= 0x04F8 && c <= 0x04F9 || c >= 0x0531 && c <= 0x0556 || c == 0x0559 || c >= 0x0561 && c <= 0x0586 || c >= 0x05D0 && c <= 0x05EA || c >= 0x05F0 && c <= 0x05F2 || c >= 0x0621 && c <= 0x063A || c >= 0x0641 && c <= 0x064A || c >= 0x0671 && c <= 0x06B7 || c >= 0x06BA && c <= 0x06BE || c >= 0x06C0 && c <= 0x06CE || c >= 0x06D0 && c <= 0x06D3 || c == 0x06D5 || c >= 0x06E5 && c <= 0x06E6 || c >= 0x0905 && c <= 0x0939 || c == 0x093D || c >= 0x0958 && c <= 0x0961 || c >= 0x0985 && c <= 0x098C || c >= 0x098F && c <= 0x0990 || c >= 0x0993 && c <= 0x09A8 || c >= 0x09AA && c <= 0x09B0 || c == 0x09B2 || c >= 0x09B6 && c <= 0x09B9 || c >= 0x09DC && c <= 0x09DD || c >= 0x09DF && c <= 0x09E1 || c >= 0x09F0 && c <= 0x09F1 || c >= 0x0A05 && c <= 0x0A0A || c >= 0x0A0F && c <= 0x0A10 || c >= 0x0A13 && c <= 0x0A28 || c >= 0x0A2A && c <= 0x0A30 || c >= 0x0A32 && c <= 0x0A33 || c >= 0x0A35 && c <= 0x0A36 || c >= 0x0A38 && c <= 0x0A39 || c >= 0x0A59 && c <= 0x0A5C || c == 0x0A5E || c >= 0x0A72 && c <= 0x0A74 || c >= 0x0A85 && c <= 0x0A8B || c == 0x0A8D || c >= 0x0A8F && c <= 0x0A91 || c >= 0x0A93 && c <= 0x0AA8 || c >= 0x0AAA && c <= 0x0AB0 || c >= 0x0AB2 && c <= 0x0AB3 || c >= 0x0AB5 && c <= 0x0AB9 || c == 0x0ABD || c == 0x0AE0 || c >= 0x0B05 && c <= 0x0B0C || c >= 0x0B0F && c <= 0x0B10 || c >= 0x0B13 && c <= 0x0B28 || c >= 0x0B2A && c <= 0x0B30 || c >= 0x0B32 && c <= 0x0B33 || c >= 0x0B36 && c <= 0x0B39 || c == 0x0B3D || c >= 0x0B5C && c <= 0x0B5D || c >= 0x0B5F && c <= 0x0B61 || c >= 0x0B85 && c <= 0x0B8A || c >= 0x0B8E && c <= 0x0B90 || c >= 0x0B92 && c <= 0x0B95 || c >= 0x0B99 && c <= 0x0B9A || c == 0x0B9C || c >= 0x0B9E && c <= 0x0B9F || c >= 0x0BA3 && c <= 0x0BA4 || c >= 0x0BA8 && c <= 0x0BAA || c >= 0x0BAE && c <= 0x0BB5 || c >= 0x0BB7 && c <= 0x0BB9 || c >= 0x0C05 && c <= 0x0C0C || c >= 0x0C0E && c <= 0x0C10 || c >= 0x0C12 && c <= 0x0C28 || c >= 0x0C2A && c <= 0x0C33 || c >= 0x0C35 && c <= 0x0C39 || c >= 0x0C60 && c <= 0x0C61 || c >= 0x0C85 && c <= 0x0C8C || c >= 0x0C8E && c <= 0x0C90 || c >= 0x0C92 && c <= 0x0CA8 || c >= 0x0CAA && c <= 0x0CB3 || c >= 0x0CB5 && c <= 0x0CB9 || c == 0x0CDE || c >= 0x0CE0 && c <= 0x0CE1 || c >= 0x0D05 && c <= 0x0D0C || c >= 0x0D0E && c <= 0x0D10 || c >= 0x0D12 && c <= 0x0D28 || c >= 0x0D2A && c <= 0x0D39 || c >= 0x0D60 && c <= 0x0D61 || c >= 0x0E01 && c <= 0x0E2E || c == 0x0E30 || c >= 0x0E32 && c <= 0x0E33 || c >= 0x0E40 && c <= 0x0E45 || c >= 0x0E81 && c <= 0x0E82 || c == 0x0E84 || c >= 0x0E87 && c <= 0x0E88 || c == 0x0E8A || c == 0x0E8D || c >= 0x0E94 && c <= 0x0E97 || c >= 0x0E99 && c <= 0x0E9F || c >= 0x0EA1 && c <= 0x0EA3 || c == 0x0EA5 || c == 0x0EA7 || c >= 0x0EAA && c <= 0x0EAB || c >= 0x0EAD && c <= 0x0EAE || c == 0x0EB0 || c >= 0x0EB2 && c <= 0x0EB3 || c == 0x0EBD || c >= 0x0EC0 && c <= 0x0EC4 || c >= 0x0F40 && c <= 0x0F47 || c >= 0x0F49 && c <= 0x0F69 || c >= 0x10A0 && c <= 0x10C5 || c >= 0x10D0 && c <= 0x10F6 || c == 0x1100 || c >= 0x1102 && c <= 0x1103 || c >= 0x1105 && c <= 0x1107 || c == 0x1109 || c >= 0x110B && c <= 0x110C || c >= 0x110E && c <= 0x1112 || c == 0x113C || c == 0x113E || c == 0x1140 || c == 0x114C || c == 0x114E || c == 0x1150 || c >= 0x1154 && c <= 0x1155 || c == 0x1159 || c >= 0x115F && c <= 0x1161 || c == 0x1163 || c == 0x1165 || c == 0x1167 || c == 0x1169 || c >= 0x116D && c <= 0x116E || c >= 0x1172 && c <= 0x1173 || c == 0x1175 || c == 0x119E || c == 0x11A8 || c == 0x11AB || c >= 0x11AE && c <= 0x11AF || c >= 0x11B7 && c <= 0x11B8 || c == 0x11BA || c >= 0x11BC && c <= 0x11C2 || c == 0x11EB || c == 0x11F0 || c == 0x11F9 || c >= 0x1E00 && c <= 0x1E9B || c >= 0x1EA0 && c <= 0x1EF9 || c >= 0x1F00 && c <= 0x1F15 || c >= 0x1F18 && c <= 0x1F1D || c >= 0x1F20 && c <= 0x1F45 || c >= 0x1F48 && c <= 0x1F4D || c >= 0x1F50 && c <= 0x1F57 || c == 0x1F59 || c == 0x1F5B || c == 0x1F5D || c >= 0x1F5F && c <= 0x1F7D || c >= 0x1F80 && c <= 0x1FB4 || c >= 0x1FB6 && c <= 0x1FBC || c == 0x1FBE || c >= 0x1FC2 && c <= 0x1FC4 || c >= 0x1FC6 && c <= 0x1FCC || c >= 0x1FD0 && c <= 0x1FD3 || c >= 0x1FD6 && c <= 0x1FDB || c >= 0x1FE0 && c <= 0x1FEC || c >= 0x1FF2 && c <= 0x1FF4 || c >= 0x1FF6 && c <= 0x1FFC || c == 0x2126 || c >= 0x212A && c <= 0x212B || c == 0x212E || c >= 0x2180 && c <= 0x2182 || c >= 0x3041 && c <= 0x3094 || c >= 0x30A1 && c <= 0x30FA || c >= 0x3105 && c <= 0x312C || c >= 0xAC00 && c <= 0xD7A3 || c >= 0x4E00 && c <= 0x9FA5 || c == 0x3007 || c >= 0x3021 && c <= 0x3029;\n};\n\nUtilities.isNCNameChar = function (c) {\n  return c >= 0x0030 && c <= 0x0039 || c >= 0x0660 && c <= 0x0669 || c >= 0x06F0 && c <= 0x06F9 || c >= 0x0966 && c <= 0x096F || c >= 0x09E6 && c <= 0x09EF || c >= 0x0A66 && c <= 0x0A6F || c >= 0x0AE6 && c <= 0x0AEF || c >= 0x0B66 && c <= 0x0B6F || c >= 0x0BE7 && c <= 0x0BEF || c >= 0x0C66 && c <= 0x0C6F || c >= 0x0CE6 && c <= 0x0CEF || c >= 0x0D66 && c <= 0x0D6F || c >= 0x0E50 && c <= 0x0E59 || c >= 0x0ED0 && c <= 0x0ED9 || c >= 0x0F20 && c <= 0x0F29 || c == 0x002E || c == 0x002D || c == 0x005F || Utilities.isLetter(c) || c >= 0x0300 && c <= 0x0345 || c >= 0x0360 && c <= 0x0361 || c >= 0x0483 && c <= 0x0486 || c >= 0x0591 && c <= 0x05A1 || c >= 0x05A3 && c <= 0x05B9 || c >= 0x05BB && c <= 0x05BD || c == 0x05BF || c >= 0x05C1 && c <= 0x05C2 || c == 0x05C4 || c >= 0x064B && c <= 0x0652 || c == 0x0670 || c >= 0x06D6 && c <= 0x06DC || c >= 0x06DD && c <= 0x06DF || c >= 0x06E0 && c <= 0x06E4 || c >= 0x06E7 && c <= 0x06E8 || c >= 0x06EA && c <= 0x06ED || c >= 0x0901 && c <= 0x0903 || c == 0x093C || c >= 0x093E && c <= 0x094C || c == 0x094D || c >= 0x0951 && c <= 0x0954 || c >= 0x0962 && c <= 0x0963 || c >= 0x0981 && c <= 0x0983 || c == 0x09BC || c == 0x09BE || c == 0x09BF || c >= 0x09C0 && c <= 0x09C4 || c >= 0x09C7 && c <= 0x09C8 || c >= 0x09CB && c <= 0x09CD || c == 0x09D7 || c >= 0x09E2 && c <= 0x09E3 || c == 0x0A02 || c == 0x0A3C || c == 0x0A3E || c == 0x0A3F || c >= 0x0A40 && c <= 0x0A42 || c >= 0x0A47 && c <= 0x0A48 || c >= 0x0A4B && c <= 0x0A4D || c >= 0x0A70 && c <= 0x0A71 || c >= 0x0A81 && c <= 0x0A83 || c == 0x0ABC || c >= 0x0ABE && c <= 0x0AC5 || c >= 0x0AC7 && c <= 0x0AC9 || c >= 0x0ACB && c <= 0x0ACD || c >= 0x0B01 && c <= 0x0B03 || c == 0x0B3C || c >= 0x0B3E && c <= 0x0B43 || c >= 0x0B47 && c <= 0x0B48 || c >= 0x0B4B && c <= 0x0B4D || c >= 0x0B56 && c <= 0x0B57 || c >= 0x0B82 && c <= 0x0B83 || c >= 0x0BBE && c <= 0x0BC2 || c >= 0x0BC6 && c <= 0x0BC8 || c >= 0x0BCA && c <= 0x0BCD || c == 0x0BD7 || c >= 0x0C01 && c <= 0x0C03 || c >= 0x0C3E && c <= 0x0C44 || c >= 0x0C46 && c <= 0x0C48 || c >= 0x0C4A && c <= 0x0C4D || c >= 0x0C55 && c <= 0x0C56 || c >= 0x0C82 && c <= 0x0C83 || c >= 0x0CBE && c <= 0x0CC4 || c >= 0x0CC6 && c <= 0x0CC8 || c >= 0x0CCA && c <= 0x0CCD || c >= 0x0CD5 && c <= 0x0CD6 || c >= 0x0D02 && c <= 0x0D03 || c >= 0x0D3E && c <= 0x0D43 || c >= 0x0D46 && c <= 0x0D48 || c >= 0x0D4A && c <= 0x0D4D || c == 0x0D57 || c == 0x0E31 || c >= 0x0E34 && c <= 0x0E3A || c >= 0x0E47 && c <= 0x0E4E || c == 0x0EB1 || c >= 0x0EB4 && c <= 0x0EB9 || c >= 0x0EBB && c <= 0x0EBC || c >= 0x0EC8 && c <= 0x0ECD || c >= 0x0F18 && c <= 0x0F19 || c == 0x0F35 || c == 0x0F37 || c == 0x0F39 || c == 0x0F3E || c == 0x0F3F || c >= 0x0F71 && c <= 0x0F84 || c >= 0x0F86 && c <= 0x0F8B || c >= 0x0F90 && c <= 0x0F95 || c == 0x0F97 || c >= 0x0F99 && c <= 0x0FAD || c >= 0x0FB1 && c <= 0x0FB7 || c == 0x0FB9 || c >= 0x20D0 && c <= 0x20DC || c == 0x20E1 || c >= 0x302A && c <= 0x302F || c == 0x3099 || c == 0x309A || c == 0x00B7 || c == 0x02D0 || c == 0x02D1 || c == 0x0387 || c == 0x0640 || c == 0x0E46 || c == 0x0EC6 || c == 0x3005 || c >= 0x3031 && c <= 0x3035 || c >= 0x309D && c <= 0x309E || c >= 0x30FC && c <= 0x30FE;\n};\n\nUtilities.coalesceText = function (n) {\n  for (var m = n.firstChild; m != null; m = m.nextSibling) {\n    if (m.nodeType == 3\n    /*Node.TEXT_NODE*/\n    || m.nodeType == 4\n    /*Node.CDATA_SECTION_NODE*/\n    ) {\n        var s = m.nodeValue;\n        var first = m;\n        m = m.nextSibling;\n\n        while (m != null && (m.nodeType == 3\n        /*Node.TEXT_NODE*/\n        || m.nodeType == 4\n        /*Node.CDATA_SECTION_NODE*/\n        )) {\n          s += m.nodeValue;\n          var del = m;\n          m = m.nextSibling;\n          del.parentNode.removeChild(del);\n        }\n\n        if (first.nodeType == 4\n        /*Node.CDATA_SECTION_NODE*/\n        ) {\n            var p = first.parentNode;\n\n            if (first.nextSibling == null) {\n              p.removeChild(first);\n              p.appendChild(p.ownerDocument.createTextNode(s));\n            } else {\n              var next = first.nextSibling;\n              p.removeChild(first);\n              p.insertBefore(p.ownerDocument.createTextNode(s), next);\n            }\n          } else {\n          first.nodeValue = s;\n        }\n\n        if (m == null) {\n          break;\n        }\n      } else if (m.nodeType == 1\n    /*Node.ELEMENT_NODE*/\n    ) {\n        Utilities.coalesceText(m);\n      }\n  }\n};\n\nUtilities.instance_of = function (o, c) {\n  while (o != null) {\n    if (o.constructor === c) {\n      return true;\n    }\n\n    if (o === Object) {\n      return false;\n    }\n\n    o = o.constructor.superclass;\n  }\n\n  return false;\n};\n\nUtilities.getElementById = function (n, id) {\n  // Note that this does not check the DTD to check for actual\n  // attributes of type ID, so this may be a bit wrong.\n  if (n.nodeType == 1\n  /*Node.ELEMENT_NODE*/\n  ) {\n      if (n.getAttribute(\"id\") == id || n.getAttributeNS(null, \"id\") == id) {\n        return n;\n      }\n    }\n\n  for (var m = n.firstChild; m != null; m = m.nextSibling) {\n    var res = Utilities.getElementById(m, id);\n\n    if (res != null) {\n      return res;\n    }\n  }\n\n  return null;\n}; // XPathException ////////////////////////////////////////////////////////////\n\n\nXPathException.prototype = {};\nXPathException.prototype.constructor = XPathException;\nXPathException.superclass = Object.prototype;\n\nfunction XPathException(c, e) {\n  this.code = c;\n  this.exception = e;\n}\n\nXPathException.prototype.toString = function () {\n  var msg = this.exception ? \": \" + this.exception.toString() : \"\";\n\n  switch (this.code) {\n    case XPathException.INVALID_EXPRESSION_ERR:\n      return \"Invalid expression\" + msg;\n\n    case XPathException.TYPE_ERR:\n      return \"Type error\" + msg;\n  }\n};\n\nXPathException.INVALID_EXPRESSION_ERR = 51;\nXPathException.TYPE_ERR = 52; // XPathExpression ///////////////////////////////////////////////////////////\n\nXPathExpression.prototype = {};\nXPathExpression.prototype.constructor = XPathExpression;\nXPathExpression.superclass = Object.prototype;\n\nfunction XPathExpression(e, r, p) {\n  this.xpath = p.parse(e);\n  this.context = new XPathContext();\n  this.context.namespaceResolver = new XPathNSResolverWrapper(r);\n}\n\nXPathExpression.prototype.evaluate = function (n, t, res) {\n  this.context.expressionContextNode = n;\n  var result = this.xpath.evaluate(this.context);\n  return new XPathResult(result, t);\n}; // XPathNSResolverWrapper ////////////////////////////////////////////////////\n\n\nXPathNSResolverWrapper.prototype = {};\nXPathNSResolverWrapper.prototype.constructor = XPathNSResolverWrapper;\nXPathNSResolverWrapper.superclass = Object.prototype;\n\nfunction XPathNSResolverWrapper(r) {\n  this.xpathNSResolver = r;\n}\n\nXPathNSResolverWrapper.prototype.getNamespace = function (prefix, n) {\n  if (this.xpathNSResolver == null) {\n    return null;\n  }\n\n  return this.xpathNSResolver.lookupNamespaceURI(prefix);\n}; // NodeXPathNSResolver ///////////////////////////////////////////////////////\n\n\nNodeXPathNSResolver.prototype = {};\nNodeXPathNSResolver.prototype.constructor = NodeXPathNSResolver;\nNodeXPathNSResolver.superclass = Object.prototype;\n\nfunction NodeXPathNSResolver(n) {\n  this.node = n;\n  this.namespaceResolver = new NamespaceResolver();\n}\n\nNodeXPathNSResolver.prototype.lookupNamespaceURI = function (prefix) {\n  return this.namespaceResolver.getNamespace(prefix, this.node);\n}; // XPathResult ///////////////////////////////////////////////////////////////\n\n\nXPathResult.prototype = {};\nXPathResult.prototype.constructor = XPathResult;\nXPathResult.superclass = Object.prototype;\n\nfunction XPathResult(v, t) {\n  if (t == XPathResult.ANY_TYPE) {\n    if (v.constructor === XString) {\n      t = XPathResult.STRING_TYPE;\n    } else if (v.constructor === XNumber) {\n      t = XPathResult.NUMBER_TYPE;\n    } else if (v.constructor === XBoolean) {\n      t = XPathResult.BOOLEAN_TYPE;\n    } else if (v.constructor === XNodeSet) {\n      t = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;\n    }\n  }\n\n  this.resultType = t;\n\n  switch (t) {\n    case XPathResult.NUMBER_TYPE:\n      this.numberValue = v.numberValue();\n      return;\n\n    case XPathResult.STRING_TYPE:\n      this.stringValue = v.stringValue();\n      return;\n\n    case XPathResult.BOOLEAN_TYPE:\n      this.booleanValue = v.booleanValue();\n      return;\n\n    case XPathResult.ANY_UNORDERED_NODE_TYPE:\n    case XPathResult.FIRST_ORDERED_NODE_TYPE:\n      if (v.constructor === XNodeSet) {\n        this.singleNodeValue = v.first();\n        return;\n      }\n\n      break;\n\n    case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:\n    case XPathResult.ORDERED_NODE_ITERATOR_TYPE:\n      if (v.constructor === XNodeSet) {\n        this.invalidIteratorState = false;\n        this.nodes = v.toArray();\n        this.iteratorIndex = 0;\n        return;\n      }\n\n      break;\n\n    case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:\n    case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:\n      if (v.constructor === XNodeSet) {\n        this.nodes = v.toArray();\n        this.snapshotLength = this.nodes.length;\n        return;\n      }\n\n      break;\n  }\n\n  throw new XPathException(XPathException.TYPE_ERR);\n}\n\n;\n\nXPathResult.prototype.iterateNext = function () {\n  if (this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE && this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE) {\n    throw new XPathException(XPathException.TYPE_ERR);\n  }\n\n  return this.nodes[this.iteratorIndex++];\n};\n\nXPathResult.prototype.snapshotItem = function (i) {\n  if (this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE && this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) {\n    throw new XPathException(XPathException.TYPE_ERR);\n  }\n\n  return this.nodes[i];\n};\n\nXPathResult.ANY_TYPE = 0;\nXPathResult.NUMBER_TYPE = 1;\nXPathResult.STRING_TYPE = 2;\nXPathResult.BOOLEAN_TYPE = 3;\nXPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;\nXPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;\nXPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;\nXPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;\nXPathResult.ANY_UNORDERED_NODE_TYPE = 8;\nXPathResult.FIRST_ORDERED_NODE_TYPE = 9; // DOM 3 XPath support ///////////////////////////////////////////////////////\n\nfunction installDOM3XPathSupport(doc, p) {\n  doc.createExpression = function (e, r) {\n    try {\n      return new XPathExpression(e, r, p);\n    } catch (e) {\n      throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, e);\n    }\n  };\n\n  doc.createNSResolver = function (n) {\n    return new NodeXPathNSResolver(n);\n  };\n\n  doc.evaluate = function (e, cn, r, t, res) {\n    if (t < 0 || t > 9) {\n      throw {\n        code: 0,\n        toString: function toString() {\n          return \"Request type not supported\";\n        }\n      };\n    }\n\n    return doc.createExpression(e, r, p).evaluate(cn, t, res);\n  };\n}\n\n; // ---------------------------------------------------------------------------\n// Install DOM 3 XPath support for the current document.\n\ntry {\n  var shouldInstall = true;\n\n  try {\n    if (document.implementation && document.implementation.hasFeature && document.implementation.hasFeature(\"XPath\", null)) {\n      shouldInstall = false;\n    }\n  } catch (e) {}\n\n  if (shouldInstall) {\n    installDOM3XPathSupport(document, new XPathParser());\n  }\n} catch (e) {}\n\nfunction SelectNodes(doc, xpath) {\n  var parser = new XPathParser();\n  var xpath = parser.parse(xpath);\n  var context = new XPathContext();\n\n  if (doc.documentElement) {\n    context.expressionContextNode = doc.documentElement;\n  } else {\n    context.expressionContextNode = doc;\n  }\n\n  var res = xpath.evaluate(context);\n  return res.toArray();\n}\n\nmodule.exports = SelectNodes;","map":null,"metadata":{},"sourceType":"script"}