{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _get = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar tds = require('tedious');\n\nvar debug = require('debug')('mssql:tedi');\n\nvar BaseRequest = require('../base/request');\n\nvar RequestError = require('../error/request-error');\n\nvar _require = require('../utils'),\n    IDS = _require.IDS,\n    objectHasProperty = _require.objectHasProperty;\n\nvar _require2 = require('../datatypes'),\n    TYPES = _require2.TYPES,\n    DECLARATIONS = _require2.DECLARATIONS,\n    declare = _require2.declare,\n    cast = _require2.cast;\n\nvar Table = require('../table');\n\nvar _require3 = require('../udt'),\n    UDT = _require3.PARSERS;\n\nvar JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B';\nvar XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B';\nvar N_TYPES = {\n  BitN: 0x68,\n  DateTimeN: 0x6F,\n  DecimalN: 0x6A,\n  FloatN: 0x6D,\n  IntN: 0x26,\n  MoneyN: 0x6E,\n  NumericN: 0x6C\n};\n\nvar getTediousType = function getTediousType(type) {\n  switch (type) {\n    case TYPES.VarChar:\n      return tds.TYPES.VarChar;\n\n    case TYPES.NVarChar:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Text:\n      return tds.TYPES.Text;\n\n    case TYPES.Int:\n      return tds.TYPES.Int;\n\n    case TYPES.BigInt:\n      return tds.TYPES.BigInt;\n\n    case TYPES.TinyInt:\n      return tds.TYPES.TinyInt;\n\n    case TYPES.SmallInt:\n      return tds.TYPES.SmallInt;\n\n    case TYPES.Bit:\n      return tds.TYPES.Bit;\n\n    case TYPES.Float:\n      return tds.TYPES.Float;\n\n    case TYPES.Decimal:\n      return tds.TYPES.Decimal;\n\n    case TYPES.Numeric:\n      return tds.TYPES.Numeric;\n\n    case TYPES.Real:\n      return tds.TYPES.Real;\n\n    case TYPES.Money:\n      return tds.TYPES.Money;\n\n    case TYPES.SmallMoney:\n      return tds.TYPES.SmallMoney;\n\n    case TYPES.Time:\n      return tds.TYPES.Time;\n\n    case TYPES.Date:\n      return tds.TYPES.Date;\n\n    case TYPES.DateTime:\n      return tds.TYPES.DateTime;\n\n    case TYPES.DateTime2:\n      return tds.TYPES.DateTime2;\n\n    case TYPES.DateTimeOffset:\n      return tds.TYPES.DateTimeOffset;\n\n    case TYPES.SmallDateTime:\n      return tds.TYPES.SmallDateTime;\n\n    case TYPES.UniqueIdentifier:\n      return tds.TYPES.UniqueIdentifier;\n\n    case TYPES.Xml:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Char:\n      return tds.TYPES.Char;\n\n    case TYPES.NChar:\n      return tds.TYPES.NChar;\n\n    case TYPES.NText:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Image:\n      return tds.TYPES.Image;\n\n    case TYPES.Binary:\n      return tds.TYPES.Binary;\n\n    case TYPES.VarBinary:\n      return tds.TYPES.VarBinary;\n\n    case TYPES.UDT:\n    case TYPES.Geography:\n    case TYPES.Geometry:\n      return tds.TYPES.UDT;\n\n    case TYPES.TVP:\n      return tds.TYPES.TVP;\n\n    case TYPES.Variant:\n      return tds.TYPES.Variant;\n\n    default:\n      return type;\n  }\n};\n\nvar getMssqlType = function getMssqlType(type, length) {\n  if (typeof type !== 'object') return undefined;\n\n  switch (type) {\n    case tds.TYPES.Char:\n      return TYPES.Char;\n\n    case tds.TYPES.NChar:\n      return TYPES.NChar;\n\n    case tds.TYPES.VarChar:\n      return TYPES.VarChar;\n\n    case tds.TYPES.NVarChar:\n      return TYPES.NVarChar;\n\n    case tds.TYPES.Text:\n      return TYPES.Text;\n\n    case tds.TYPES.NText:\n      return TYPES.NText;\n\n    case tds.TYPES.Int:\n      return TYPES.Int;\n\n    case tds.TYPES.BigInt:\n      return TYPES.BigInt;\n\n    case tds.TYPES.TinyInt:\n      return TYPES.TinyInt;\n\n    case tds.TYPES.SmallInt:\n      return TYPES.SmallInt;\n\n    case tds.TYPES.Bit:\n      return TYPES.Bit;\n\n    case tds.TYPES.Float:\n      return TYPES.Float;\n\n    case tds.TYPES.Real:\n      return TYPES.Real;\n\n    case tds.TYPES.Money:\n      return TYPES.Money;\n\n    case tds.TYPES.SmallMoney:\n      return TYPES.SmallMoney;\n\n    case tds.TYPES.Numeric:\n      return TYPES.Numeric;\n\n    case tds.TYPES.Decimal:\n      return TYPES.Decimal;\n\n    case tds.TYPES.DateTime:\n      return TYPES.DateTime;\n\n    case tds.TYPES.Time:\n      return TYPES.Time;\n\n    case tds.TYPES.Date:\n      return TYPES.Date;\n\n    case tds.TYPES.DateTime2:\n      return TYPES.DateTime2;\n\n    case tds.TYPES.DateTimeOffset:\n      return TYPES.DateTimeOffset;\n\n    case tds.TYPES.SmallDateTime:\n      return TYPES.SmallDateTime;\n\n    case tds.TYPES.UniqueIdentifier:\n      return TYPES.UniqueIdentifier;\n\n    case tds.TYPES.Image:\n      return TYPES.Image;\n\n    case tds.TYPES.Binary:\n      return TYPES.Binary;\n\n    case tds.TYPES.VarBinary:\n      return TYPES.VarBinary;\n\n    case tds.TYPES.Xml:\n      return TYPES.Xml;\n\n    case tds.TYPES.UDT:\n      return TYPES.UDT;\n\n    case tds.TYPES.TVP:\n      return TYPES.TVP;\n\n    case tds.TYPES.Variant:\n      return TYPES.Variant;\n\n    default:\n      switch (type.id) {\n        case N_TYPES.BitN:\n          return TYPES.Bit;\n\n        case N_TYPES.NumericN:\n          return TYPES.Numeric;\n\n        case N_TYPES.DecimalN:\n          return TYPES.Decimal;\n\n        case N_TYPES.IntN:\n          if (length === 8) return TYPES.BigInt;\n          if (length === 4) return TYPES.Int;\n          if (length === 2) return TYPES.SmallInt;\n          return TYPES.TinyInt;\n\n        case N_TYPES.FloatN:\n          if (length === 8) return TYPES.Float;\n          return TYPES.Real;\n\n        case N_TYPES.MoneyN:\n          if (length === 8) return TYPES.Money;\n          return TYPES.SmallMoney;\n\n        case N_TYPES.DateTimeN:\n          if (length === 8) return TYPES.DateTime;\n          return TYPES.SmallDateTime;\n      }\n\n  }\n};\n\nvar createColumns = function createColumns(metadata, arrayRowMode) {\n  var out = {};\n  if (arrayRowMode) out = [];\n\n  for (var index = 0, length = metadata.length; index < length; index++) {\n    var column = metadata[index];\n    var outColumn = {\n      index: index,\n      name: column.colName,\n      length: column.dataLength,\n      type: getMssqlType(column.type, column.dataLength),\n      scale: column.scale,\n      precision: column.precision,\n      nullable: !!(column.flags & 0x01),\n      caseSensitive: !!(column.flags & 0x02),\n      identity: !!(column.flags & 0x10),\n      readOnly: !(column.flags & 0x0C)\n    };\n\n    if (column.udtInfo) {\n      outColumn.udt = {\n        name: column.udtInfo.typeName,\n        database: column.udtInfo.dbname,\n        schema: column.udtInfo.owningSchema,\n        assembly: column.udtInfo.assemblyName\n      };\n\n      if (DECLARATIONS[column.udtInfo.typeName]) {\n        outColumn.type = DECLARATIONS[column.udtInfo.typeName];\n      }\n    }\n\n    if (arrayRowMode) {\n      out.push(outColumn);\n    } else {\n      out[column.colName] = outColumn;\n    }\n  }\n\n  return out;\n};\n\nvar valueCorrection = function valueCorrection(value, metadata) {\n  if (metadata.type === tds.TYPES.UDT && value != null) {\n    if (UDT[metadata.udtInfo.typeName]) {\n      return UDT[metadata.udtInfo.typeName](value);\n    } else {\n      return value;\n    }\n  } else {\n    return value;\n  }\n};\n\nvar parameterCorrection = function parameterCorrection(value) {\n  if (value instanceof Table) {\n    var tvp = {\n      name: value.name,\n      schema: value.schema,\n      columns: [],\n      rows: value.rows\n    };\n\n    var _iterator = _createForOfIteratorHelper(value.columns),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var col = _step.value;\n        tvp.columns.push({\n          name: col.name,\n          type: getTediousType(col.type),\n          length: col.length,\n          scale: col.scale,\n          precision: col.precision\n        });\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return tvp;\n  } else {\n    return value;\n  }\n};\n\nvar Request = /*#__PURE__*/function (_BaseRequest) {\n  _inherits(Request, _BaseRequest);\n\n  function Request() {\n    _classCallCheck(this, Request);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Request).apply(this, arguments));\n  }\n\n  _createClass(Request, [{\n    key: \"_batch\",\n\n    /*\n    Execute specified sql batch.\n    */\n    value: function _batch(batch, callback) {\n      this._isBatch = true;\n\n      this._query(batch, callback);\n    }\n    /*\n    Bulk load.\n    */\n\n  }, {\n    key: \"_bulk\",\n    value: function _bulk(table, options, callback) {\n      var _this = this;\n\n      _get(_getPrototypeOf(Request.prototype), \"_bulk\", this).call(this, table, options, function (err) {\n        if (err) return callback(err);\n\n        table._makeBulk();\n\n        if (!table.name) {\n          return callback(new RequestError('Table name must be specified for bulk insert.', 'ENAME'));\n        }\n\n        if (table.name.charAt(0) === '@') {\n          return callback(new RequestError(\"You can't use table variables for bulk insert.\", 'ENAME'));\n        }\n\n        var errors = [];\n        var errorHandlers = {};\n        var hasReturned = false;\n\n        var handleError = function handleError(doReturn, connection, info) {\n          var err = new Error(info.message);\n          err.info = info;\n          err = new RequestError(err, 'EREQUEST');\n\n          if (_this.stream) {\n            _this.emit('error', err);\n          } else {\n            if (doReturn && !hasReturned) {\n              if (connection) {\n                for (var event in errorHandlers) {\n                  connection.removeListener(event, errorHandlers[event]);\n                }\n\n                _this.parent.release(connection);\n              }\n\n              hasReturned = true;\n              callback(err);\n            }\n          } // we must collect errors even in stream mode\n\n\n          errors.push(err);\n        };\n\n        var handleInfo = function handleInfo(msg) {\n          _this.emit('info', {\n            message: msg.message,\n            number: msg.number,\n            state: msg.state,\n            class: msg.class,\n            lineNumber: msg.lineNumber,\n            serverName: msg.serverName,\n            procName: msg.procName\n          });\n        };\n\n        _this.parent.acquire(_this, function (err, connection) {\n          if (err) return callback(err);\n          debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(_this));\n\n          if (_this.canceled) {\n            debug('request(%d): canceled', IDS.get(_this));\n\n            _this.parent.release(connection);\n\n            return callback(new RequestError('Canceled.', 'ECANCEL'));\n          }\n\n          _this._cancel = function () {\n            debug('request(%d): cancel', IDS.get(_this));\n            connection.cancel();\n          }; // attach handler to handle multiple error messages\n\n\n          connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n          connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n          connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n\n          var done = function done(err, rowCount) {\n            // to make sure we handle no-sql errors as well\n            if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n              err = new RequestError(err, 'EREQUEST');\n              if (_this.stream) _this.emit('error', err);\n              errors.push(err);\n            }\n\n            delete _this._cancel;\n            var error;\n\n            if (errors.length && !_this.stream) {\n              error = errors.pop();\n              error.precedingErrors = errors;\n            }\n\n            if (!hasReturned) {\n              for (var event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              _this.parent.release(connection);\n\n              hasReturned = true;\n\n              if (_this.stream) {\n                callback(null, rowCount);\n              } else {\n                callback(error, rowCount);\n              }\n            }\n          };\n\n          var bulk = connection.newBulkLoad(table.path, options, done);\n\n          var _iterator2 = _createForOfIteratorHelper(table.columns),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var col = _step2.value;\n              bulk.addColumn(col.name, getTediousType(col.type), {\n                nullable: col.nullable,\n                length: col.length,\n                scale: col.scale,\n                precision: col.precision\n              });\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          var _iterator3 = _createForOfIteratorHelper(table.rows),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var row = _step3.value;\n              bulk.addRow(row);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n\n          if (table.create) {\n            var objectid = table.temporary ? \"tempdb..[\".concat(table.name, \"]\") : table.path;\n            var req = new tds.Request(\"if object_id('\".concat(objectid.replace(/'/g, '\\'\\''), \"') is null \").concat(table.declare()), function (err) {\n              if (err) return done(err);\n              connection.execBulkLoad(bulk);\n            });\n\n            _this._setCurrentRequest(req);\n\n            connection.execSqlBatch(req);\n          } else {\n            connection.execBulkLoad(bulk);\n          }\n        });\n      });\n    }\n    /*\n    Execute specified sql command.\n    */\n\n  }, {\n    key: \"_query\",\n    value: function _query(command, callback) {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(Request.prototype), \"_query\", this).call(this, command, function (err) {\n        if (err) return callback(err);\n        var recordsets = [];\n        var recordsetcolumns = [];\n        var errors = [];\n        var errorHandlers = {};\n        var output = {};\n        var rowsAffected = [];\n        var columns = {};\n        var recordset = [];\n        var batchLastRow = null;\n        var batchHasOutput = false;\n        var isChunkedRecordset = false;\n        var chunksBuffer = null;\n        var hasReturned = false;\n\n        var handleError = function handleError(doReturn, connection, info) {\n          var err = new Error(info.message);\n          err.info = info;\n          err = new RequestError(err, 'EREQUEST');\n\n          if (_this2.stream) {\n            _this2.emit('error', err);\n          } else {\n            if (doReturn && !hasReturned) {\n              if (connection) {\n                for (var event in errorHandlers) {\n                  connection.removeListener(event, errorHandlers[event]);\n                }\n\n                _this2.parent.release(connection);\n              }\n\n              hasReturned = true;\n              callback(err);\n            }\n          } // we must collect errors even in stream mode\n\n\n          errors.push(err);\n        };\n\n        var handleInfo = function handleInfo(msg) {\n          _this2.emit('info', {\n            message: msg.message,\n            number: msg.number,\n            state: msg.state,\n            class: msg.class,\n            lineNumber: msg.lineNumber,\n            serverName: msg.serverName,\n            procName: msg.procName\n          });\n        };\n\n        _this2.parent.acquire(_this2, function (err, connection, config) {\n          if (err) return callback(err);\n          debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(_this2));\n          var row;\n\n          if (_this2.canceled) {\n            debug('request(%d): canceled', IDS.get(_this2));\n\n            _this2.parent.release(connection);\n\n            return callback(new RequestError('Canceled.', 'ECANCEL'));\n          }\n\n          _this2._cancel = function () {\n            debug('request(%d): cancel', IDS.get(_this2));\n            connection.cancel();\n          }; // attach handler to handle multiple error messages\n\n\n          connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n          connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n          connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n          debug('request(%d): query', IDS.get(_this2), command);\n          var req = new tds.Request(command, function (err) {\n            // to make sure we handle no-sql errors as well\n            if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n              err = new RequestError(err, 'EREQUEST');\n              if (_this2.stream) _this2.emit('error', err);\n              errors.push(err);\n            } // process batch outputs\n\n\n            if (batchHasOutput) {\n              if (!_this2.stream) batchLastRow = recordsets.pop()[0];\n\n              for (var name in batchLastRow) {\n                var value = batchLastRow[name];\n\n                if (name !== '___return___') {\n                  output[name] = value;\n                }\n              }\n            }\n\n            delete _this2._cancel;\n            var error;\n\n            if (errors.length && !_this2.stream) {\n              error = errors.pop();\n              error.precedingErrors = errors;\n            }\n\n            if (!hasReturned) {\n              for (var event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              _this2.parent.release(connection);\n\n              hasReturned = true;\n\n              if (error) {\n                debug('request(%d): failed', IDS.get(_this2), error);\n              } else {\n                debug('request(%d): completed', IDS.get(_this2));\n              }\n\n              if (_this2.stream) {\n                callback(null, null, output, rowsAffected, recordsetcolumns);\n              } else {\n                callback(error, recordsets, output, rowsAffected, recordsetcolumns);\n              }\n            }\n          });\n\n          _this2._setCurrentRequest(req);\n\n          req.on('columnMetadata', function (metadata) {\n            columns = createColumns(metadata, _this2.arrayRowMode);\n            isChunkedRecordset = false;\n\n            if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n              isChunkedRecordset = true;\n              chunksBuffer = [];\n            }\n\n            if (_this2.stream) {\n              if (_this2._isBatch) {\n                // don't stream recordset with output values in batches\n                if (!columns.___return___) {\n                  _this2.emit('recordset', columns);\n                }\n              } else {\n                _this2.emit('recordset', columns);\n              }\n            }\n\n            if (_this2.arrayRowMode) recordsetcolumns.push(columns);\n          });\n\n          var doneHandler = function doneHandler(rowCount, more) {\n            if (rowCount != null) rowsAffected.push(rowCount); // this function is called even when select only set variables so we should skip adding a new recordset\n\n            if (Object.keys(columns).length === 0) return;\n\n            if (isChunkedRecordset) {\n              var concatenatedChunks = chunksBuffer.join('');\n\n              if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n                try {\n                  if (concatenatedChunks === '') {\n                    row = null;\n                  } else {\n                    row = JSON.parse(concatenatedChunks);\n                  }\n                } catch (ex) {\n                  row = null;\n                  var ex2 = new RequestError(new Error(\"Failed to parse incoming JSON. \".concat(ex.message)), 'EJSON');\n                  if (_this2.stream) _this2.emit('error', ex2); // we must collect errors even in stream mode\n\n                  errors.push(ex2);\n                }\n              } else {\n                row = {};\n                row[Object.keys(columns)[0]] = concatenatedChunks;\n              }\n\n              chunksBuffer = null;\n\n              if (_this2.stream) {\n                _this2.emit('row', row);\n              } else {\n                recordset.push(row);\n              }\n            }\n\n            if (!_this2.stream) {\n              // all rows of current recordset loaded\n              Object.defineProperty(recordset, 'columns', {\n                enumerable: false,\n                configurable: true,\n                value: columns\n              });\n              Object.defineProperty(recordset, 'toTable', {\n                enumerable: false,\n                configurable: true,\n                value: function value(name) {\n                  return Table.fromRecordset(this, name);\n                }\n              });\n              recordsets.push(recordset);\n            }\n\n            recordset = [];\n            columns = {};\n          };\n\n          req.on('doneInProc', doneHandler); // doneInProc handlers are used in both queries and batches\n\n          req.on('done', doneHandler); // done handlers are used in batches\n\n          req.on('returnValue', function (parameterName, value, metadata) {\n            output[parameterName] = value;\n          });\n          req.on('row', function (columns) {\n            if (!recordset) recordset = [];\n\n            if (isChunkedRecordset) {\n              return chunksBuffer.push(columns[0].value);\n            }\n\n            if (_this2.arrayRowMode) {\n              row = [];\n            } else {\n              row = {};\n            }\n\n            var _iterator4 = _createForOfIteratorHelper(columns),\n                _step4;\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var col = _step4.value;\n                col.value = valueCorrection(col.value, col.metadata);\n\n                if (_this2.arrayRowMode) {\n                  row.push(col.value);\n                } else {\n                  var exi = row[col.metadata.colName];\n\n                  if (exi != null) {\n                    if (exi instanceof Array) {\n                      exi.push(col.value);\n                    } else {\n                      row[col.metadata.colName] = [exi, col.value];\n                    }\n                  } else {\n                    row[col.metadata.colName] = col.value;\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n\n            if (_this2.stream) {\n              if (_this2._isBatch) {\n                // dont stream recordset with output values in batches\n                if (row.___return___) {\n                  batchLastRow = row;\n                } else {\n                  _this2.emit('row', row);\n                }\n              } else {\n                _this2.emit('row', row);\n              }\n            } else {\n              recordset.push(row);\n            }\n          });\n\n          if (_this2._isBatch) {\n            if (Object.keys(_this2.parameters).length) {\n              for (var name in _this2.parameters) {\n                if (!objectHasProperty(_this2.parameters, name)) {\n                  continue;\n                }\n\n                var param = _this2.parameters[name];\n                var value = getTediousType(param.type).validate(param.value);\n\n                if (value instanceof TypeError) {\n                  value = new RequestError(\"Validation failed for parameter '\".concat(name, \"'. \").concat(value.message), 'EPARAM');\n\n                  _this2.parent.release(connection);\n\n                  return callback(value);\n                }\n\n                param.value = value;\n              }\n\n              var declarations = [];\n\n              for (var _name in _this2.parameters) {\n                if (!objectHasProperty(_this2.parameters, _name)) {\n                  continue;\n                }\n\n                var _param = _this2.parameters[_name];\n                declarations.push(\"@\".concat(_name, \" \").concat(declare(_param.type, _param)));\n              }\n\n              var assigns = [];\n\n              for (var _name2 in _this2.parameters) {\n                if (!objectHasProperty(_this2.parameters, _name2)) {\n                  continue;\n                }\n\n                var _param2 = _this2.parameters[_name2];\n                assigns.push(\"@\".concat(_name2, \" = \").concat(cast(_param2.value, _param2.type, _param2)));\n              }\n\n              var selects = [];\n\n              for (var _name3 in _this2.parameters) {\n                if (!objectHasProperty(_this2.parameters, _name3)) {\n                  continue;\n                }\n\n                var _param3 = _this2.parameters[_name3];\n\n                if (_param3.io === 2) {\n                  selects.push(\"@\".concat(_name3, \" as [\").concat(_name3, \"]\"));\n                }\n              }\n\n              batchHasOutput = selects.length > 0;\n              req.sqlTextOrProcedure = \"declare \".concat(declarations.join(', '), \";select \").concat(assigns.join(', '), \";\").concat(req.sqlTextOrProcedure, \";\").concat(batchHasOutput ? \"select 1 as [___return___], \".concat(selects.join(', ')) : '');\n            }\n          } else {\n            for (var _name4 in _this2.parameters) {\n              if (!objectHasProperty(_this2.parameters, _name4)) {\n                continue;\n              }\n\n              var _param4 = _this2.parameters[_name4];\n\n              if (_param4.io === 1) {\n                req.addParameter(_param4.name, getTediousType(_param4.type), parameterCorrection(_param4.value), {\n                  length: _param4.length,\n                  scale: _param4.scale,\n                  precision: _param4.precision\n                });\n              } else {\n                req.addOutputParameter(_param4.name, getTediousType(_param4.type), parameterCorrection(_param4.value), {\n                  length: _param4.length,\n                  scale: _param4.scale,\n                  precision: _param4.precision\n                });\n              }\n            }\n          }\n\n          try {\n            connection[_this2._isBatch ? 'execSqlBatch' : 'execSql'](req);\n          } catch (error) {\n            handleError(true, connection, error);\n          }\n        });\n      });\n    }\n    /*\n    Execute stored procedure with specified parameters.\n    */\n\n  }, {\n    key: \"_execute\",\n    value: function _execute(procedure, callback) {\n      var _this3 = this;\n\n      _get(_getPrototypeOf(Request.prototype), \"_execute\", this).call(this, procedure, function (err) {\n        if (err) return callback(err);\n        var recordsets = [];\n        var recordsetcolumns = [];\n        var errors = [];\n        var errorHandlers = {};\n        var output = {};\n        var rowsAffected = [];\n        var columns = {};\n        var recordset = [];\n        var returnValue = 0;\n        var isChunkedRecordset = false;\n        var chunksBuffer = null;\n        var hasReturned = false;\n\n        var handleError = function handleError(doReturn, connection, info) {\n          var err = new Error(info.message);\n          err.info = info;\n          err = new RequestError(err, 'EREQUEST');\n\n          if (_this3.stream) {\n            _this3.emit('error', err);\n          } else {\n            if (doReturn && !hasReturned) {\n              if (connection) {\n                for (var event in errorHandlers) {\n                  connection.removeListener(event, errorHandlers[event]);\n                }\n\n                _this3.parent.release(connection);\n              }\n\n              hasReturned = true;\n              callback(err);\n            }\n          } // we must collect errors even in stream mode\n\n\n          errors.push(err);\n        };\n\n        var handleInfo = function handleInfo(msg) {\n          _this3.emit('info', {\n            message: msg.message,\n            number: msg.number,\n            state: msg.state,\n            class: msg.class,\n            lineNumber: msg.lineNumber,\n            serverName: msg.serverName,\n            procName: msg.procName\n          });\n        };\n\n        _this3.parent.acquire(_this3, function (err, connection, config) {\n          if (err) return callback(err);\n          debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(_this3));\n          var row;\n\n          if (_this3.canceled) {\n            debug('request(%d): canceled', IDS.get(_this3));\n\n            _this3.parent.release(connection);\n\n            return callback(new RequestError('Canceled.', 'ECANCEL'));\n          }\n\n          _this3._cancel = function () {\n            debug('request(%d): cancel', IDS.get(_this3));\n            connection.cancel();\n          }; // attach handler to handle multiple error messages\n\n\n          connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n          connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n          connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n\n          if (debug.enabled) {\n            // log stored procedure executions and provided parameters\n            var params = Object.keys(_this3.parameters).map(function (k) {\n              return _this3.parameters[k];\n            }); // cut long string parameters short to keep log somewhat clean\n\n            var logValue = function logValue(s) {\n              return typeof s === 'string' && s.length > 50 ? s.substring(0, 47) + '...' : s;\n            }; // format parameter names as 'my_parameter [sql.Int]'\n\n\n            var logName = function logName(param) {\n              return param.name + ' [sql.' + param.type.name + ']';\n            };\n\n            var logParams = {};\n            params.forEach(function (p) {\n              logParams[logName(p)] = logValue(p.value);\n            });\n            debug('request(%d): execute %s %O', IDS.get(_this3), procedure, logParams);\n          }\n\n          var req = new tds.Request(procedure, function (err) {\n            // to make sure we handle no-sql errors as well\n            if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n              err = new RequestError(err, 'EREQUEST');\n              if (_this3.stream) _this3.emit('error', err);\n              errors.push(err);\n            }\n\n            delete _this3._cancel;\n            var error;\n\n            if (errors.length && !_this3.stream) {\n              error = errors.pop();\n              error.precedingErrors = errors;\n            }\n\n            if (!hasReturned) {\n              for (var event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              _this3.parent.release(connection);\n\n              hasReturned = true;\n\n              if (error) {\n                debug('request(%d): failed', IDS.get(_this3), error);\n              } else {\n                debug('request(%d): complete', IDS.get(_this3));\n              }\n\n              if (_this3.stream) {\n                callback(null, null, output, returnValue, rowsAffected, recordsetcolumns);\n              } else {\n                callback(error, recordsets, output, returnValue, rowsAffected, recordsetcolumns);\n              }\n            }\n          });\n\n          _this3._setCurrentRequest(req);\n\n          req.on('columnMetadata', function (metadata) {\n            columns = createColumns(metadata, _this3.arrayRowMode);\n            isChunkedRecordset = false;\n\n            if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n              isChunkedRecordset = true;\n              chunksBuffer = [];\n            }\n\n            if (_this3.stream) _this3.emit('recordset', columns);\n            if (_this3.arrayRowMode) recordsetcolumns.push(columns);\n          });\n          req.on('row', function (columns) {\n            if (!recordset) recordset = [];\n\n            if (isChunkedRecordset) {\n              return chunksBuffer.push(columns[0].value);\n            }\n\n            if (_this3.arrayRowMode) {\n              row = [];\n            } else {\n              row = {};\n            }\n\n            var _iterator5 = _createForOfIteratorHelper(columns),\n                _step5;\n\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var col = _step5.value;\n                col.value = valueCorrection(col.value, col.metadata);\n\n                if (_this3.arrayRowMode) {\n                  row.push(col.value);\n                } else {\n                  var exi = row[col.metadata.colName];\n\n                  if (exi != null) {\n                    if (exi instanceof Array) {\n                      exi.push(col.value);\n                    } else {\n                      row[col.metadata.colName] = [exi, col.value];\n                    }\n                  } else {\n                    row[col.metadata.colName] = col.value;\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n\n            if (_this3.stream) {\n              _this3.emit('row', row);\n            } else {\n              recordset.push(row);\n            }\n          });\n          req.on('doneInProc', function (rowCount, more) {\n            if (rowCount != null) rowsAffected.push(rowCount); // filter empty recordsets when NOCOUNT is OFF\n\n            if (Object.keys(columns).length === 0) return;\n\n            if (isChunkedRecordset) {\n              if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n                try {\n                  if (chunksBuffer.length === 0) {\n                    row = null;\n                  } else {\n                    row = JSON.parse(chunksBuffer.join(''));\n                  }\n                } catch (ex) {\n                  row = null;\n                  var ex2 = new RequestError(new Error(\"Failed to parse incoming JSON. \".concat(ex.message)), 'EJSON');\n                  if (_this3.stream) _this3.emit('error', ex2); // we must collect errors even in stream mode\n\n                  errors.push(ex2);\n                }\n              } else {\n                row = {};\n                row[Object.keys(columns)[0]] = chunksBuffer.join('');\n              }\n\n              chunksBuffer = null;\n\n              if (_this3.stream) {\n                _this3.emit('row', row);\n              } else {\n                recordset.push(row);\n              }\n            }\n\n            if (!_this3.stream) {\n              // all rows of current recordset loaded\n              Object.defineProperty(recordset, 'columns', {\n                enumerable: false,\n                configurable: true,\n                value: columns\n              });\n              Object.defineProperty(recordset, 'toTable', {\n                enumerable: false,\n                configurable: true,\n                value: function value(name) {\n                  return Table.fromRecordset(this, name);\n                }\n              });\n              recordsets.push(recordset);\n            }\n\n            recordset = [];\n            columns = {};\n          });\n          req.on('doneProc', function (rowCount, more, returnStatus) {\n            returnValue = returnStatus;\n          });\n          req.on('returnValue', function (parameterName, value, metadata) {\n            output[parameterName] = value;\n          });\n\n          for (var name in _this3.parameters) {\n            if (!objectHasProperty(_this3.parameters, name)) {\n              continue;\n            }\n\n            var param = _this3.parameters[name];\n\n            if (param.io === 1) {\n              req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            } else {\n              req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            }\n          }\n\n          connection.callProcedure(req);\n        });\n      });\n    }\n  }, {\n    key: \"_pause\",\n    value: function _pause() {\n      _get(_getPrototypeOf(Request.prototype), \"_pause\", this).call(this);\n\n      if (this._currentRequest) {\n        this._currentRequest.pause();\n      }\n    }\n  }, {\n    key: \"_resume\",\n    value: function _resume() {\n      _get(_getPrototypeOf(Request.prototype), \"_resume\", this).call(this);\n\n      if (this._currentRequest) {\n        this._currentRequest.resume();\n      }\n    }\n  }]);\n\n  return Request;\n}(BaseRequest);\n\nmodule.exports = Request;","map":null,"metadata":{},"sourceType":"script"}