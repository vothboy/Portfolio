{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nimport uuidv4 from \"uuid/v4\";\nimport { Constants } from \"./constants\";\n/**\n * A constant that indicates whether the environment is node.js or browser based.\n */\n\nexport var isNode = typeof process !== \"undefined\" && !!process.version && !!process.versions && !!process.versions.node;\n/**\n * Checks if a parsed URL is HTTPS\n *\n * @param {object} urlToCheck The url to check\n * @return {boolean} True if the URL is HTTPS; false otherwise.\n */\n\nexport function urlIsHTTPS(urlToCheck) {\n  return urlToCheck.protocol.toLowerCase() === Constants.HTTPS;\n}\n/**\n * Encodes an URI.\n *\n * @param {string} uri The URI to be encoded.\n * @return {string} The encoded URI.\n */\n\nexport function encodeUri(uri) {\n  return encodeURIComponent(uri).replace(/!/g, \"%21\").replace(/\"/g, \"%27\").replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\").replace(/\\*/g, \"%2A\");\n}\n/**\n * Returns a stripped version of the Http Response which only contains body,\n * headers and the status.\n *\n * @param {HttpOperationResponse} response The Http Response\n *\n * @return {object} The stripped version of Http Response.\n */\n\nexport function stripResponse(response) {\n  var strippedResponse = {};\n  strippedResponse.body = response.bodyAsText;\n  strippedResponse.headers = response.headers;\n  strippedResponse.status = response.status;\n  return strippedResponse;\n}\n/**\n * Returns a stripped version of the Http Request that does not contain the\n * Authorization header.\n *\n * @param {WebResource} request The Http Request object\n *\n * @return {WebResource} The stripped version of Http Request.\n */\n\nexport function stripRequest(request) {\n  var strippedRequest = request.clone();\n\n  if (strippedRequest.headers) {\n    strippedRequest.headers.remove(\"authorization\");\n  }\n\n  return strippedRequest;\n}\n/**\n * Validates the given uuid as a string\n *\n * @param {string} uuid The uuid as a string that needs to be validated\n *\n * @return {boolean} True if the uuid is valid; false otherwise.\n */\n\nexport function isValidUuid(uuid) {\n  var validUuidRegex = new RegExp(\"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\", \"ig\");\n  return validUuidRegex.test(uuid);\n}\n/**\n * Provides an array of values of an object. For example\n * for a given object { \"a\": \"foo\", \"b\": \"bar\" }, the method returns [\"foo\", \"bar\"].\n *\n * @param {object} obj An object whose properties need to be enumerated so that it\"s values can be provided as an array\n *\n * @return {any[]} An array of values of the given object.\n */\n\nexport function objectValues(obj) {\n  var result = [];\n\n  if (obj && obj instanceof Object) {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        result.push(obj[key]);\n      }\n    }\n  } else {\n    throw new Error(\"The provided object \" + JSON.stringify(obj, undefined, 2) + \" is not a valid object that can be \" + \"enumerated to provide its values as an array.\");\n  }\n\n  return result;\n}\n/**\n * Generated UUID\n *\n * @return {string} RFC4122 v4 UUID.\n */\n\nexport function generateUuid() {\n  return uuidv4();\n}\n/**\n * Executes an array of promises sequentially. Inspiration of this method is here:\n * https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html. An awesome blog on promises!\n *\n * @param {Array} promiseFactories An array of promise factories(A function that return a promise)\n *\n * @param {any} [kickstart] Input to the first promise that is used to kickstart the promise chain.\n * If not provided then the promise chain starts with undefined.\n *\n * @return A chain of resolved or rejected promises\n */\n\nexport function executePromisesSequentially(promiseFactories, kickstart) {\n  var result = Promise.resolve(kickstart);\n  promiseFactories.forEach(function (promiseFactory) {\n    result = result.then(promiseFactory);\n  });\n  return result;\n}\n/**\n * Merges source object into the target object\n * @param {object} source The object that needs to be merged\n *\n * @param {object} target The object to be merged into\n *\n * @returns {object} Returns the merged target object.\n */\n\nexport function mergeObjects(source, target) {\n  Object.keys(source).forEach(function (key) {\n    target[key] = source[key];\n  });\n  return target;\n}\n/**\n * A wrapper for setTimeout that resolves a promise after t milliseconds.\n * @param {number} t The number of milliseconds to be delayed.\n * @param {T} value The value to be resolved with after a timeout of t milliseconds.\n * @returns {Promise<T>} Resolved promise\n */\n\nexport function delay(t, value) {\n  return new Promise(function (resolve) {\n    return setTimeout(function () {\n      return resolve(value);\n    }, t);\n  });\n}\n/**\n * Converts a Promise to a callback.\n * @param {Promise<any>} promise The Promise to be converted to a callback\n * @returns {Function} A function that takes the callback (cb: Function): void\n * @deprecated generated code should instead depend on responseToBody\n */\n\nexport function promiseToCallback(promise) {\n  if (typeof promise.then !== \"function\") {\n    throw new Error(\"The provided input is not a Promise.\");\n  }\n\n  return function (cb) {\n    promise.then(function (data) {\n      cb(undefined, data);\n    }, function (err) {\n      cb(err);\n    });\n  };\n}\n/**\n * Converts a Promise to a service callback.\n * @param {Promise<HttpOperationResponse>} promise - The Promise of HttpOperationResponse to be converted to a service callback\n * @returns {Function} A function that takes the service callback (cb: ServiceCallback<T>): void\n */\n\nexport function promiseToServiceCallback(promise) {\n  if (typeof promise.then !== \"function\") {\n    throw new Error(\"The provided input is not a Promise.\");\n  }\n\n  return function (cb) {\n    promise.then(function (data) {\n      process.nextTick(cb, undefined, data.parsedBody, data.request, data);\n    }, function (err) {\n      process.nextTick(cb, err);\n    });\n  };\n}\nexport function prepareXMLRootList(obj, elementName) {\n  var _a;\n\n  if (!Array.isArray(obj)) {\n    obj = [obj];\n  }\n\n  return _a = {}, _a[elementName] = obj, _a;\n}\n/**\n * Applies the properties on the prototype of sourceCtors to the prototype of targetCtor\n * @param {object} targetCtor The target object on which the properties need to be applied.\n * @param {Array<object>} sourceCtors An array of source objects from which the properties need to be taken.\n */\n\nexport function applyMixins(targetCtor, sourceCtors) {\n  sourceCtors.forEach(function (sourceCtors) {\n    Object.getOwnPropertyNames(sourceCtors.prototype).forEach(function (name) {\n      targetCtor.prototype[name] = sourceCtors.prototype[name];\n    });\n  });\n}\nvar validateISODuration = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n/**\n * Indicates whether the given string is in ISO 8601 format.\n * @param {string} value The value to be validated for ISO 8601 duration format.\n * @return {boolean} `true` if valid, `false` otherwise.\n */\n\nexport function isDuration(value) {\n  return validateISODuration.test(value);\n}\n/**\n * Replace all of the instances of searchValue in value with the provided replaceValue.\n * @param {string | undefined} value The value to search and replace in.\n * @param {string} searchValue The value to search for in the value argument.\n * @param {string} replaceValue The value to replace searchValue with in the value argument.\n * @returns {string | undefined} The value where each instance of searchValue was replaced with replacedValue.\n */\n\nexport function replaceAll(value, searchValue, replaceValue) {\n  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || \"\");\n}","map":null,"metadata":{},"sourceType":"module"}