{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar debug = require('debug')('mssql:base');\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar _require2 = require('../utils'),\n    IDS = _require2.IDS,\n    objectHasProperty = _require2.objectHasProperty;\n\nvar globalConnection = require('../global-connection');\n\nvar _require3 = require('../error'),\n    TransactionError = _require3.TransactionError,\n    PreparedStatementError = _require3.PreparedStatementError;\n\nvar shared = require('../shared');\n\nvar _require4 = require('../datatypes'),\n    TYPES = _require4.TYPES,\n    declare = _require4.declare;\n/**\n * Class PreparedStatement.\n *\n * IMPORTANT: Rememeber that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement!\n *\n * @property {String} statement Prepared SQL statement.\n */\n\n\nvar PreparedStatement = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(PreparedStatement, _EventEmitter);\n\n  /**\n   * Creates a new Prepared Statement.\n   *\n   * @param {ConnectionPool|Transaction} [holder]\n   */\n  function PreparedStatement(parent) {\n    var _this;\n\n    _classCallCheck(this, PreparedStatement);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PreparedStatement).call(this));\n    IDS.add(_assertThisInitialized(_assertThisInitialized(_this)), 'PreparedStatement');\n    debug('ps(%d): created', IDS.get(_assertThisInitialized(_assertThisInitialized(_this))));\n    _this.parent = parent || globalConnection.pool;\n    _this._handle = 0;\n    _this.prepared = false;\n    _this.parameters = {};\n    return _this;\n  }\n\n  _createClass(PreparedStatement, [{\n    key: \"acquire\",\n\n    /**\n     * Acquire connection from connection pool.\n     *\n     * @param {Request} request Request.\n     * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.\n     * @return {PreparedStatement|Promise}\n     */\n    value: function acquire(request, callback) {\n      if (!this._acquiredConnection) {\n        setImmediate(callback, new PreparedStatementError('Statement is not prepared. Call prepare() first.', 'ENOTPREPARED'));\n        return this;\n      }\n\n      if (this._activeRequest) {\n        setImmediate(callback, new TransactionError(\"Can't acquire connection for the request. There is another request in progress.\", 'EREQINPROG'));\n        return this;\n      }\n\n      this._activeRequest = request;\n      setImmediate(callback, null, this._acquiredConnection, this._acquiredConfig);\n      return this;\n    }\n    /**\n     * Release connection back to the pool.\n     *\n     * @param {Connection} connection Previously acquired connection.\n     * @return {PreparedStatement}\n     */\n\n  }, {\n    key: \"release\",\n    value: function release(connection) {\n      if (connection === this._acquiredConnection) {\n        this._activeRequest = null;\n      }\n\n      return this;\n    }\n    /**\n     * Add an input parameter to the prepared statement.\n     *\n     * @param {String} name Name of the input parameter without @ char.\n     * @param {*} type SQL data type of input parameter.\n     * @return {PreparedStatement}\n     */\n\n  }, {\n    key: \"input\",\n    value: function input(name, type) {\n      if (/(--| |\\/\\*|\\*\\/|')/.test(name)) {\n        throw new PreparedStatementError(\"SQL injection warning for param '\".concat(name, \"'\"), 'EINJECT');\n      }\n\n      if (arguments.length < 2) {\n        throw new PreparedStatementError('Invalid number of arguments. 2 arguments expected.', 'EARGS');\n      }\n\n      if (type instanceof Function) {\n        type = type();\n      }\n\n      if (objectHasProperty(this.parameters, name)) {\n        throw new PreparedStatementError(\"The parameter name \".concat(name, \" has already been declared. Parameter names must be unique\"), 'EDUPEPARAM');\n      }\n\n      this.parameters[name] = {\n        name: name,\n        type: type.type,\n        io: 1,\n        length: type.length,\n        scale: type.scale,\n        precision: type.precision,\n        tvpType: type.tvpType\n      };\n      return this;\n    }\n    /**\n     * Replace an input parameter on the request.\n     *\n     * @param {String} name Name of the input parameter without @ char.\n     * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.\n     * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n     * @return {Request}\n     */\n\n  }, {\n    key: \"replaceInput\",\n    value: function replaceInput(name, type, value) {\n      delete this.parameters[name];\n      return this.input(name, type, value);\n    }\n    /**\n     * Add an output parameter to the prepared statement.\n     *\n     * @param {String} name Name of the output parameter without @ char.\n     * @param {*} type SQL data type of output parameter.\n     * @return {PreparedStatement}\n     */\n\n  }, {\n    key: \"output\",\n    value: function output(name, type) {\n      if (/(--| |\\/\\*|\\*\\/|')/.test(name)) {\n        throw new PreparedStatementError(\"SQL injection warning for param '\".concat(name, \"'\"), 'EINJECT');\n      }\n\n      if (arguments.length < 2) {\n        throw new PreparedStatementError('Invalid number of arguments. 2 arguments expected.', 'EARGS');\n      }\n\n      if (type instanceof Function) type = type();\n\n      if (objectHasProperty(this.parameters, name)) {\n        throw new PreparedStatementError(\"The parameter name \".concat(name, \" has already been declared. Parameter names must be unique\"), 'EDUPEPARAM');\n      }\n\n      this.parameters[name] = {\n        name: name,\n        type: type.type,\n        io: 2,\n        length: type.length,\n        scale: type.scale,\n        precision: type.precision\n      };\n      return this;\n    }\n    /**\n     * Replace an output parameter on the request.\n     *\n     * @param {String} name Name of the output parameter without @ char.\n     * @param {*} type SQL data type of output parameter.\n     * @return {PreparedStatement}\n     */\n\n  }, {\n    key: \"replaceOutput\",\n    value: function replaceOutput(name, type) {\n      delete this.parameters[name];\n      return this.output(name, type);\n    }\n    /**\n     * Prepare a statement.\n     *\n     * @param {String} statement SQL statement to prepare.\n     * @param {basicCallback} [callback] A callback which is called after preparation has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {PreparedStatement|Promise}\n     */\n\n  }, {\n    key: \"prepare\",\n    value: function prepare(statement, callback) {\n      var _this2 = this;\n\n      if (typeof callback === 'function') {\n        this._prepare(statement, callback);\n\n        return this;\n      }\n\n      return new shared.Promise(function (resolve, reject) {\n        _this2._prepare(statement, function (err) {\n          if (err) return reject(err);\n          resolve(_this2);\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {String} statement\n     * @param {basicCallback} callback\n     */\n\n  }, {\n    key: \"_prepare\",\n    value: function _prepare(statement, callback) {\n      var _this3 = this;\n\n      debug('ps(%d): prepare', IDS.get(this));\n\n      if (typeof statement === 'function') {\n        callback = statement;\n        statement = undefined;\n      }\n\n      if (this.prepared) {\n        return setImmediate(callback, new PreparedStatementError('Statement is already prepared.', 'EALREADYPREPARED'));\n      }\n\n      this.statement = statement || this.statement;\n      this.parent.acquire(this, function (err, connection, config) {\n        if (err) return callback(err);\n        _this3._acquiredConnection = connection;\n        _this3._acquiredConfig = config;\n        var req = new shared.driver.Request(_this3);\n        req.stream = false;\n        req.output('handle', TYPES.Int);\n        req.input('params', TYPES.NVarChar, function () {\n          var result = [];\n\n          for (var name in _this3.parameters) {\n            if (!objectHasProperty(_this3.parameters, name)) {\n              continue;\n            }\n\n            var param = _this3.parameters[name];\n            result.push(\"@\".concat(name, \" \").concat(declare(param.type, param)).concat(param.io === 2 ? ' output' : ''));\n          }\n\n          return result;\n        }().join(','));\n        req.input('stmt', TYPES.NVarChar, _this3.statement);\n        req.execute('sp_prepare', function (err, result) {\n          if (err) {\n            _this3.parent.release(_this3._acquiredConnection);\n\n            _this3._acquiredConnection = null;\n            _this3._acquiredConfig = null;\n            return callback(err);\n          }\n\n          debug('ps(%d): prepared', IDS.get(_this3));\n          _this3._handle = result.output.handle;\n          _this3.prepared = true;\n          callback(null);\n        });\n      });\n    }\n    /**\n     * Execute a prepared statement.\n     *\n     * @param {Object} values An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n     * @param {basicCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {Request|Promise}\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(values, callback) {\n      var _this4 = this;\n\n      if (this.stream || typeof callback === 'function') {\n        return this._execute(values, callback);\n      }\n\n      return new shared.Promise(function (resolve, reject) {\n        _this4._execute(values, function (err, recordset) {\n          if (err) return reject(err);\n          resolve(recordset);\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {Object} values\n     * @param {basicCallback} callback\n     */\n\n  }, {\n    key: \"_execute\",\n    value: function _execute(values, callback) {\n      var req = new shared.driver.Request(this);\n      req.stream = this.stream;\n      req.arrayRowMode = this.arrayRowMode;\n      req.input('handle', TYPES.Int, this._handle); // copy parameters with new values\n\n      for (var name in this.parameters) {\n        if (!objectHasProperty(this.parameters, name)) {\n          continue;\n        }\n\n        var param = this.parameters[name];\n        req.parameters[name] = {\n          name: name,\n          type: param.type,\n          io: param.io,\n          value: values[name],\n          length: param.length,\n          scale: param.scale,\n          precision: param.precision\n        };\n      }\n\n      req.execute('sp_execute', function (err, result) {\n        if (err) return callback(err);\n        callback(null, result);\n      });\n      return req;\n    }\n    /**\n     * Unprepare a prepared statement.\n     *\n     * @param {basicCallback} [callback] A callback which is called after unpreparation has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {PreparedStatement|Promise}\n     */\n\n  }, {\n    key: \"unprepare\",\n    value: function unprepare(callback) {\n      var _this5 = this;\n\n      if (typeof callback === 'function') {\n        this._unprepare(callback);\n\n        return this;\n      }\n\n      return new shared.Promise(function (resolve, reject) {\n        _this5._unprepare(function (err) {\n          if (err) return reject(err);\n          resolve();\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {basicCallback} callback\n     */\n\n  }, {\n    key: \"_unprepare\",\n    value: function _unprepare(callback) {\n      var _this6 = this;\n\n      debug('ps(%d): unprepare', IDS.get(this));\n\n      if (!this.prepared) {\n        return setImmediate(callback, new PreparedStatementError('Statement is not prepared. Call prepare() first.', 'ENOTPREPARED'));\n      }\n\n      if (this._activeRequest) {\n        return setImmediate(callback, new TransactionError(\"Can't unprepare the statement. There is a request in progress.\", 'EREQINPROG'));\n      }\n\n      var req = new shared.driver.Request(this);\n      req.stream = false;\n      req.input('handle', TYPES.Int, this._handle);\n      req.execute('sp_unprepare', function (err) {\n        if (err) return callback(err);\n\n        _this6.parent.release(_this6._acquiredConnection);\n\n        _this6._acquiredConnection = null;\n        _this6._acquiredConfig = null;\n        _this6._handle = 0;\n        _this6.prepared = false;\n        debug('ps(%d): unprepared', IDS.get(_this6));\n        return callback(null);\n      });\n    }\n  }, {\n    key: \"connected\",\n    get: function get() {\n      return this.parent.connected;\n    }\n  }]);\n\n  return PreparedStatement;\n}(EventEmitter);\n\nmodule.exports = PreparedStatement;","map":null,"metadata":{},"sourceType":"script"}