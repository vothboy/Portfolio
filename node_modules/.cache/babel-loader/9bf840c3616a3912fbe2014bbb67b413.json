{"ast":null,"code":"'use strict';\n/* const FIGURE = {\n  INTERIOR_RING: 0x00,\n  STROKE: 0x01,\n  EXTERIOR_RING: 0x02\n};\n\nconst FIGURE_V2 = {\n  POINT: 0x00,\n  LINE: 0x01,\n  ARC: 0x02,\n  COMPOSITE_CURVE: 0x03\n};\n\nconst SHAPE = {\n  POINT: 0x01,\n  LINESTRING: 0x02,\n  POLYGON: 0x03,\n  MULTIPOINT: 0x04,\n  MULTILINESTRING: 0x05,\n  MULTIPOLYGON: 0x06,\n  GEOMETRY_COLLECTION: 0x07\n};\n\nconst SHAPE_V2 = {\n  POINT: 0x01,\n  LINESTRING: 0x02,\n  POLYGON: 0x03,\n  MULTIPOINT: 0x04,\n  MULTILINESTRING: 0x05,\n  MULTIPOLYGON: 0x06,\n  GEOMETRY_COLLECTION: 0x07,\n  CIRCULAR_STRING: 0x08,\n  COMPOUND_CURVE: 0x09,\n  CURVE_POLYGON: 0x0A,\n  FULL_GLOBE: 0x0B\n};\n\nconst SEGMENT = {\n  LINE: 0x00,\n  ARC: 0x01,\n  FIRST_LINE: 0x02,\n  FIRST_ARC: 0x03\n}; */\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar Point = function Point() {\n  _classCallCheck(this, Point);\n\n  this.x = 0;\n  this.y = 0;\n  this.z = null;\n  this.m = null;\n};\n\nvar parsePoints = function parsePoints(buffer, count) {\n  // s2.1.5 + s2.1.6\n  var points = [];\n\n  if (count < 1) {\n    return points;\n  }\n\n  for (var i = 1; i <= count; i++) {\n    var point = new Point();\n    points.push(point);\n    point.x = buffer.readDoubleLE(buffer.position);\n    point.y = buffer.readDoubleLE(buffer.position + 8);\n    buffer.position += 16;\n  }\n\n  return points;\n};\n\nvar parseZ = function parseZ(buffer, points) {\n  // s2.1.1 + s.2.1.2\n  if (points < 1) {\n    return;\n  }\n\n  points.forEach(function (point) {\n    point.z = buffer.readDoubleLE(buffer.position);\n    buffer.position += 8;\n  });\n};\n\nvar parseM = function parseM(buffer, points) {\n  // s2.1.1 + s.2.1.2\n  if (points < 1) {\n    return;\n  }\n\n  points.forEach(function (point) {\n    point.m = buffer.readDoubleLE(buffer.position);\n    buffer.position += 8;\n  });\n};\n\nvar parseFigures = function parseFigures(buffer, count, properties) {\n  // s2.1.3\n  var figures = [];\n\n  if (count < 1) {\n    return figures;\n  }\n\n  if (properties.P) {\n    figures.push({\n      attribute: 0x01,\n      pointOffset: 0\n    });\n  } else if (properties.L) {\n    figures.push({\n      attribute: 0x01,\n      pointOffset: 0\n    });\n  } else {\n    for (var i = 1; i <= count; i++) {\n      figures.push({\n        attribute: buffer.readUInt8(buffer.position),\n        pointOffset: buffer.readInt32LE(buffer.position + 1)\n      });\n      buffer.position += 5;\n    }\n  }\n\n  return figures;\n};\n\nvar parseShapes = function parseShapes(buffer, count, properties) {\n  // s2.1.4\n  var shapes = [];\n\n  if (count < 1) {\n    return shapes;\n  }\n\n  if (properties.P) {\n    shapes.push({\n      parentOffset: -1,\n      figureOffset: 0,\n      type: 0x01\n    });\n  } else if (properties.L) {\n    shapes.push({\n      parentOffset: -1,\n      figureOffset: 0,\n      type: 0x02\n    });\n  } else {\n    for (var i = 1; i <= count; i++) {\n      shapes.push({\n        parentOffset: buffer.readInt32LE(buffer.position),\n        figureOffset: buffer.readInt32LE(buffer.position + 4),\n        type: buffer.readUInt8(buffer.position + 8)\n      });\n      buffer.position += 9;\n    }\n  }\n\n  return shapes;\n};\n\nvar parseSegments = function parseSegments(buffer, count) {\n  // s2.1.7\n  var segments = [];\n\n  if (count < 1) {\n    return segments;\n  }\n\n  for (var i = 1; i <= count; i++) {\n    segments.push({\n      type: buffer.readUInt8(buffer.position)\n    });\n    buffer.position++;\n  }\n\n  return segments;\n};\n\nvar parseGeography = function parseGeography(buffer) {\n  // s2.1.1 + s.2.1.2\n  var srid = buffer.readInt32LE(0);\n\n  if (srid === -1) {\n    return null;\n  }\n\n  var value = {\n    srid: srid,\n    version: buffer.readUInt8(4)\n  };\n  var flags = buffer.readUInt8(5);\n  buffer.position = 6; // console.log(\"srid\", srid)\n  // console.log(\"version\", version)\n\n  var properties = {\n    Z: (flags & 1 << 0) > 0,\n    M: (flags & 1 << 1) > 0,\n    V: (flags & 1 << 2) > 0,\n    P: (flags & 1 << 3) > 0,\n    L: (flags & 1 << 4) > 0\n  };\n\n  if (value.version === 2) {\n    properties.H = (flags & 1 << 3) > 0;\n  } // console.log(\"properties\", properties);\n\n\n  var numberOfPoints;\n\n  if (properties.P) {\n    numberOfPoints = 1;\n  } else if (properties.L) {\n    numberOfPoints = 2;\n  } else {\n    numberOfPoints = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4;\n  } // console.log(\"numberOfPoints\", numberOfPoints)\n\n\n  value.points = parsePoints(buffer, numberOfPoints);\n\n  if (properties.Z) {\n    parseZ(buffer, value.points);\n  }\n\n  if (properties.M) {\n    parseM(buffer, value.points);\n  } // console.log(\"points\", points)\n\n\n  var numberOfFigures;\n\n  if (properties.P) {\n    numberOfFigures = 1;\n  } else if (properties.L) {\n    numberOfFigures = 1;\n  } else {\n    numberOfFigures = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4;\n  } // console.log(\"numberOfFigures\", numberOfFigures)\n\n\n  value.figures = parseFigures(buffer, numberOfFigures, properties); // console.log(\"figures\", figures)\n\n  var numberOfShapes;\n\n  if (properties.P) {\n    numberOfShapes = 1;\n  } else if (properties.L) {\n    numberOfShapes = 1;\n  } else {\n    numberOfShapes = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4;\n  } // console.log(\"numberOfShapes\", numberOfShapes)\n\n\n  value.shapes = parseShapes(buffer, numberOfShapes, properties); // console.log( \"shapes\", shapes)\n\n  if (value.version === 2 && buffer.position < buffer.length) {\n    var numberOfSegments = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4; // console.log(\"numberOfSegments\", numberOfSegments)\n\n    value.segments = parseSegments(buffer, numberOfSegments); // console.log(\"segments\", segments)\n  } else {\n    value.segments = [];\n  }\n\n  return value;\n};\n\nmodule.exports.PARSERS = {\n  geography: function geography(buffer) {\n    return parseGeography(buffer);\n  },\n  geometry: function geometry(buffer) {\n    return parseGeography(buffer);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}