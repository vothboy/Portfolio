{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar debug = require('debug')('mssql:base');\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar _require2 = require('../utils'),\n    IDS = _require2.IDS,\n    objectHasProperty = _require2.objectHasProperty;\n\nvar globalConnection = require('../global-connection');\n\nvar _require3 = require('../error'),\n    RequestError = _require3.RequestError,\n    ConnectionError = _require3.ConnectionError;\n\nvar _require4 = require('../datatypes'),\n    TYPES = _require4.TYPES;\n\nvar shared = require('../shared');\n/**\n * Class Request.\n *\n * @property {Transaction} transaction Reference to transaction when request was created in transaction.\n * @property {*} parameters Collection of input and output parameters.\n * @property {Boolean} canceled `true` if request was canceled.\n *\n * @fires Request#recordset\n * @fires Request#row\n * @fires Request#done\n * @fires Request#error\n */\n\n\nvar Request = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Request, _EventEmitter);\n\n  /**\n   * Create new Request.\n   *\n   * @param {Connection|ConnectionPool|Transaction|PreparedStatement} parent If ommited, global connection is used instead.\n   */\n  function Request(parent) {\n    var _this;\n\n    _classCallCheck(this, Request);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Request).call(this));\n    IDS.add(_assertThisInitialized(_assertThisInitialized(_this)), 'Request');\n    debug('request(%d): created', IDS.get(_assertThisInitialized(_assertThisInitialized(_this))));\n    _this.canceled = false;\n    _this._paused = false;\n    _this.parent = parent || globalConnection.pool;\n    _this.parameters = {};\n    return _this;\n  }\n\n  _createClass(Request, [{\n    key: \"template\",\n\n    /**\n     * Generate sql string and set imput parameters from tagged template string.\n     *\n     * @param {Template literal} template\n     * @return {String}\n     */\n    value: function template() {\n      var values = Array.prototype.slice.call(arguments);\n      var strings = values.shift();\n      return this._template(strings, values);\n    }\n    /**\n     * Fetch request from tagged template string.\n     *\n     * @private\n     * @param {Array} strings\n     * @param {Array} values\n     * @param {String} [method] If provided, method is automatically called with serialized command on this object.\n     * @return {Request}\n     */\n\n  }, {\n    key: \"_template\",\n    value: function _template(strings, values, method) {\n      var command = [strings[0]];\n\n      for (var index = 0; index < values.length; index++) {\n        var value = values[index]; // if value is an array, prepare each items as it's own comma separated parameter\n\n        if (Array.isArray(value)) {\n          for (var parameterIndex = 0; parameterIndex < value.length; parameterIndex++) {\n            this.input(\"param\".concat(index + 1, \"_\").concat(parameterIndex), value[parameterIndex]);\n            command.push(\"@param\".concat(index + 1, \"_\").concat(parameterIndex));\n\n            if (parameterIndex < value.length - 1) {\n              command.push(', ');\n            }\n          }\n\n          command.push(strings[index + 1]);\n        } else {\n          this.input(\"param\".concat(index + 1), value);\n          command.push(\"@param\".concat(index + 1), strings[index + 1]);\n        }\n      }\n\n      if (method) {\n        return this[method](command.join(''));\n      } else {\n        return command.join('');\n      }\n    }\n    /**\n     * Add an input parameter to the request.\n     *\n     * @param {String} name Name of the input parameter without @ char.\n     * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.\n     * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n     * @return {Request}\n     */\n\n  }, {\n    key: \"input\",\n    value: function input(name, type, value) {\n      if (/(--| |\\/\\*|\\*\\/|')/.test(name)) {\n        throw new RequestError(\"SQL injection warning for param '\".concat(name, \"'\"), 'EINJECT');\n      }\n\n      if (arguments.length < 2) {\n        throw new RequestError('Invalid number of arguments. At least 2 arguments expected.', 'EARGS');\n      } else if (arguments.length === 2) {\n        value = type;\n        type = shared.getTypeByValue(value);\n      } // support for custom data types\n\n\n      if (value && typeof value.valueOf === 'function' && !(value instanceof Date)) value = value.valueOf();\n      if (value === undefined) value = null; // undefined to null\n\n      if (typeof value === 'number' && isNaN(value)) value = null; // NaN to null\n\n      if (type instanceof Function) type = type();\n\n      if (objectHasProperty(this.parameters, name)) {\n        throw new RequestError(\"The parameter name \".concat(name, \" has already been declared. Parameter names must be unique\"), 'EDUPEPARAM');\n      }\n\n      this.parameters[name] = {\n        name: name,\n        type: type.type,\n        io: 1,\n        value: value,\n        length: type.length,\n        scale: type.scale,\n        precision: type.precision,\n        tvpType: type.tvpType\n      };\n      return this;\n    }\n    /**\n     * Replace an input parameter on the request.\n     *\n     * @param {String} name Name of the input parameter without @ char.\n     * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.\n     * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n     * @return {Request}\n     */\n\n  }, {\n    key: \"replaceInput\",\n    value: function replaceInput(name, type, value) {\n      delete this.parameters[name];\n      return this.input(name, type, value);\n    }\n    /**\n     * Add an output parameter to the request.\n     *\n     * @param {String} name Name of the output parameter without @ char.\n     * @param {*} type SQL data type of output parameter.\n     * @param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n     * @return {Request}\n     */\n\n  }, {\n    key: \"output\",\n    value: function output(name, type, value) {\n      if (!type) {\n        type = TYPES.NVarChar;\n      }\n\n      if (/(--| |\\/\\*|\\*\\/|')/.test(name)) {\n        throw new RequestError(\"SQL injection warning for param '\".concat(name, \"'\"), 'EINJECT');\n      }\n\n      if (type === TYPES.Text || type === TYPES.NText || type === TYPES.Image) {\n        throw new RequestError('Deprecated types (Text, NText, Image) are not supported as OUTPUT parameters.', 'EDEPRECATED');\n      } // support for custom data types\n\n\n      if (value && typeof value.valueOf === 'function' && !(value instanceof Date)) value = value.valueOf();\n      if (value === undefined) value = null; // undefined to null\n\n      if (typeof value === 'number' && isNaN(value)) value = null; // NaN to null\n\n      if (type instanceof Function) type = type();\n\n      if (objectHasProperty(this.parameters, name)) {\n        throw new RequestError(\"The parameter name \".concat(name, \" has already been declared. Parameter names must be unique\"), 'EDUPEPARAM');\n      }\n\n      this.parameters[name] = {\n        name: name,\n        type: type.type,\n        io: 2,\n        value: value,\n        length: type.length,\n        scale: type.scale,\n        precision: type.precision\n      };\n      return this;\n    }\n    /**\n     * Replace an output parameter on the request.\n     *\n     * @param {String} name Name of the output parameter without @ char.\n     * @param {*} type SQL data type of output parameter.\n     * @param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n     * @return {Request}\n     */\n\n  }, {\n    key: \"replaceOutput\",\n    value: function replaceOutput(name, type, value) {\n      delete this.parameters[name];\n      return this.output(name, type, value);\n    }\n    /**\n     * Execute the SQL batch.\n     *\n     * @param {String} batch T-SQL batch to be executed.\n     * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {Request|Promise}\n     */\n\n  }, {\n    key: \"batch\",\n    value: function batch(_batch, callback) {\n      var _this2 = this;\n\n      if (this.stream == null && this.connection) this.stream = this.connection.config.stream;\n      if (this.arrayRowMode == null && this.connection) this.arrayRowMode = this.connection.config.arrayRowMode;\n      this.rowsAffected = 0;\n\n      if (typeof callback === 'function') {\n        this._batch(_batch, function (err, recordsets, output, rowsAffected) {\n          if (_this2.stream) {\n            if (err) _this2.emit('error', err);\n            err = null;\n\n            _this2.emit('done', {\n              output: output,\n              rowsAffected: rowsAffected\n            });\n          }\n\n          if (err) return callback(err);\n          callback(null, {\n            recordsets: recordsets,\n            recordset: recordsets && recordsets[0],\n            output: output,\n            rowsAffected: rowsAffected\n          });\n        });\n\n        return this;\n      } // Check is method was called as tagged template\n\n\n      if (typeof _batch === 'object') {\n        var values = Array.prototype.slice.call(arguments);\n        var strings = values.shift();\n        _batch = this._template(strings, values);\n      }\n\n      return new shared.Promise(function (resolve, reject) {\n        _this2._batch(_batch, function (err, recordsets, output, rowsAffected) {\n          if (_this2.stream) {\n            if (err) _this2.emit('error', err);\n            err = null;\n\n            _this2.emit('done', {\n              output: output,\n              rowsAffected: rowsAffected\n            });\n          }\n\n          if (err) return reject(err);\n          resolve({\n            recordsets: recordsets,\n            recordset: recordsets && recordsets[0],\n            output: output,\n            rowsAffected: rowsAffected\n          });\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {String} batch\n     * @param {Request~requestCallback} callback\n     */\n\n  }, {\n    key: \"_batch\",\n    value: function _batch(batch, callback) {\n      if (!this.connection) {\n        return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'));\n      }\n\n      if (!this.connection.connected) {\n        return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'));\n      }\n\n      this.canceled = false;\n      setImmediate(callback);\n    }\n    /**\n     * Bulk load.\n     *\n     * @param {Table} table SQL table.\n     * @param {object} [options] Options to be passed to the underlying driver (tedious only).\n     * @param {Request~bulkCallback} [callback] A callback which is called after bulk load has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {Request|Promise}\n     */\n\n  }, {\n    key: \"bulk\",\n    value: function bulk(table, options, callback) {\n      var _this3 = this;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      } else if (typeof options === 'undefined') {\n        options = {};\n      }\n\n      if (this.stream == null && this.connection) this.stream = this.connection.config.stream;\n      if (this.arrayRowMode == null && this.connection) this.arrayRowMode = this.connection.config.arrayRowMode;\n\n      if (this.stream || typeof callback === 'function') {\n        this._bulk(table, options, function (err, rowsAffected) {\n          if (_this3.stream) {\n            if (err) _this3.emit('error', err);\n            return _this3.emit('done', {\n              rowsAffected: rowsAffected\n            });\n          }\n\n          if (err) return callback(err);\n          callback(null, {\n            rowsAffected: rowsAffected\n          });\n        });\n\n        return this;\n      }\n\n      return new shared.Promise(function (resolve, reject) {\n        _this3._bulk(table, options, function (err, rowsAffected) {\n          if (err) return reject(err);\n          resolve({\n            rowsAffected: rowsAffected\n          });\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {Table} table\n     * @param {object} options\n     * @param {Request~bulkCallback} callback\n     */\n\n  }, {\n    key: \"_bulk\",\n    value: function _bulk(table, options, callback) {\n      if (!this.parent) {\n        return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'));\n      }\n\n      if (!this.parent.connected) {\n        return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'));\n      }\n\n      this.canceled = false;\n      setImmediate(callback);\n    }\n    /**\n     * Sets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n     *\n     * @param {Stream} stream Stream to pipe data into.\n     * @return {Stream}\n     */\n\n  }, {\n    key: \"pipe\",\n    value: function pipe(stream) {\n      this.stream = true;\n      this.on('row', stream.write.bind(stream));\n      this.on('error', stream.emit.bind(stream, 'error'));\n      this.on('done', function () {\n        setImmediate(function () {\n          return stream.end();\n        });\n      });\n      stream.emit('pipe', this);\n      return stream;\n    }\n    /**\n     * Execute the SQL command.\n     *\n     * @param {String} command T-SQL command to be executed.\n     * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {Request|Promise}\n     */\n\n  }, {\n    key: \"query\",\n    value: function query(command, callback) {\n      var _this4 = this;\n\n      if (this.stream == null && this.connection) this.stream = this.connection.config.stream;\n      if (this.arrayRowMode == null && this.connection) this.arrayRowMode = this.connection.config.arrayRowMode;\n      this.rowsAffected = 0;\n\n      if (typeof callback === 'function') {\n        this._query(command, function (err, recordsets, output, rowsAffected, columns) {\n          if (_this4.stream) {\n            if (err) _this4.emit('error', err);\n            err = null;\n\n            _this4.emit('done', {\n              output: output,\n              rowsAffected: rowsAffected\n            });\n          }\n\n          if (err) return callback(err);\n          var result = {\n            recordsets: recordsets,\n            recordset: recordsets && recordsets[0],\n            output: output,\n            rowsAffected: rowsAffected\n          };\n          if (_this4.arrayRowMode) result.columns = columns;\n          callback(null, result);\n        });\n\n        return this;\n      } // Check is method was called as tagged template\n\n\n      if (typeof command === 'object') {\n        var values = Array.prototype.slice.call(arguments);\n        var strings = values.shift();\n        command = this._template(strings, values);\n      }\n\n      return new shared.Promise(function (resolve, reject) {\n        _this4._query(command, function (err, recordsets, output, rowsAffected, columns) {\n          if (_this4.stream) {\n            if (err) _this4.emit('error', err);\n            err = null;\n\n            _this4.emit('done', {\n              output: output,\n              rowsAffected: rowsAffected\n            });\n          }\n\n          if (err) return reject(err);\n          var result = {\n            recordsets: recordsets,\n            recordset: recordsets && recordsets[0],\n            output: output,\n            rowsAffected: rowsAffected\n          };\n          if (_this4.arrayRowMode) result.columns = columns;\n          resolve(result);\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {String} command\n     * @param {Request~bulkCallback} callback\n     */\n\n  }, {\n    key: \"_query\",\n    value: function _query(command, callback) {\n      if (!this.parent) {\n        return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'));\n      }\n\n      if (!this.parent.connected) {\n        return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'));\n      }\n\n      this.canceled = false;\n      setImmediate(callback);\n    }\n    /**\n     * Call a stored procedure.\n     *\n     * @param {String} procedure Name of the stored procedure to be executed.\n     * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n     * @return {Request|Promise}\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute(command, callback) {\n      var _this5 = this;\n\n      if (this.stream == null && this.connection) this.stream = this.connection.config.stream;\n      if (this.arrayRowMode == null && this.connection) this.arrayRowMode = this.connection.config.arrayRowMode;\n      this.rowsAffected = 0;\n\n      if (typeof callback === 'function') {\n        this._execute(command, function (err, recordsets, output, returnValue, rowsAffected, columns) {\n          if (_this5.stream) {\n            if (err) _this5.emit('error', err);\n            err = null;\n\n            _this5.emit('done', {\n              output: output,\n              rowsAffected: rowsAffected,\n              returnValue: returnValue\n            });\n          }\n\n          if (err) return callback(err);\n          var result = {\n            recordsets: recordsets,\n            recordset: recordsets && recordsets[0],\n            output: output,\n            rowsAffected: rowsAffected,\n            returnValue: returnValue\n          };\n          if (_this5.arrayRowMode) result.columns = columns;\n          callback(null, result);\n        });\n\n        return this;\n      }\n\n      return new shared.Promise(function (resolve, reject) {\n        _this5._execute(command, function (err, recordsets, output, returnValue, rowsAffected, columns) {\n          if (_this5.stream) {\n            if (err) _this5.emit('error', err);\n            err = null;\n\n            _this5.emit('done', {\n              output: output,\n              rowsAffected: rowsAffected,\n              returnValue: returnValue\n            });\n          }\n\n          if (err) return reject(err);\n          var result = {\n            recordsets: recordsets,\n            recordset: recordsets && recordsets[0],\n            output: output,\n            rowsAffected: rowsAffected,\n            returnValue: returnValue\n          };\n          if (_this5.arrayRowMode) result.columns = columns;\n          resolve(result);\n        });\n      });\n    }\n    /**\n     * @private\n     * @param {String} procedure\n     * @param {Request~bulkCallback} callback\n     */\n\n  }, {\n    key: \"_execute\",\n    value: function _execute(procedure, callback) {\n      if (!this.parent) {\n        return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'));\n      }\n\n      if (!this.parent.connected) {\n        return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'));\n      }\n\n      this.canceled = false;\n      setImmediate(callback);\n    }\n    /**\n     * Cancel currently executed request.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this._cancel();\n\n      return true;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_cancel\",\n    value: function _cancel() {\n      this.canceled = true;\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this.stream) {\n        this._pause();\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_pause\",\n    value: function _pause() {\n      this._paused = true;\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this.stream) {\n        this._resume();\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_resume\",\n    value: function _resume() {\n      this._paused = false;\n    }\n  }, {\n    key: \"_setCurrentRequest\",\n    value: function _setCurrentRequest(request) {\n      this._currentRequest = request;\n\n      if (this._paused) {\n        this.pause();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"paused\",\n    get: function get() {\n      return this._paused;\n    }\n  }]);\n\n  return Request;\n}(EventEmitter);\n\nmodule.exports = Request;","map":null,"metadata":{},"sourceType":"script"}