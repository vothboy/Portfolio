{"ast":null,"code":"/*\r\n * @copyright\r\n * Copyright Â© Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\n'use strict';\n\nvar jwtConstants = require('./constants').Jwt;\n\nvar Logger = require('./log').Logger;\n\nvar util = require('./util');\n\nrequire('date-utils');\n\nvar jws = require('jws');\n\nvar uuid = require('uuid');\n/**\r\n * JavaScript dates are in milliseconds, but JWT dates are in seconds.\r\n * This function does the conversion.\r\n * @param  {Date}   date\r\n * @return {string}\r\n */\n\n\nfunction dateGetTimeInSeconds(date) {\n  return Math.floor(date.getTime() / 1000);\n}\n/**\r\n * Constructs a new SelfSignedJwt object.\r\n * @param {object}    callContext    Context specific to this token request.\r\n * @param {Authority} authority      The authority to be used as the JWT audience.\r\n * @param {string}    clientId       The client id of the calling app.\r\n */\n\n\nfunction SelfSignedJwt(callContext, authority, clientId) {\n  this._log = new Logger('SelfSignedJwt', callContext._logContext);\n  this._callContext = callContext;\n  this._authority = authority;\n  this._tokenEndpoint = authority.tokenEndpoint;\n  this._clientId = clientId;\n}\n/**\r\n * This wraps date creation in order to make unit testing easier.\r\n * @return {Date}\r\n */\n\n\nSelfSignedJwt.prototype._getDateNow = function () {\n  return new Date();\n};\n\nSelfSignedJwt.prototype._getNewJwtId = function () {\n  return uuid.v4();\n};\n/**\r\n * A regular certificate thumbprint is a hex encode string of the binary certificate\r\n * hash.  For some reason teh x5t value in a JWT is a url save base64 encoded string\r\n * instead.  This function does the conversion.\r\n * @param  {string} thumbprint  A hex encoded certificate thumbprint.\r\n * @return {string} A url safe base64 encoded certificate thumbprint.\r\n */\n\n\nSelfSignedJwt.prototype._createx5tValue = function (thumbprint) {\n  var hexString = thumbprint.replace(/:/g, '').replace(/ /g, '');\n  var base64 = new Buffer(hexString, 'hex').toString('base64');\n  return util.convertRegularToUrlSafeBase64EncodedString(base64);\n};\n/**\r\n * Creates the JWT header.\r\n * @param  {string} thumbprint  A hex encoded certificate thumbprint.\r\n * @return {object}\r\n */\n\n\nSelfSignedJwt.prototype._createHeader = function (thumbprint) {\n  var x5t = this._createx5tValue(thumbprint);\n\n  var header = {\n    typ: 'JWT',\n    alg: 'RS256',\n    x5t: x5t\n  };\n\n  this._log.verbose('Creating self signed JWT header');\n\n  this._log.verbose('Creating self signed JWT header.  x5t: ' + x5t, true);\n\n  return header;\n};\n/**\r\n * Creates the JWT payload.\r\n * @return {object}\r\n */\n\n\nSelfSignedJwt.prototype._createPayload = function () {\n  var now = this._getDateNow();\n\n  var expires = new Date(now.getTime()).addMinutes(jwtConstants.SELF_SIGNED_JWT_LIFETIME);\n\n  this._log.verbose('Creating self signed JWT payload.  Expires: ' + expires + ' NotBefore: ' + now);\n\n  var jwtPayload = {};\n  jwtPayload[jwtConstants.AUDIENCE] = this._tokenEndpoint;\n  jwtPayload[jwtConstants.ISSUER] = this._clientId;\n  jwtPayload[jwtConstants.SUBJECT] = this._clientId;\n  jwtPayload[jwtConstants.NOT_BEFORE] = dateGetTimeInSeconds(now);\n  jwtPayload[jwtConstants.EXPIRES_ON] = dateGetTimeInSeconds(expires);\n  jwtPayload[jwtConstants.JWT_ID] = this._getNewJwtId();\n  return jwtPayload;\n};\n\nSelfSignedJwt.prototype._throwOnInvalidJwtSignature = function (jwt) {\n  var jwtSegments = jwt.split('.');\n\n  if (3 > jwtSegments.length || !jwtSegments[2]) {\n    throw this._log.createError('Failed to sign JWT.  This is most likely due to an invalid certificate.');\n  }\n\n  return;\n};\n\nSelfSignedJwt.prototype._signJwt = function (header, payload, certificate) {\n  var jwt;\n\n  try {\n    jwt = jws.sign({\n      header: header,\n      payload: payload,\n      secret: certificate\n    });\n  } catch (err) {\n    this._log.error(err, true);\n\n    throw this._log.createError('Failed to sign JWT.This is most likely due to an invalid certificate.');\n  }\n\n  this._throwOnInvalidJwtSignature(jwt);\n\n  return jwt;\n};\n\nSelfSignedJwt.prototype._reduceThumbprint = function (thumbprint) {\n  var canonical = thumbprint.toLowerCase().replace(/ /g, '').replace(/:/g, '');\n\n  this._throwOnInvalidThumbprint(canonical);\n\n  return canonical;\n};\n\nvar numCharIn128BitHexString = 128 / 8 * 2;\nvar numCharIn160BitHexString = 160 / 8 * 2;\nvar thumbprintSizes = {};\nthumbprintSizes[numCharIn128BitHexString] = true;\nthumbprintSizes[numCharIn160BitHexString] = true;\nvar thumbprintRegExp = /^[a-f\\d]*$/;\n\nSelfSignedJwt.prototype._throwOnInvalidThumbprint = function (thumbprint) {\n  if (!thumbprintSizes[thumbprint.length] || !thumbprintRegExp.test(thumbprint)) {\n    throw this._log.createError('The thumbprint does not match a known format');\n  }\n};\n/**\r\n * Creates a self signed JWT that can be used as a client_assertion.\r\n * @param  {string}  certificate   A PEM encoded certificate private key.\r\n * @param  {string}  thumbprint    A hex encoded thumbprint of the certificate.\r\n * @return {string}  A self signed JWT token.\r\n */\n\n\nSelfSignedJwt.prototype.create = function (certificate, thumbprint) {\n  thumbprint = this._reduceThumbprint(thumbprint);\n\n  var header = this._createHeader(thumbprint);\n\n  var payload = this._createPayload();\n\n  var jwt = this._signJwt(header, payload, certificate);\n\n  return jwt;\n};\n\nmodule.exports = SelfSignedJwt;","map":null,"metadata":{},"sourceType":"script"}