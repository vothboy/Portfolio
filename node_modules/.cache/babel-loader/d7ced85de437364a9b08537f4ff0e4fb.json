{"ast":null,"code":"/*\r\n * @copyright\r\n * Copyright Â© Microsoft Open Technologies, Inc.\r\n *\r\n * All Rights Reserved\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http: *www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\r\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\r\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\r\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\r\n *\r\n * See the Apache License, Version 2.0 for the specific language\r\n * governing permissions and limitations under the License.\r\n */\n'use strict';\n\nvar querystring = require('querystring');\n\nvar request = require('request');\n\nvar _ = require('underscore');\n\nvar url = require('url');\n\nvar constants = require('./constants');\n\nvar Logger = require('./log').Logger;\n\nvar util = require('./util');\n\nvar AccountType = constants.UserRealm.AccountType;\nvar FederationProtocolType = constants.UserRealm.FederationProtocolType;\nvar USER_REALM_PATH_TEMPLATE = 'common/UserRealm/<user>';\n/**\r\n * Create a new UserRealm object\r\n * @private\r\n * @constructor\r\n * @param {object} callContext Contains any context information that applies to the request.\r\n * @param {string} userPrinciple   The username for which a realm needs to be discovered.\r\n * @param {string} authority       The string url of the authority that owns the userPrinciple.\r\n */\n\nfunction UserRealm(callContext, userPrinciple, authority) {\n  this._log = new Logger('UserRealm', callContext._logContext);\n  this._callContext = callContext;\n  this._apiVersion = '1.0';\n  this._federationProtocol = null;\n  this._accountType = null;\n  this._federationMetadataUrl = null;\n  this._federationActiveAuthUrl = null;\n  this._userPrinciple = userPrinciple;\n  this._authority = authority;\n}\n/**\r\n* The API version requested by UserRealm.\r\n* @type {string}\r\n* @instance\r\n* @memberOf UserRealm\r\n* @name apiVersion\r\n*/\n\n\nObject.defineProperty(UserRealm.prototype, 'apiVersion', {\n  get: function get() {\n    return this._apiVersion;\n  }\n});\n/**\r\n* The federation protocol used by the users realm.\r\n* @type {string}\r\n* @instance\r\n* @memberOf UserRealm\r\n* @name federationProtocol\r\n*/\n\nObject.defineProperty(UserRealm.prototype, 'federationProtocol', {\n  get: function get() {\n    return this._federationProtocol;\n  }\n});\n/**\r\n* The Type of account.  Either managed or federated.\r\n* @type {string}\r\n* @instance\r\n* @memberOf UserRealm\r\n* @name accountType\r\n*/\n\nObject.defineProperty(UserRealm.prototype, 'accountType', {\n  get: function get() {\n    return this._accountType;\n  }\n});\n/**\r\n* If this is a federated account then this property will contain the mex url.\r\n* @type {string}\r\n* @instance\r\n* @memberOf UserRealm\r\n* @name federationsMetadataUrl\r\n*/\n\nObject.defineProperty(UserRealm.prototype, 'federationMetadataUrl', {\n  get: function get() {\n    return this._federationMetadataUrl;\n  }\n});\n/**\r\n* If the account is federated this will contain the authentication endpoint.\r\n* @type {string}\r\n* @instance\r\n* @memberOf UserRealm\r\n* @name federationActiveAuthUrl\r\n*/\n\nObject.defineProperty(UserRealm.prototype, 'federationActiveAuthUrl', {\n  get: function get() {\n    return this._federationActiveAuthUrl;\n  }\n});\n/**\r\n* Given the authority url this method constructs a full user realm discovery url.\r\n* @private\r\n* @returns A full user realm discovery url including path and query string.\r\n*/\n\nUserRealm.prototype._getUserRealmUrl = function () {\n  var userRealmUrl = util.copyUrl(this._authority);\n  var urlEncodedUser = encodeURIComponent(this._userPrinciple);\n  userRealmUrl.pathname = USER_REALM_PATH_TEMPLATE.replace('<user>', urlEncodedUser);\n  var userRealmQuery = {\n    'api-version': this._apiVersion\n  };\n  userRealmUrl.search = querystring.stringify(userRealmQuery);\n  userRealmUrl = util.copyUrl(userRealmUrl);\n  return userRealmUrl;\n};\n/**\r\n* Given a constants object and a value, validates that the value is a key in the constants object.\r\n* @private\r\n* @param {object} constants   An object containing constant key value pairs.\r\n* @param {string}  value       A value to check against the constants\r\n* @param {bool}   caseSensitive  set to true if comparisons should be made as case sensitive.  Defaults to false.\r\n* @returns {bool|string}  If value passed in matches one of the constants then the return value is the matched constant.\r\n*                         If a non case sensitive match was done, then the value returned may be different than the value\r\n*                         passed in.  If there is no match then the method returns false.\r\n*/\n\n\nUserRealm.prototype._validateConstantValue = function (constants, value, caseSensitive) {\n  if (!value) {\n    return false;\n  }\n\n  if (!caseSensitive) {\n    value = value.toLowerCase();\n  }\n\n  return _.contains(_.values(constants), value) ? value : false;\n};\n/**\r\n* Checks whether an account type string is valid.\r\n* @private\r\n* @param {string} type  An account type string.\r\n* @returns {bool}\r\n*/\n\n\nUserRealm.prototype._validateAccountType = function (type) {\n  return this._validateConstantValue(AccountType, type);\n};\n/**\r\n* Checks whether a federation protocol string is valid.\r\n* @private\r\n* @param {string} protocol  A federation protocol string.\r\n* @returns {bool}\r\n*/\n\n\nUserRealm.prototype._validateFederationProtocol = function (protocol) {\n  return this._validateConstantValue(FederationProtocolType, protocol);\n};\n/**\r\n* Logs the values parsed as part of user realm discovery.\r\n* @private\r\n*/\n\n\nUserRealm.prototype._logParsedResponse = function () {\n  this._log.verbose('UserRealm response:');\n\n  this._log.verbose(' AccountType:             ' + this.accountType);\n\n  this._log.verbose(' FederationProtocol:      ' + this.federationProtocol);\n\n  this._log.verbose(' FederationMetatdataUrl:  ' + this.federationMetadataUrl, true);\n\n  this._log.verbose(' FederationActiveAuthUrl: ' + this.federationActiveAuthUrl, true);\n};\n/**\r\n* Parses the response from a user realm discovery request.\r\n* @private\r\n* @param {string} body    The body returned as part of the http user realm discovery request.\r\n* @param {UserRealm.DiscoverCallback} callback  Called when parsing is complete.\r\n*/\n\n\nUserRealm.prototype._parseDiscoveryResponse = function (body, callback) {\n  this._log.verbose('Discovery response:\\n' + body, true);\n\n  var response;\n\n  try {\n    response = JSON.parse(body);\n  } catch (err) {\n    callback(this._log.createError('Parsing realm discovery respone JSON failed: ' + body, true));\n    return;\n  }\n\n  var accountType = this._validateAccountType(response['account_type']);\n\n  if (!accountType) {\n    callback(this._log.createError('Cannot parse account_type: ' + accountType));\n    return;\n  }\n\n  this._accountType = accountType;\n\n  if (this._accountType === AccountType.Federated) {\n    var protocol = this._validateFederationProtocol(response['federation_protocol']);\n\n    if (!protocol) {\n      callback(this._log.createError('Cannot parse federation protocol: ' + protocol));\n      return;\n    }\n\n    this._federationProtocol = protocol;\n    this._federationMetadataUrl = response['federation_metadata_url'];\n    this._federationActiveAuthUrl = response['federation_active_auth_url'];\n  }\n\n  this._logParsedResponse();\n\n  callback();\n};\n/**\r\n* @callback DiscoverCallback\r\n* @memberOf UserRealm\r\n* @param {Error} error   If an error occurs during discovery then this parameter will be used to return the error.\r\n*/\n\n/**\r\n* Performs user realm discovery and fills in the properties on this object.\r\n* @private\r\n* @param {UserRealm.DiscoverCallback} callback  Called when discovery is complete.\r\n*/\n\n\nUserRealm.prototype.discover = function (callback) {\n  var self = this;\n  var options = util.createRequestOptions(this, {\n    headers: {\n      Accept: 'application/json'\n    }\n  });\n\n  var userRealmUrl = this._getUserRealmUrl();\n\n  this._log.verbose('Performing user realm discovery at: ' + url.format(userRealmUrl), true);\n\n  request.get(userRealmUrl, options, util.createRequestHandler('User Realm Discovery', this._log, callback, function (response, body) {\n    self._parseDiscoveryResponse(body, callback);\n  }));\n};\n\nmodule.exports = UserRealm;","map":null,"metadata":{},"sourceType":"script"}