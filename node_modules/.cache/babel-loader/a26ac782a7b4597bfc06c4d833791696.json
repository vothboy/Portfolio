{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\vothb\\\\Desktop\\\\School\\\\Quarter_5\\\\CIS259\\\\Plankcooking-microservices\\\\Plankcooking\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _jsbi = _interopRequireDefault(require(\"jsbi\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar SHIFT_LEFT_32 = (1 << 16) * (1 << 16);\nvar SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\nvar UNKNOWN_PLP_LEN = Buffer.from([0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);\nvar ZERO_LENGTH_BUFFER = Buffer.alloc(0);\n/**\n  A Buffer-like class that tracks position.\n\n  As values are written, the position advances by the size of the written data.\n  When writing, automatically allocates new buffers if there's not enough space.\n */\n\nvar WritableTrackingBuffer = /*#__PURE__*/function () {\n  function WritableTrackingBuffer(initialSize, encoding, doubleSizeGrowth) {\n    _classCallCheck(this, WritableTrackingBuffer);\n\n    this.initialSize = void 0;\n    this.encoding = void 0;\n    this.doubleSizeGrowth = void 0;\n    this.buffer = void 0;\n    this.compositeBuffer = void 0;\n    this.position = void 0;\n    this.initialSize = initialSize;\n    this.encoding = encoding || 'ucs2';\n    this.doubleSizeGrowth = doubleSizeGrowth || false;\n    this.buffer = Buffer.alloc(this.initialSize, 0);\n    this.compositeBuffer = ZERO_LENGTH_BUFFER;\n    this.position = 0;\n  }\n\n  _createClass(WritableTrackingBuffer, [{\n    key: \"copyFrom\",\n    value: function copyFrom(buffer) {\n      var length = buffer.length;\n      this.makeRoomFor(length);\n      buffer.copy(this.buffer, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"makeRoomFor\",\n    value: function makeRoomFor(requiredLength) {\n      if (this.buffer.length - this.position < requiredLength) {\n        if (this.doubleSizeGrowth) {\n          var size = Math.max(128, this.buffer.length * 2);\n\n          while (size < requiredLength) {\n            size *= 2;\n          }\n\n          this.newBuffer(size);\n        } else {\n          this.newBuffer(requiredLength);\n        }\n      }\n    }\n  }, {\n    key: \"newBuffer\",\n    value: function newBuffer(size) {\n      var buffer = this.buffer.slice(0, this.position);\n      this.compositeBuffer = Buffer.concat([this.compositeBuffer, buffer]);\n      this.buffer = size === 0 ? ZERO_LENGTH_BUFFER : Buffer.alloc(size, 0);\n      this.position = 0;\n    }\n  }, {\n    key: \"writeUInt8\",\n    value: function writeUInt8(value) {\n      var length = 1;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt8(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeUInt16LE\",\n    value: function writeUInt16LE(value) {\n      var length = 2;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt16LE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeUShort\",\n    value: function writeUShort(value) {\n      this.writeUInt16LE(value);\n    }\n  }, {\n    key: \"writeUInt16BE\",\n    value: function writeUInt16BE(value) {\n      var length = 2;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt16BE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeUInt24LE\",\n    value: function writeUInt24LE(value) {\n      var length = 3;\n      this.makeRoomFor(length);\n      this.buffer[this.position + 2] = value >>> 16 & 0xff;\n      this.buffer[this.position + 1] = value >>> 8 & 0xff;\n      this.buffer[this.position] = value & 0xff;\n      this.position += length;\n    }\n  }, {\n    key: \"writeUInt32LE\",\n    value: function writeUInt32LE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt32LE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeBigInt64LE\",\n    value: function writeBigInt64LE(value) {\n      this.writeBigU_Int64LE(value);\n    }\n  }, {\n    key: \"writeBigU_Int64LE\",\n    value: function writeBigU_Int64LE(value) {\n      this.makeRoomFor(8);\n\n      var lo = _jsbi.default.toNumber(_jsbi.default.bitwiseAnd(value, _jsbi.default.BigInt(0xffffffff)));\n\n      this.buffer[this.position++] = lo;\n      lo = lo >> 8;\n      this.buffer[this.position++] = lo;\n      lo = lo >> 8;\n      this.buffer[this.position++] = lo;\n      lo = lo >> 8;\n      this.buffer[this.position++] = lo;\n\n      var hi = _jsbi.default.toNumber(_jsbi.default.bitwiseAnd(_jsbi.default.signedRightShift(value, _jsbi.default.BigInt(32)), _jsbi.default.BigInt(0xffffffff)));\n\n      this.buffer[this.position++] = hi;\n      hi = hi >> 8;\n      this.buffer[this.position++] = hi;\n      hi = hi >> 8;\n      this.buffer[this.position++] = hi;\n      hi = hi >> 8;\n      this.buffer[this.position++] = hi;\n    }\n  }, {\n    key: \"writeInt64LE\",\n    value: function writeInt64LE(value) {\n      this.writeBigInt64LE(_jsbi.default.BigInt(value));\n    }\n  }, {\n    key: \"writeUInt32BE\",\n    value: function writeUInt32BE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeUInt32BE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeUInt40LE\",\n    value: function writeUInt40LE(value) {\n      // inspired by https://github.com/dpw/node-buffer-more-ints\n      this.writeInt32LE(value & -1);\n      this.writeUInt8(Math.floor(value * SHIFT_RIGHT_32));\n    }\n  }, {\n    key: \"writeUInt64LE\",\n    value: function writeUInt64LE(value) {\n      this.writeBigUInt64LE(_jsbi.default.BigInt(value));\n    }\n  }, {\n    key: \"writeBigUInt64LE\",\n    value: function writeBigUInt64LE(value) {\n      this.writeBigU_Int64LE(value);\n    }\n  }, {\n    key: \"writeInt8\",\n    value: function writeInt8(value) {\n      var length = 1;\n      this.makeRoomFor(length);\n      this.buffer.writeInt8(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeInt16LE\",\n    value: function writeInt16LE(value) {\n      var length = 2;\n      this.makeRoomFor(length);\n      this.buffer.writeInt16LE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeInt16BE\",\n    value: function writeInt16BE(value) {\n      var length = 2;\n      this.makeRoomFor(length);\n      this.buffer.writeInt16BE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeInt32LE\",\n    value: function writeInt32LE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeInt32LE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeInt32BE\",\n    value: function writeInt32BE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeInt32BE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeFloatLE\",\n    value: function writeFloatLE(value) {\n      var length = 4;\n      this.makeRoomFor(length);\n      this.buffer.writeFloatLE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeDoubleLE\",\n    value: function writeDoubleLE(value) {\n      var length = 8;\n      this.makeRoomFor(length);\n      this.buffer.writeDoubleLE(value, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeString\",\n    value: function writeString(value, encoding) {\n      if (encoding == null) {\n        encoding = this.encoding;\n      }\n\n      var length = Buffer.byteLength(value, encoding);\n      this.makeRoomFor(length); // $FlowFixMe https://github.com/facebook/flow/pull/5398\n\n      this.buffer.write(value, this.position, encoding);\n      this.position += length;\n    }\n  }, {\n    key: \"writeBVarchar\",\n    value: function writeBVarchar(value, encoding) {\n      this.writeUInt8(value.length);\n      this.writeString(value, encoding);\n    }\n  }, {\n    key: \"writeUsVarchar\",\n    value: function writeUsVarchar(value, encoding) {\n      this.writeUInt16LE(value.length);\n      this.writeString(value, encoding);\n    } // TODO: Figure out what types are passed in other than `Buffer`\n\n  }, {\n    key: \"writeUsVarbyte\",\n    value: function writeUsVarbyte(value, encoding) {\n      if (encoding == null) {\n        encoding = this.encoding;\n      }\n\n      var length;\n\n      if (value instanceof Buffer) {\n        length = value.length;\n      } else {\n        value = value.toString();\n        length = Buffer.byteLength(value, encoding);\n      }\n\n      this.writeUInt16LE(length);\n\n      if (value instanceof Buffer) {\n        this.writeBuffer(value);\n      } else {\n        this.makeRoomFor(length); // $FlowFixMe https://github.com/facebook/flow/pull/5398\n\n        this.buffer.write(value, this.position, encoding);\n        this.position += length;\n      }\n    }\n  }, {\n    key: \"writePLPBody\",\n    value: function writePLPBody(value, encoding) {\n      if (encoding == null) {\n        encoding = this.encoding;\n      }\n\n      var length;\n\n      if (value instanceof Buffer) {\n        length = value.length;\n      } else {\n        value = value.toString();\n        length = Buffer.byteLength(value, encoding);\n      } // Length of all chunks.\n      // this.writeUInt64LE(length);\n      // unknown seems to work better here - might revisit later.\n\n\n      this.writeBuffer(UNKNOWN_PLP_LEN); // In the UNKNOWN_PLP_LEN case, the data is represented as a series of zero or more chunks.\n\n      if (length > 0) {\n        // One chunk.\n        this.writeUInt32LE(length);\n\n        if (value instanceof Buffer) {\n          this.writeBuffer(value);\n        } else {\n          this.makeRoomFor(length);\n          this.buffer.write(value, this.position, encoding);\n          this.position += length;\n        }\n      } // PLP_TERMINATOR (no more chunks).\n\n\n      this.writeUInt32LE(0);\n    }\n  }, {\n    key: \"writeBuffer\",\n    value: function writeBuffer(value) {\n      var length = value.length;\n      this.makeRoomFor(length);\n      value.copy(this.buffer, this.position);\n      this.position += length;\n    }\n  }, {\n    key: \"writeMoney\",\n    value: function writeMoney(value) {\n      this.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32));\n      this.writeInt32LE(value & -1);\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      this.newBuffer(0);\n      return this.compositeBuffer;\n    }\n  }]);\n\n  return WritableTrackingBuffer;\n}();\n\nvar _default = WritableTrackingBuffer;\nexports.default = _default;\nmodule.exports = WritableTrackingBuffer;","map":null,"metadata":{},"sourceType":"script"}