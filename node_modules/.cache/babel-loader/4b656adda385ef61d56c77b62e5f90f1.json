{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nimport { HttpHeaders } from \"./httpHeaders\";\nimport { RestError } from \"./restError\";\n/**\n * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.\n */\n\nvar XhrHttpClient =\n/** @class */\nfunction () {\n  function XhrHttpClient() {}\n\n  XhrHttpClient.prototype.sendRequest = function (request) {\n    var xhr = new XMLHttpRequest();\n\n    if (request.agentSettings) {\n      throw new Error(\"HTTP agent settings not supported in browser environment\");\n    }\n\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n\n    var abortSignal = request.abortSignal;\n\n    if (abortSignal) {\n      var listener_1 = function listener_1() {\n        xhr.abort();\n      };\n\n      abortSignal.addEventListener(\"abort\", listener_1);\n      xhr.addEventListener(\"readystatechange\", function () {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n          abortSignal.removeEventListener(\"abort\", listener_1);\n        }\n      });\n    }\n\n    addProgressListener(xhr.upload, request.onUploadProgress);\n    addProgressListener(xhr, request.onDownloadProgress);\n\n    if (request.formData) {\n      var formData = request.formData;\n      var requestForm_1 = new FormData();\n\n      var appendFormValue = function appendFormValue(key, value) {\n        if (value && value.hasOwnProperty(\"value\") && value.hasOwnProperty(\"options\")) {\n          requestForm_1.append(key, value.value, value.options);\n        } else {\n          requestForm_1.append(key, value);\n        }\n      };\n\n      for (var _i = 0, _a = Object.keys(formData); _i < _a.length; _i++) {\n        var formKey = _a[_i];\n        var formValue = formData[formKey];\n\n        if (Array.isArray(formValue)) {\n          for (var j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j]);\n          }\n        } else {\n          appendFormValue(formKey, formValue);\n        }\n      }\n\n      request.body = requestForm_1;\n      request.formData = undefined;\n      var contentType = request.headers.get(\"Content-Type\");\n\n      if (contentType && contentType.indexOf(\"multipart/form-data\") !== -1) {\n        // browser will automatically apply a suitable content-type header\n        request.headers.remove(\"Content-Type\");\n      }\n    }\n\n    xhr.open(request.method, request.url);\n    xhr.timeout = request.timeout;\n    xhr.withCredentials = request.withCredentials;\n\n    for (var _b = 0, _c = request.headers.headersArray(); _b < _c.length; _b++) {\n      var header = _c[_b];\n      xhr.setRequestHeader(header.name, header.value);\n    }\n\n    xhr.responseType = request.streamResponseBody ? \"blob\" : \"text\"; // tslint:disable-next-line:no-null-keyword\n\n    xhr.send(request.body === undefined ? null : request.body);\n\n    if (request.streamResponseBody) {\n      return new Promise(function (resolve, reject) {\n        xhr.addEventListener(\"readystatechange\", function () {\n          // Resolve as soon as headers are loaded\n          if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n            var blobBody = new Promise(function (resolve, reject) {\n              xhr.addEventListener(\"load\", function () {\n                resolve(xhr.response);\n              });\n              rejectOnTerminalEvent(request, xhr, reject);\n            });\n            resolve({\n              request: request,\n              status: xhr.status,\n              headers: parseHeaders(xhr),\n              blobBody: blobBody\n            });\n          }\n        });\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    } else {\n      return new Promise(function (resolve, reject) {\n        xhr.addEventListener(\"load\", function () {\n          return resolve({\n            request: request,\n            status: xhr.status,\n            headers: parseHeaders(xhr),\n            bodyAsText: xhr.responseText\n          });\n        });\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    }\n  };\n\n  return XhrHttpClient;\n}();\n\nexport { XhrHttpClient };\n\nfunction addProgressListener(xhr, listener) {\n  if (listener) {\n    xhr.addEventListener(\"progress\", function (rawEvent) {\n      return listener({\n        loadedBytes: rawEvent.loaded\n      });\n    });\n  }\n} // exported locally for testing\n\n\nexport function parseHeaders(xhr) {\n  var responseHeaders = new HttpHeaders();\n  var headerLines = xhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/);\n\n  for (var _i = 0, headerLines_1 = headerLines; _i < headerLines_1.length; _i++) {\n    var line = headerLines_1[_i];\n    var index = line.indexOf(\":\");\n    var headerName = line.slice(0, index);\n    var headerValue = line.slice(index + 2);\n    responseHeaders.set(headerName, headerValue);\n  }\n\n  return responseHeaders;\n}\n\nfunction rejectOnTerminalEvent(request, xhr, reject) {\n  xhr.addEventListener(\"error\", function () {\n    return reject(new RestError(\"Failed to send request to \" + request.url, RestError.REQUEST_SEND_ERROR, undefined, request));\n  });\n  xhr.addEventListener(\"abort\", function () {\n    return reject(new RestError(\"The request was aborted\", RestError.REQUEST_ABORTED_ERROR, undefined, request));\n  });\n  xhr.addEventListener(\"timeout\", function () {\n    return reject(new RestError(\"timeout of \" + xhr.timeout + \"ms exceeded\", RestError.REQUEST_SEND_ERROR, undefined, request));\n  });\n}","map":null,"metadata":{},"sourceType":"module"}